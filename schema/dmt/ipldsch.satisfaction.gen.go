package schemadmt

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n _AnyScalar) AsInterface() _AnyScalar__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _AnyScalar__Maybe struct {
	m schema.Maybe
	v AnyScalar
}
type MaybeAnyScalar = *_AnyScalar__Maybe

func (m MaybeAnyScalar) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAnyScalar) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAnyScalar) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAnyScalar) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeAnyScalar) Must() AnyScalar {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__AnyScalar_Bool = _String{"Bool"}
	memberName__AnyScalar_String = _String{"String"}
	memberName__AnyScalar_Bytes = _String{"Bytes"}
	memberName__AnyScalar_Int = _String{"Int"}
	memberName__AnyScalar_Float = _String{"Float"}
)
var _ ipld.Node = (AnyScalar)(&_AnyScalar{})
var _ schema.TypedNode = (AnyScalar)(&_AnyScalar{})
func (AnyScalar) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n AnyScalar) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Bool":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "String":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "Bytes":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "Int":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "Float":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n AnyScalar) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (AnyScalar) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.LookupByIndex(0)
}
func (n AnyScalar) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n AnyScalar) MapIterator() ipld.MapIterator {
	return &_AnyScalar__MapItr{n, false}
}

type _AnyScalar__MapItr struct {
	n AnyScalar
	done bool
}

func (itr *_AnyScalar__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__AnyScalar_Bool, &itr.n.x1
	case 2:
		k, v = &memberName__AnyScalar_String, &itr.n.x2
	case 3:
		k, v = &memberName__AnyScalar_Bytes, &itr.n.x3
	case 4:
		k, v = &memberName__AnyScalar_Int, &itr.n.x4
	case 5:
		k, v = &memberName__AnyScalar_Float, &itr.n.x5
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_AnyScalar__MapItr) Done() bool {
	return itr.done
}

func (AnyScalar) ListIterator() ipld.ListIterator {
	return nil
}
func (AnyScalar) Length() int {
	return 1
}
func (AnyScalar) IsAbsent() bool {
	return false
}
func (AnyScalar) IsNull() bool {
	return false
}
func (AnyScalar) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsBool()
}
func (AnyScalar) AsInt() (int, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsInt()
}
func (AnyScalar) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsFloat()
}
func (AnyScalar) AsString() (string, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsString()
}
func (AnyScalar) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsBytes()
}
func (AnyScalar) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.AnyScalar"}.AsLink()
}
func (AnyScalar) Prototype() ipld.NodePrototype {
	return _AnyScalar__Prototype{}
}
type _AnyScalar__Prototype struct{}

func (_AnyScalar__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AnyScalar__Builder
	nb.Reset()
	return &nb
}
type _AnyScalar__Builder struct {
	_AnyScalar__Assembler
}
func (nb *_AnyScalar__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AnyScalar__Builder) Reset() {
	var w _AnyScalar
	var m schema.Maybe
	*nb = _AnyScalar__Builder{_AnyScalar__Assembler{w: &w, m: &m}}
}
type _AnyScalar__Assembler struct {
	w *_AnyScalar
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _Bool__Assembler
	
	ca2 _String__Assembler
	
	ca3 _Bytes__Assembler
	
	ca4 _Int__Assembler
	
	ca5 _Float__Assembler
	ca uint
}
func (na *_AnyScalar__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_AnyScalar__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	return na, nil
}
func (_AnyScalar__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.BeginList(0)
}
func (na *_AnyScalar__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AnyScalar__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignBool(false)
}
func (_AnyScalar__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignInt(0)
}
func (_AnyScalar__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignFloat(0)
}
func (_AnyScalar__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignString("")
}
func (_AnyScalar__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignBytes(nil)
}
func (_AnyScalar__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.AnyScalar"}.AssignLink(nil)
}
func (na *_AnyScalar__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AnyScalar); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AnyScalar__Assembler) Prototype() ipld.NodePrototype {
	return _AnyScalar__Prototype{}
}
func (ma *_AnyScalar__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_AnyScalar__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.AnyScalar", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Bool":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "String":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "Bytes":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "Int":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "Float":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.AnyScalar", Key:&_String{k}}
	}
}
func (ma *_AnyScalar__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AnyScalar__KeyAssembler)(ma)
}
func (ma *_AnyScalar__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	default:
		panic("unreachable")
	}
}
func (ma *_AnyScalar__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.AnyScalar", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AnyScalar__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AnyScalar__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "Bool":
		return _Bool__Prototype{}
	case "String":
		return _String__Prototype{}
	case "Bytes":
		return _Bytes__Prototype{}
	case "Int":
		return _Int__Prototype{}
	case "Float":
		return _Float__Prototype{}
	default:
		return nil
	}
}
type _AnyScalar__KeyAssembler _AnyScalar__Assembler
func (_AnyScalar__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.BeginMap(0)
}
func (_AnyScalar__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.BeginList(0)
}
func (na *_AnyScalar__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignNull()
}
func (_AnyScalar__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignBool(false)
}
func (_AnyScalar__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignInt(0)
}
func (_AnyScalar__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AnyScalar__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.AnyScalar", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Bool":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "String":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "Bytes":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "Int":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "Float":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.AnyScalar", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_AnyScalar__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignBytes(nil)
}
func (_AnyScalar__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.AnyScalar.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AnyScalar__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AnyScalar__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (AnyScalar) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AnyScalar) Representation() ipld.Node {
	return (*_AnyScalar__Repr)(n)
}
type _AnyScalar__Repr _AnyScalar
var _ ipld.Node = &_AnyScalar__Repr{}
func (n *_AnyScalar__Repr) ReprKind() ipld.ReprKind {
	switch n.tag {
	case 1:
		return ipld.ReprKind_Bool
	case 2:
		return ipld.ReprKind_String
	case 3:
		return ipld.ReprKind_Bytes
	case 4:
		return ipld.ReprKind_Int
	case 5:
		return ipld.ReprKind_Float
	default:
		panic("unreachable")
	}
}
func (n *_AnyScalar__Repr) LookupByString(key string) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "LookupByString", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: n.ReprKind()}
}
func (n *_AnyScalar__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "LookupByNode", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
}
func (n *_AnyScalar__Repr) LookupByIndex(idx int) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "LookupByIndex", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: n.ReprKind()}
}
func (n *_AnyScalar__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "LookupBySegment", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
}
func (n *_AnyScalar__Repr) MapIterator() ipld.MapIterator {
		return nil
}
func (n *_AnyScalar__Repr) ListIterator() ipld.ListIterator {
		return nil
}
func (n *_AnyScalar__Repr) Length() int {
		return -1
}
func (n *_AnyScalar__Repr) IsAbsent() bool {
	return false
}
func (n *_AnyScalar__Repr) IsNull() bool {
	return false
}
func (n *_AnyScalar__Repr) AsBool() (bool, error) {
	switch n.tag {
	case 1:
		return n.x1.Representation().AsBool()
	default:
		return false, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsBool", AppropriateKind: ipld.ReprKindSet_JustBool, ActualKind: n.ReprKind()}
	}
}
func (n *_AnyScalar__Repr) AsInt() (int, error) {
	switch n.tag {
	case 4:
		return n.x4.Representation().AsInt()
	default:
		return 0, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsInt", AppropriateKind: ipld.ReprKindSet_JustInt, ActualKind: n.ReprKind()}
	}
}
func (n *_AnyScalar__Repr) AsFloat() (float64, error) {
	switch n.tag {
	case 5:
		return n.x5.Representation().AsFloat()
	default:
		return 0, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsFloat", AppropriateKind: ipld.ReprKindSet_JustFloat, ActualKind: n.ReprKind()}
	}
}
func (n *_AnyScalar__Repr) AsString() (string, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().AsString()
	default:
		return "", ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsString", AppropriateKind: ipld.ReprKindSet_JustString, ActualKind: n.ReprKind()}
	}
}
func (n *_AnyScalar__Repr) AsBytes() ([]byte, error) {
	switch n.tag {
	case 3:
		return n.x3.Representation().AsBytes()
	default:
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsBytes", AppropriateKind: ipld.ReprKindSet_JustBytes, ActualKind: n.ReprKind()}
	}
}
func (n *_AnyScalar__Repr) AsLink() (ipld.Link, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.AnyScalar.Repr", MethodName: "AsLink", AppropriateKind: ipld.ReprKindSet_JustLink, ActualKind: n.ReprKind()}
}
func (_AnyScalar__Repr) Prototype() ipld.NodePrototype {
	return _AnyScalar__ReprPrototype{}
}
type _AnyScalar__ReprPrototype struct{}

func (_AnyScalar__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AnyScalar__ReprBuilder
	nb.Reset()
	return &nb
}
type _AnyScalar__ReprBuilder struct {
	_AnyScalar__ReprAssembler
}
func (nb *_AnyScalar__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AnyScalar__ReprBuilder) Reset() {
	var w _AnyScalar
	var m schema.Maybe
	*nb = _AnyScalar__ReprBuilder{_AnyScalar__ReprAssembler{w: &w, m: &m}}
}
type _AnyScalar__ReprAssembler struct {
	w *_AnyScalar
	m *schema.Maybe
	ca1 _Bool__ReprAssembler
	ca2 _String__ReprAssembler
	ca3 _Bytes__ReprAssembler
	ca4 _Int__ReprAssembler
	ca5 _Float__ReprAssembler
	ca uint
}
func (na *_AnyScalar__ReprAssembler) reset() {
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	case 2:
		na.ca2.reset()
	case 3:
		na.ca3.reset()
	case 4:
		na.ca4.reset()
	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
}
func (na *_AnyScalar__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return nil, schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "BeginMap called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return nil, schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "BeginList called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignNull() error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignNull called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignBool(v bool) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	na.ca = 1
	na.w.tag = 1
	na.ca1.w = &na.w.x1
	na.ca1.m = na.m
	return na.ca1.AssignBool(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignBool called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignInt(v int) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	na.ca = 4
	na.w.tag = 4
	na.ca4.w = &na.w.x4
	na.ca4.m = na.m
	return na.ca4.AssignInt(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignInt called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignFloat(v float64) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	na.ca = 5
	na.w.tag = 5
	na.ca5.w = &na.w.x5
	na.ca5.m = na.m
	return na.ca5.AssignFloat(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignFloat called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignString(v string) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	na.ca = 2
	na.w.tag = 2
	na.ca2.w = &na.w.x2
	na.ca2.m = na.m
	return na.ca2.AssignString(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignString called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignBytes(v []byte) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_AnyScalar{}
	}
	na.ca = 3
	na.w.tag = 3
	na.ca3.w = &na.w.x3
	na.ca3.m = na.m
	return na.ca3.AssignBytes(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignBytes called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignLink(v ipld.Link) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.AnyScalar.Repr", Detail: "AssignLink called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_AnyScalar__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AnyScalar); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	switch v.ReprKind() {
	case ipld.ReprKind_Bool:
		v2, _ := v.AsBool()
		return na.AssignBool(v2)
	case ipld.ReprKind_Int:
		v2, _ := v.AsInt()
		return na.AssignInt(v2)
	case ipld.ReprKind_Float:
		v2, _ := v.AsFloat()
		return na.AssignFloat(v2)
	case ipld.ReprKind_String:
		v2, _ := v.AsString()
		return na.AssignString(v2)
	case ipld.ReprKind_Bytes:
		v2, _ := v.AsBytes()
		return na.AssignBytes(v2)
	case ipld.ReprKind_Map:
		na, err := na.BeginMap(v.Length())
		if err != nil {
			return err
		}
		itr := v.MapIterator()
		for !itr.Done() {
			k, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleKey().AssignNode(k); err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_List:
		na, err := na.BeginList(v.Length())
		if err != nil {
			return err
		}
		itr := v.ListIterator()
		for !itr.Done() {
			_, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_Link:
		v2, _ := v.AsLink()
		return na.AssignLink(v2)
	default:
		panic("unreachable")
	}
}
func (na *_AnyScalar__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AnyScalar__ReprPrototype{}
}

func (n Bool) Bool() bool {
	return n.x
}
func (_Bool__Prototype) FromBool(v bool) (Bool, error) {
	n := _Bool{v}
	return &n, nil
}
type _Bool__Maybe struct {
	m schema.Maybe
	v Bool
}
type MaybeBool = *_Bool__Maybe

func (m MaybeBool) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBool) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBool) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBool) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeBool) Must() Bool {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Bool)(&_Bool{})
var _ schema.TypedNode = (Bool)(&_Bool{})
func (Bool) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Bool
}
func (Bool) LookupByString(string) (ipld.Node, error) {
	return mixins.Bool{"schemadmt.Bool"}.LookupByString("")
}
func (Bool) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bool{"schemadmt.Bool"}.LookupByNode(nil)
}
func (Bool) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Bool{"schemadmt.Bool"}.LookupByIndex(0)
}
func (Bool) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bool{"schemadmt.Bool"}.LookupBySegment(seg)
}
func (Bool) MapIterator() ipld.MapIterator {
	return nil
}
func (Bool) ListIterator() ipld.ListIterator {
	return nil
}
func (Bool) Length() int {
	return -1
}
func (Bool) IsAbsent() bool {
	return false
}
func (Bool) IsNull() bool {
	return false
}
func (n Bool) AsBool() (bool, error) {
	return n.x, nil
}
func (Bool) AsInt() (int, error) {
	return mixins.Bool{"schemadmt.Bool"}.AsInt()
}
func (Bool) AsFloat() (float64, error) {
	return mixins.Bool{"schemadmt.Bool"}.AsFloat()
}
func (Bool) AsString() (string, error) {
	return mixins.Bool{"schemadmt.Bool"}.AsString()
}
func (Bool) AsBytes() ([]byte, error) {
	return mixins.Bool{"schemadmt.Bool"}.AsBytes()
}
func (Bool) AsLink() (ipld.Link, error) {
	return mixins.Bool{"schemadmt.Bool"}.AsLink()
}
func (Bool) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}
type _Bool__Prototype struct{}

func (_Bool__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bool__Builder
	nb.Reset()
	return &nb
}
type _Bool__Builder struct {
	_Bool__Assembler
}
func (nb *_Bool__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bool__Builder) Reset() {
	var w _Bool
	var m schema.Maybe
	*nb = _Bool__Builder{_Bool__Assembler{w: &w, m: &m}}
}
type _Bool__Assembler struct {
	w *_Bool
	m *schema.Maybe
}

func (na *_Bool__Assembler) reset() {}
func (_Bool__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.BoolAssembler{"schemadmt.Bool"}.BeginMap(0)
}
func (_Bool__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.BoolAssembler{"schemadmt.Bool"}.BeginList(0)
}
func (na *_Bool__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BoolAssembler{"schemadmt.Bool"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (na *_Bool__Assembler) AssignBool(v bool) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bool{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bool__Assembler) AssignInt(int) error {
	return mixins.BoolAssembler{"schemadmt.Bool"}.AssignInt(0)
}
func (_Bool__Assembler) AssignFloat(float64) error {
	return mixins.BoolAssembler{"schemadmt.Bool"}.AssignFloat(0)
}
func (_Bool__Assembler) AssignString(string) error {
	return mixins.BoolAssembler{"schemadmt.Bool"}.AssignString("")
}
func (_Bool__Assembler) AssignBytes([]byte) error {
	return mixins.BoolAssembler{"schemadmt.Bool"}.AssignBytes(nil)
}
func (_Bool__Assembler) AssignLink(ipld.Link) error {
	return mixins.BoolAssembler{"schemadmt.Bool"}.AssignLink(nil)
}
func (na *_Bool__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bool); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBool(); err != nil {
		return err
	} else {
		return na.AssignBool(v2)
	}
}
func (_Bool__Assembler) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}
func (Bool) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bool) Representation() ipld.Node {
	return (*_Bool__Repr)(n)
}
type _Bool__Repr = _Bool
var _ ipld.Node = &_Bool__Repr{}
type _Bool__ReprPrototype = _Bool__Prototype
type _Bool__ReprAssembler = _Bool__Assembler

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}
type _Bytes__Maybe struct {
	m schema.Maybe
	v Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})
func (Bytes) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"schemadmt.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}
type _Bytes__Builder struct {
	_Bytes__Assembler
}
func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}
type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int) error {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"schemadmt.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}
type _Bytes__Repr = _Bytes
var _ ipld.Node = &_Bytes__Repr{}
type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler

func (n _EnumRepresentation) AsInterface() _EnumRepresentation__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _EnumRepresentation__Maybe struct {
	m schema.Maybe
	v EnumRepresentation
}
type MaybeEnumRepresentation = *_EnumRepresentation__Maybe

func (m MaybeEnumRepresentation) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEnumRepresentation) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEnumRepresentation) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEnumRepresentation) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeEnumRepresentation) Must() EnumRepresentation {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__EnumRepresentation_EnumRepresentation_String = _String{"EnumRepresentation_String"}
	memberName__EnumRepresentation_EnumRepresentation_Int = _String{"EnumRepresentation_Int"}
)
var _ ipld.Node = (EnumRepresentation)(&_EnumRepresentation{})
var _ schema.TypedNode = (EnumRepresentation)(&_EnumRepresentation{})
func (EnumRepresentation) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n EnumRepresentation) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "EnumRepresentation_String":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "EnumRepresentation_Int":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n EnumRepresentation) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (EnumRepresentation) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.LookupByIndex(0)
}
func (n EnumRepresentation) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EnumRepresentation) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation__MapItr{n, false}
}

type _EnumRepresentation__MapItr struct {
	n EnumRepresentation
	done bool
}

func (itr *_EnumRepresentation__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__EnumRepresentation_EnumRepresentation_String, &itr.n.x1
	case 2:
		k, v = &memberName__EnumRepresentation_EnumRepresentation_Int, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_EnumRepresentation__MapItr) Done() bool {
	return itr.done
}

func (EnumRepresentation) ListIterator() ipld.ListIterator {
	return nil
}
func (EnumRepresentation) Length() int {
	return 1
}
func (EnumRepresentation) IsAbsent() bool {
	return false
}
func (EnumRepresentation) IsNull() bool {
	return false
}
func (EnumRepresentation) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsBool()
}
func (EnumRepresentation) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsInt()
}
func (EnumRepresentation) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsFloat()
}
func (EnumRepresentation) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsString()
}
func (EnumRepresentation) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsBytes()
}
func (EnumRepresentation) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation"}.AsLink()
}
func (EnumRepresentation) Prototype() ipld.NodePrototype {
	return _EnumRepresentation__Prototype{}
}
type _EnumRepresentation__Prototype struct{}

func (_EnumRepresentation__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation__Builder
	nb.Reset()
	return &nb
}
type _EnumRepresentation__Builder struct {
	_EnumRepresentation__Assembler
}
func (nb *_EnumRepresentation__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation__Builder) Reset() {
	var w _EnumRepresentation
	var m schema.Maybe
	*nb = _EnumRepresentation__Builder{_EnumRepresentation__Assembler{w: &w, m: &m}}
}
type _EnumRepresentation__Assembler struct {
	w *_EnumRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _EnumRepresentation_String__Assembler
	
	ca2 _EnumRepresentation_Int__Assembler
	ca uint
}
func (na *_EnumRepresentation__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_EnumRepresentation__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EnumRepresentation{}
	}
	return na, nil
}
func (_EnumRepresentation__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.BeginList(0)
}
func (na *_EnumRepresentation__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignBool(false)
}
func (_EnumRepresentation__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignInt(0)
}
func (_EnumRepresentation__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignFloat(0)
}
func (_EnumRepresentation__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignString("")
}
func (_EnumRepresentation__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignBytes(nil)
}
func (_EnumRepresentation__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation"}.AssignLink(nil)
}
func (na *_EnumRepresentation__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation__Assembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation__Prototype{}
}
func (ma *_EnumRepresentation__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "EnumRepresentation_String":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "EnumRepresentation_Int":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation", Key:&_String{k}}
	}
}
func (ma *_EnumRepresentation__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EnumRepresentation__KeyAssembler)(ma)
}
func (ma *_EnumRepresentation__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_EnumRepresentation__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EnumRepresentation__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "EnumRepresentation_String":
		return _EnumRepresentation_String__Prototype{}
	case "EnumRepresentation_Int":
		return _EnumRepresentation_Int__Prototype{}
	default:
		return nil
	}
}
type _EnumRepresentation__KeyAssembler _EnumRepresentation__Assembler
func (_EnumRepresentation__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.BeginMap(0)
}
func (_EnumRepresentation__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.BeginList(0)
}
func (na *_EnumRepresentation__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignNull()
}
func (_EnumRepresentation__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignBool(false)
}
func (_EnumRepresentation__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignInt(0)
}
func (_EnumRepresentation__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EnumRepresentation__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "EnumRepresentation_String":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "EnumRepresentation_Int":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_EnumRepresentation__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignBytes(nil)
}
func (_EnumRepresentation__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EnumRepresentation__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EnumRepresentation__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (EnumRepresentation) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EnumRepresentation) Representation() ipld.Node {
	return (*_EnumRepresentation__Repr)(n)
}
type _EnumRepresentation__Repr _EnumRepresentation
var (
	memberName__EnumRepresentation_EnumRepresentation_String_serial = _String{"string"}
	memberName__EnumRepresentation_EnumRepresentation_Int_serial = _String{"int"}
)
var _ ipld.Node = &_EnumRepresentation__Repr{}
func (_EnumRepresentation__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_EnumRepresentation__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "string":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "int":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_EnumRepresentation__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_EnumRepresentation__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.LookupByIndex(0)
}
func (n _EnumRepresentation__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_EnumRepresentation__Repr) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation__ReprMapItr{n, false}
}

type _EnumRepresentation__ReprMapItr struct {
	n *_EnumRepresentation__Repr
	done bool
}

func (itr *_EnumRepresentation__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__EnumRepresentation_EnumRepresentation_String_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__EnumRepresentation_EnumRepresentation_Int_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_EnumRepresentation__ReprMapItr) Done() bool {
	return itr.done
}

func (_EnumRepresentation__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_EnumRepresentation__Repr) Length() int {
	return 1
}
func (_EnumRepresentation__Repr) IsAbsent() bool {
	return false
}
func (_EnumRepresentation__Repr) IsNull() bool {
	return false
}
func (_EnumRepresentation__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsBool()
}
func (_EnumRepresentation__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsInt()
}
func (_EnumRepresentation__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsFloat()
}
func (_EnumRepresentation__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsString()
}
func (_EnumRepresentation__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsBytes()
}
func (_EnumRepresentation__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation.Repr"}.AsLink()
}
func (_EnumRepresentation__Repr) Prototype() ipld.NodePrototype {
	return _EnumRepresentation__ReprPrototype{}
}
type _EnumRepresentation__ReprPrototype struct{}

func (_EnumRepresentation__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation__ReprBuilder
	nb.Reset()
	return &nb
}
type _EnumRepresentation__ReprBuilder struct {
	_EnumRepresentation__ReprAssembler
}
func (nb *_EnumRepresentation__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation__ReprBuilder) Reset() {
	var w _EnumRepresentation
	var m schema.Maybe
	*nb = _EnumRepresentation__ReprBuilder{_EnumRepresentation__ReprAssembler{w: &w, m: &m}}
}
type _EnumRepresentation__ReprAssembler struct {
	w *_EnumRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _EnumRepresentation_String__ReprAssembler
	
	ca2 _EnumRepresentation_Int__ReprAssembler
	ca uint
}
func (na *_EnumRepresentation__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_EnumRepresentation__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EnumRepresentation{}
	}
	return na, nil
}
func (_EnumRepresentation__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.BeginList(0)
}
func (na *_EnumRepresentation__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignBool(false)
}
func (_EnumRepresentation__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignInt(0)
}
func (_EnumRepresentation__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignFloat(0)
}
func (_EnumRepresentation__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignString("")
}
func (_EnumRepresentation__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignBytes(nil)
}
func (_EnumRepresentation__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation.Repr"}.AssignLink(nil)
}
func (na *_EnumRepresentation__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation__ReprPrototype{}
}
func (ma *_EnumRepresentation__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "string":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "int":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation.Repr", Key:&_String{k}}
	}
}
func (ma *_EnumRepresentation__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EnumRepresentation__ReprKeyAssembler)(ma)
}
func (ma *_EnumRepresentation__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_EnumRepresentation__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EnumRepresentation__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "EnumRepresentation_String":
		return _EnumRepresentation_String__ReprPrototype{}
	case "EnumRepresentation_Int":
		return _EnumRepresentation_Int__ReprPrototype{}
	default:
		return nil
	}
}
type _EnumRepresentation__ReprKeyAssembler _EnumRepresentation__ReprAssembler
func (_EnumRepresentation__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.BeginMap(0)
}
func (_EnumRepresentation__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_EnumRepresentation__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignNull()
}
func (_EnumRepresentation__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignBool(false)
}
func (_EnumRepresentation__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignInt(0)
}
func (_EnumRepresentation__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EnumRepresentation__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.EnumRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "string":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "int":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_EnumRepresentation__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_EnumRepresentation__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.EnumRepresentation.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EnumRepresentation__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EnumRepresentation__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_EnumRepresentation_Int) Lookup(k EnumValue) Int {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_EnumRepresentation_Int) LookupMaybe(k EnumValue) MaybeInt {
	v, exists := n.m[*k]
	if !exists {
		return &_EnumRepresentation_Int__valueAbsent
	}
	return &_Int__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _EnumRepresentation_Int__valueAbsent = _Int__Maybe{m:schema.Maybe_Absent}
func (n EnumRepresentation_Int) Iterator() *EnumRepresentation_Int__Itr {
	return &EnumRepresentation_Int__Itr{n, 0}
}

type EnumRepresentation_Int__Itr struct {
	n EnumRepresentation_Int
	idx  int
}

func (itr *EnumRepresentation_Int__Itr) Next() (k EnumValue, v Int) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *EnumRepresentation_Int__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _EnumRepresentation_Int__Maybe struct {
	m schema.Maybe
	v EnumRepresentation_Int
}
type MaybeEnumRepresentation_Int = *_EnumRepresentation_Int__Maybe

func (m MaybeEnumRepresentation_Int) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEnumRepresentation_Int) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEnumRepresentation_Int) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEnumRepresentation_Int) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeEnumRepresentation_Int) Must() EnumRepresentation_Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (EnumRepresentation_Int)(&_EnumRepresentation_Int{})
var _ schema.TypedNode = (EnumRepresentation_Int)(&_EnumRepresentation_Int{})
func (EnumRepresentation_Int) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n EnumRepresentation_Int) LookupByString(k string) (ipld.Node, error) {
	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n EnumRepresentation_Int) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(EnumValue)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation_Int", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (EnumRepresentation_Int) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.LookupByIndex(0)
}
func (n EnumRepresentation_Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EnumRepresentation_Int) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation_Int__MapItr{n, 0}
}

type _EnumRepresentation_Int__MapItr struct {
	n EnumRepresentation_Int
	idx  int
}

func (itr *_EnumRepresentation_Int__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_EnumRepresentation_Int__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (EnumRepresentation_Int) ListIterator() ipld.ListIterator {
	return nil
}
func (n EnumRepresentation_Int) Length() int {
	return len(n.t)
}
func (EnumRepresentation_Int) IsAbsent() bool {
	return false
}
func (EnumRepresentation_Int) IsNull() bool {
	return false
}
func (EnumRepresentation_Int) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsBool()
}
func (EnumRepresentation_Int) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsInt()
}
func (EnumRepresentation_Int) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsFloat()
}
func (EnumRepresentation_Int) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsString()
}
func (EnumRepresentation_Int) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsBytes()
}
func (EnumRepresentation_Int) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int"}.AsLink()
}
func (EnumRepresentation_Int) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_Int__Prototype{}
}
type _EnumRepresentation_Int__Prototype struct{}

func (_EnumRepresentation_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation_Int__Builder
	nb.Reset()
	return &nb
}
type _EnumRepresentation_Int__Builder struct {
	_EnumRepresentation_Int__Assembler
}
func (nb *_EnumRepresentation_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation_Int__Builder) Reset() {
	var w _EnumRepresentation_Int
	var m schema.Maybe
	*nb = _EnumRepresentation_Int__Builder{_EnumRepresentation_Int__Assembler{w: &w, m: &m}}
}
type _EnumRepresentation_Int__Assembler struct {
	w *_EnumRepresentation_Int
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__Assembler
	va _Int__Assembler
}

func (na *_EnumRepresentation_Int__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_EnumRepresentation_Int__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EnumRepresentation_Int{}
	}
	na.w.m = make(map[_EnumValue]*_Int, sizeHint)
	na.w.t = make([]_EnumRepresentation_Int__entry, 0, sizeHint)
	return na, nil
}
func (_EnumRepresentation_Int__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.BeginList(0)
}
func (na *_EnumRepresentation_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation_Int__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignBool(false)
}
func (_EnumRepresentation_Int__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignInt(0)
}
func (_EnumRepresentation_Int__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignFloat(0)
}
func (_EnumRepresentation_Int__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignString("")
}
func (_EnumRepresentation_Int__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignBytes(nil)
}
func (_EnumRepresentation_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int"}.AssignLink(nil)
}
func (na *_EnumRepresentation_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation_Int", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation_Int__Assembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_Int__Prototype{}
}
func (ma *_EnumRepresentation_Int__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_Int__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_Int__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_Int__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_EnumRepresentation_Int__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_Int__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_EnumRepresentation_Int__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_EnumRepresentation_Int__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation_Int__Assembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__Prototype{}
}
func (ma *_EnumRepresentation_Int__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Int__Prototype{}
}
func (EnumRepresentation_Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EnumRepresentation_Int) Representation() ipld.Node {
	return (*_EnumRepresentation_Int__Repr)(n)
}
type _EnumRepresentation_Int__Repr _EnumRepresentation_Int
var _ ipld.Node = &_EnumRepresentation_Int__Repr{}
func (_EnumRepresentation_Int__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_EnumRepresentation_Int__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (EnumRepresentation_Int)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Int).Representation(), nil
}
func (nr *_EnumRepresentation_Int__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (EnumRepresentation_Int)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Int).Representation(), nil
}
func (_EnumRepresentation_Int__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.LookupByIndex(0)
}
func (n _EnumRepresentation_Int__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_EnumRepresentation_Int__Repr) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation_Int__ReprMapItr{(EnumRepresentation_Int)(nr), 0}
}

type _EnumRepresentation_Int__ReprMapItr _EnumRepresentation_Int__MapItr

func (itr *_EnumRepresentation_Int__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_EnumRepresentation_Int__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(Int).Representation(), nil
}
func (itr *_EnumRepresentation_Int__ReprMapItr) Done() bool {
	return (*_EnumRepresentation_Int__MapItr)(itr).Done()
}

func (_EnumRepresentation_Int__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_EnumRepresentation_Int__Repr) Length() int {
	return len(rn.t)
}
func (_EnumRepresentation_Int__Repr) IsAbsent() bool {
	return false
}
func (_EnumRepresentation_Int__Repr) IsNull() bool {
	return false
}
func (_EnumRepresentation_Int__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsBool()
}
func (_EnumRepresentation_Int__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsInt()
}
func (_EnumRepresentation_Int__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsFloat()
}
func (_EnumRepresentation_Int__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsString()
}
func (_EnumRepresentation_Int__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsBytes()
}
func (_EnumRepresentation_Int__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_Int.Repr"}.AsLink()
}
func (_EnumRepresentation_Int__Repr) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_Int__ReprPrototype{}
}
type _EnumRepresentation_Int__ReprPrototype struct{}

func (_EnumRepresentation_Int__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation_Int__ReprBuilder
	nb.Reset()
	return &nb
}
type _EnumRepresentation_Int__ReprBuilder struct {
	_EnumRepresentation_Int__ReprAssembler
}
func (nb *_EnumRepresentation_Int__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation_Int__ReprBuilder) Reset() {
	var w _EnumRepresentation_Int
	var m schema.Maybe
	*nb = _EnumRepresentation_Int__ReprBuilder{_EnumRepresentation_Int__ReprAssembler{w: &w, m: &m}}
}
type _EnumRepresentation_Int__ReprAssembler struct {
	w *_EnumRepresentation_Int
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__ReprAssembler
	va _Int__ReprAssembler
}

func (na *_EnumRepresentation_Int__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_EnumRepresentation_Int__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EnumRepresentation_Int{}
	}
	na.w.m = make(map[_EnumValue]*_Int, sizeHint)
	na.w.t = make([]_EnumRepresentation_Int__entry, 0, sizeHint)
	return na, nil
}
func (_EnumRepresentation_Int__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.BeginList(0)
}
func (na *_EnumRepresentation_Int__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation_Int__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignBool(false)
}
func (_EnumRepresentation_Int__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignInt(0)
}
func (_EnumRepresentation_Int__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignFloat(0)
}
func (_EnumRepresentation_Int__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignString("")
}
func (_EnumRepresentation_Int__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignBytes(nil)
}
func (_EnumRepresentation_Int__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_Int.Repr"}.AssignLink(nil)
}
func (na *_EnumRepresentation_Int__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation_Int.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation_Int__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_Int__ReprPrototype{}
}
func (ma *_EnumRepresentation_Int__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_Int__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_Int__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_Int__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_EnumRepresentation_Int__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_Int__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_EnumRepresentation_Int__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_EnumRepresentation_Int__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation_Int__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__ReprPrototype{}
}
func (ma *_EnumRepresentation_Int__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Int__ReprPrototype{}
}

func (n *_EnumRepresentation_String) Lookup(k EnumValue) String {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_EnumRepresentation_String) LookupMaybe(k EnumValue) MaybeString {
	v, exists := n.m[*k]
	if !exists {
		return &_EnumRepresentation_String__valueAbsent
	}
	return &_String__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _EnumRepresentation_String__valueAbsent = _String__Maybe{m:schema.Maybe_Absent}
func (n EnumRepresentation_String) Iterator() *EnumRepresentation_String__Itr {
	return &EnumRepresentation_String__Itr{n, 0}
}

type EnumRepresentation_String__Itr struct {
	n EnumRepresentation_String
	idx  int
}

func (itr *EnumRepresentation_String__Itr) Next() (k EnumValue, v String) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *EnumRepresentation_String__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _EnumRepresentation_String__Maybe struct {
	m schema.Maybe
	v EnumRepresentation_String
}
type MaybeEnumRepresentation_String = *_EnumRepresentation_String__Maybe

func (m MaybeEnumRepresentation_String) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEnumRepresentation_String) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEnumRepresentation_String) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEnumRepresentation_String) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeEnumRepresentation_String) Must() EnumRepresentation_String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (EnumRepresentation_String)(&_EnumRepresentation_String{})
var _ schema.TypedNode = (EnumRepresentation_String)(&_EnumRepresentation_String{})
func (EnumRepresentation_String) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n EnumRepresentation_String) LookupByString(k string) (ipld.Node, error) {
	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n EnumRepresentation_String) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(EnumValue)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.EnumRepresentation_String", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (EnumRepresentation_String) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.LookupByIndex(0)
}
func (n EnumRepresentation_String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EnumRepresentation_String) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation_String__MapItr{n, 0}
}

type _EnumRepresentation_String__MapItr struct {
	n EnumRepresentation_String
	idx  int
}

func (itr *_EnumRepresentation_String__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_EnumRepresentation_String__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (EnumRepresentation_String) ListIterator() ipld.ListIterator {
	return nil
}
func (n EnumRepresentation_String) Length() int {
	return len(n.t)
}
func (EnumRepresentation_String) IsAbsent() bool {
	return false
}
func (EnumRepresentation_String) IsNull() bool {
	return false
}
func (EnumRepresentation_String) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsBool()
}
func (EnumRepresentation_String) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsInt()
}
func (EnumRepresentation_String) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsFloat()
}
func (EnumRepresentation_String) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsString()
}
func (EnumRepresentation_String) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsBytes()
}
func (EnumRepresentation_String) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String"}.AsLink()
}
func (EnumRepresentation_String) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_String__Prototype{}
}
type _EnumRepresentation_String__Prototype struct{}

func (_EnumRepresentation_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation_String__Builder
	nb.Reset()
	return &nb
}
type _EnumRepresentation_String__Builder struct {
	_EnumRepresentation_String__Assembler
}
func (nb *_EnumRepresentation_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation_String__Builder) Reset() {
	var w _EnumRepresentation_String
	var m schema.Maybe
	*nb = _EnumRepresentation_String__Builder{_EnumRepresentation_String__Assembler{w: &w, m: &m}}
}
type _EnumRepresentation_String__Assembler struct {
	w *_EnumRepresentation_String
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__Assembler
	va _String__Assembler
}

func (na *_EnumRepresentation_String__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_EnumRepresentation_String__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EnumRepresentation_String{}
	}
	na.w.m = make(map[_EnumValue]*_String, sizeHint)
	na.w.t = make([]_EnumRepresentation_String__entry, 0, sizeHint)
	return na, nil
}
func (_EnumRepresentation_String__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.BeginList(0)
}
func (na *_EnumRepresentation_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation_String__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignBool(false)
}
func (_EnumRepresentation_String__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignInt(0)
}
func (_EnumRepresentation_String__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignFloat(0)
}
func (_EnumRepresentation_String__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignString("")
}
func (_EnumRepresentation_String__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignBytes(nil)
}
func (_EnumRepresentation_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String"}.AssignLink(nil)
}
func (na *_EnumRepresentation_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation_String", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation_String__Assembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_String__Prototype{}
}
func (ma *_EnumRepresentation_String__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_String__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_String__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_String__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_EnumRepresentation_String__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_String__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_EnumRepresentation_String__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_EnumRepresentation_String__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation_String__Assembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__Prototype{}
}
func (ma *_EnumRepresentation_String__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _String__Prototype{}
}
func (EnumRepresentation_String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EnumRepresentation_String) Representation() ipld.Node {
	return (*_EnumRepresentation_String__Repr)(n)
}
type _EnumRepresentation_String__Repr _EnumRepresentation_String
var _ ipld.Node = &_EnumRepresentation_String__Repr{}
func (_EnumRepresentation_String__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_EnumRepresentation_String__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (EnumRepresentation_String)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(String).Representation(), nil
}
func (nr *_EnumRepresentation_String__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (EnumRepresentation_String)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(String).Representation(), nil
}
func (_EnumRepresentation_String__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.LookupByIndex(0)
}
func (n _EnumRepresentation_String__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_EnumRepresentation_String__Repr) MapIterator() ipld.MapIterator {
	return &_EnumRepresentation_String__ReprMapItr{(EnumRepresentation_String)(nr), 0}
}

type _EnumRepresentation_String__ReprMapItr _EnumRepresentation_String__MapItr

func (itr *_EnumRepresentation_String__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_EnumRepresentation_String__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(String).Representation(), nil
}
func (itr *_EnumRepresentation_String__ReprMapItr) Done() bool {
	return (*_EnumRepresentation_String__MapItr)(itr).Done()
}

func (_EnumRepresentation_String__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_EnumRepresentation_String__Repr) Length() int {
	return len(rn.t)
}
func (_EnumRepresentation_String__Repr) IsAbsent() bool {
	return false
}
func (_EnumRepresentation_String__Repr) IsNull() bool {
	return false
}
func (_EnumRepresentation_String__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsBool()
}
func (_EnumRepresentation_String__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsInt()
}
func (_EnumRepresentation_String__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsFloat()
}
func (_EnumRepresentation_String__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsString()
}
func (_EnumRepresentation_String__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsBytes()
}
func (_EnumRepresentation_String__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.EnumRepresentation_String.Repr"}.AsLink()
}
func (_EnumRepresentation_String__Repr) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_String__ReprPrototype{}
}
type _EnumRepresentation_String__ReprPrototype struct{}

func (_EnumRepresentation_String__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumRepresentation_String__ReprBuilder
	nb.Reset()
	return &nb
}
type _EnumRepresentation_String__ReprBuilder struct {
	_EnumRepresentation_String__ReprAssembler
}
func (nb *_EnumRepresentation_String__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumRepresentation_String__ReprBuilder) Reset() {
	var w _EnumRepresentation_String
	var m schema.Maybe
	*nb = _EnumRepresentation_String__ReprBuilder{_EnumRepresentation_String__ReprAssembler{w: &w, m: &m}}
}
type _EnumRepresentation_String__ReprAssembler struct {
	w *_EnumRepresentation_String
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__ReprAssembler
	va _String__ReprAssembler
}

func (na *_EnumRepresentation_String__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_EnumRepresentation_String__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EnumRepresentation_String{}
	}
	na.w.m = make(map[_EnumValue]*_String, sizeHint)
	na.w.t = make([]_EnumRepresentation_String__entry, 0, sizeHint)
	return na, nil
}
func (_EnumRepresentation_String__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.BeginList(0)
}
func (na *_EnumRepresentation_String__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EnumRepresentation_String__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignBool(false)
}
func (_EnumRepresentation_String__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignInt(0)
}
func (_EnumRepresentation_String__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignFloat(0)
}
func (_EnumRepresentation_String__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignString("")
}
func (_EnumRepresentation_String__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignBytes(nil)
}
func (_EnumRepresentation_String__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.EnumRepresentation_String.Repr"}.AssignLink(nil)
}
func (na *_EnumRepresentation_String__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumRepresentation_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.EnumRepresentation_String.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EnumRepresentation_String__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EnumRepresentation_String__ReprPrototype{}
}
func (ma *_EnumRepresentation_String__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_String__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_EnumRepresentation_String__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_String__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_EnumRepresentation_String__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _EnumRepresentation_String__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_EnumRepresentation_String__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_EnumRepresentation_String__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EnumRepresentation_String__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__ReprPrototype{}
}
func (ma *_EnumRepresentation_String__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _String__ReprPrototype{}
}

func (n EnumValue) String() string {
	return n.x
}
func (_EnumValue__Prototype) fromString(w *_EnumValue, v string) error {
	*w = _EnumValue{v}
	return nil
}
func (_EnumValue__Prototype) FromString(v string) (EnumValue, error) {
	n := _EnumValue{v}
	return &n, nil
}
type _EnumValue__Maybe struct {
	m schema.Maybe
	v EnumValue
}
type MaybeEnumValue = *_EnumValue__Maybe

func (m MaybeEnumValue) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEnumValue) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEnumValue) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEnumValue) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeEnumValue) Must() EnumValue {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (EnumValue)(&_EnumValue{})
var _ schema.TypedNode = (EnumValue)(&_EnumValue{})
func (EnumValue) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_String
}
func (EnumValue) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"schemadmt.EnumValue"}.LookupByString("")
}
func (EnumValue) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"schemadmt.EnumValue"}.LookupByNode(nil)
}
func (EnumValue) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.String{"schemadmt.EnumValue"}.LookupByIndex(0)
}
func (EnumValue) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"schemadmt.EnumValue"}.LookupBySegment(seg)
}
func (EnumValue) MapIterator() ipld.MapIterator {
	return nil
}
func (EnumValue) ListIterator() ipld.ListIterator {
	return nil
}
func (EnumValue) Length() int {
	return -1
}
func (EnumValue) IsAbsent() bool {
	return false
}
func (EnumValue) IsNull() bool {
	return false
}
func (EnumValue) AsBool() (bool, error) {
	return mixins.String{"schemadmt.EnumValue"}.AsBool()
}
func (EnumValue) AsInt() (int, error) {
	return mixins.String{"schemadmt.EnumValue"}.AsInt()
}
func (EnumValue) AsFloat() (float64, error) {
	return mixins.String{"schemadmt.EnumValue"}.AsFloat()
}
func (n EnumValue) AsString() (string, error) {
	return n.x, nil
}
func (EnumValue) AsBytes() ([]byte, error) {
	return mixins.String{"schemadmt.EnumValue"}.AsBytes()
}
func (EnumValue) AsLink() (ipld.Link, error) {
	return mixins.String{"schemadmt.EnumValue"}.AsLink()
}
func (EnumValue) Prototype() ipld.NodePrototype {
	return _EnumValue__Prototype{}
}
type _EnumValue__Prototype struct{}

func (_EnumValue__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EnumValue__Builder
	nb.Reset()
	return &nb
}
type _EnumValue__Builder struct {
	_EnumValue__Assembler
}
func (nb *_EnumValue__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EnumValue__Builder) Reset() {
	var w _EnumValue
	var m schema.Maybe
	*nb = _EnumValue__Builder{_EnumValue__Assembler{w: &w, m: &m}}
}
type _EnumValue__Assembler struct {
	w *_EnumValue
	m *schema.Maybe
}

func (na *_EnumValue__Assembler) reset() {}
func (_EnumValue__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.BeginMap(0)
}
func (_EnumValue__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.BeginList(0)
}
func (na *_EnumValue__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_EnumValue__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignBool(false)
}
func (_EnumValue__Assembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignInt(0)
}
func (_EnumValue__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignFloat(0)
}
func (na *_EnumValue__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_EnumValue{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_EnumValue__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignBytes(nil)
}
func (_EnumValue__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.EnumValue"}.AssignLink(nil)
}
func (na *_EnumValue__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EnumValue); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_EnumValue__Assembler) Prototype() ipld.NodePrototype {
	return _EnumValue__Prototype{}
}
func (EnumValue) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EnumValue) Representation() ipld.Node {
	return (*_EnumValue__Repr)(n)
}
type _EnumValue__Repr = _EnumValue
var _ ipld.Node = &_EnumValue__Repr{}
type _EnumValue__ReprPrototype = _EnumValue__Prototype
type _EnumValue__ReprAssembler = _EnumValue__Assembler

func (n FieldName) String() string {
	return n.x
}
func (_FieldName__Prototype) fromString(w *_FieldName, v string) error {
	*w = _FieldName{v}
	return nil
}
func (_FieldName__Prototype) FromString(v string) (FieldName, error) {
	n := _FieldName{v}
	return &n, nil
}
type _FieldName__Maybe struct {
	m schema.Maybe
	v FieldName
}
type MaybeFieldName = *_FieldName__Maybe

func (m MaybeFieldName) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFieldName) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFieldName) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFieldName) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeFieldName) Must() FieldName {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (FieldName)(&_FieldName{})
var _ schema.TypedNode = (FieldName)(&_FieldName{})
func (FieldName) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_String
}
func (FieldName) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"schemadmt.FieldName"}.LookupByString("")
}
func (FieldName) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"schemadmt.FieldName"}.LookupByNode(nil)
}
func (FieldName) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.String{"schemadmt.FieldName"}.LookupByIndex(0)
}
func (FieldName) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"schemadmt.FieldName"}.LookupBySegment(seg)
}
func (FieldName) MapIterator() ipld.MapIterator {
	return nil
}
func (FieldName) ListIterator() ipld.ListIterator {
	return nil
}
func (FieldName) Length() int {
	return -1
}
func (FieldName) IsAbsent() bool {
	return false
}
func (FieldName) IsNull() bool {
	return false
}
func (FieldName) AsBool() (bool, error) {
	return mixins.String{"schemadmt.FieldName"}.AsBool()
}
func (FieldName) AsInt() (int, error) {
	return mixins.String{"schemadmt.FieldName"}.AsInt()
}
func (FieldName) AsFloat() (float64, error) {
	return mixins.String{"schemadmt.FieldName"}.AsFloat()
}
func (n FieldName) AsString() (string, error) {
	return n.x, nil
}
func (FieldName) AsBytes() ([]byte, error) {
	return mixins.String{"schemadmt.FieldName"}.AsBytes()
}
func (FieldName) AsLink() (ipld.Link, error) {
	return mixins.String{"schemadmt.FieldName"}.AsLink()
}
func (FieldName) Prototype() ipld.NodePrototype {
	return _FieldName__Prototype{}
}
type _FieldName__Prototype struct{}

func (_FieldName__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _FieldName__Builder
	nb.Reset()
	return &nb
}
type _FieldName__Builder struct {
	_FieldName__Assembler
}
func (nb *_FieldName__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_FieldName__Builder) Reset() {
	var w _FieldName
	var m schema.Maybe
	*nb = _FieldName__Builder{_FieldName__Assembler{w: &w, m: &m}}
}
type _FieldName__Assembler struct {
	w *_FieldName
	m *schema.Maybe
}

func (na *_FieldName__Assembler) reset() {}
func (_FieldName__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.FieldName"}.BeginMap(0)
}
func (_FieldName__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.FieldName"}.BeginList(0)
}
func (na *_FieldName__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"schemadmt.FieldName"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_FieldName__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.FieldName"}.AssignBool(false)
}
func (_FieldName__Assembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.FieldName"}.AssignInt(0)
}
func (_FieldName__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.FieldName"}.AssignFloat(0)
}
func (na *_FieldName__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_FieldName{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_FieldName__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.FieldName"}.AssignBytes(nil)
}
func (_FieldName__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.FieldName"}.AssignLink(nil)
}
func (na *_FieldName__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_FieldName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_FieldName__Assembler) Prototype() ipld.NodePrototype {
	return _FieldName__Prototype{}
}
func (FieldName) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n FieldName) Representation() ipld.Node {
	return (*_FieldName__Repr)(n)
}
type _FieldName__Repr = _FieldName
var _ ipld.Node = &_FieldName__Repr{}
type _FieldName__ReprPrototype = _FieldName__Prototype
type _FieldName__ReprAssembler = _FieldName__Assembler

func (n Float) Float() float64 {
	return n.x
}
func (_Float__Prototype) FromFloat(v float64) (Float, error) {
	n := _Float{v}
	return &n, nil
}
type _Float__Maybe struct {
	m schema.Maybe
	v Float
}
type MaybeFloat = *_Float__Maybe

func (m MaybeFloat) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFloat) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFloat) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFloat) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeFloat) Must() Float {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Float)(&_Float{})
var _ schema.TypedNode = (Float)(&_Float{})
func (Float) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Float
}
func (Float) LookupByString(string) (ipld.Node, error) {
	return mixins.Float{"schemadmt.Float"}.LookupByString("")
}
func (Float) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Float{"schemadmt.Float"}.LookupByNode(nil)
}
func (Float) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Float{"schemadmt.Float"}.LookupByIndex(0)
}
func (Float) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Float{"schemadmt.Float"}.LookupBySegment(seg)
}
func (Float) MapIterator() ipld.MapIterator {
	return nil
}
func (Float) ListIterator() ipld.ListIterator {
	return nil
}
func (Float) Length() int {
	return -1
}
func (Float) IsAbsent() bool {
	return false
}
func (Float) IsNull() bool {
	return false
}
func (Float) AsBool() (bool, error) {
	return mixins.Float{"schemadmt.Float"}.AsBool()
}
func (Float) AsInt() (int, error) {
	return mixins.Float{"schemadmt.Float"}.AsInt()
}
func (n Float) AsFloat() (float64, error) {
	return n.x, nil
}
func (Float) AsString() (string, error) {
	return mixins.Float{"schemadmt.Float"}.AsString()
}
func (Float) AsBytes() ([]byte, error) {
	return mixins.Float{"schemadmt.Float"}.AsBytes()
}
func (Float) AsLink() (ipld.Link, error) {
	return mixins.Float{"schemadmt.Float"}.AsLink()
}
func (Float) Prototype() ipld.NodePrototype {
	return _Float__Prototype{}
}
type _Float__Prototype struct{}

func (_Float__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Float__Builder
	nb.Reset()
	return &nb
}
type _Float__Builder struct {
	_Float__Assembler
}
func (nb *_Float__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Float__Builder) Reset() {
	var w _Float
	var m schema.Maybe
	*nb = _Float__Builder{_Float__Assembler{w: &w, m: &m}}
}
type _Float__Assembler struct {
	w *_Float
	m *schema.Maybe
}

func (na *_Float__Assembler) reset() {}
func (_Float__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.FloatAssembler{"schemadmt.Float"}.BeginMap(0)
}
func (_Float__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.FloatAssembler{"schemadmt.Float"}.BeginList(0)
}
func (na *_Float__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.FloatAssembler{"schemadmt.Float"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Float__Assembler) AssignBool(bool) error {
	return mixins.FloatAssembler{"schemadmt.Float"}.AssignBool(false)
}
func (_Float__Assembler) AssignInt(int) error {
	return mixins.FloatAssembler{"schemadmt.Float"}.AssignInt(0)
}
func (na *_Float__Assembler) AssignFloat(v float64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Float{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Float__Assembler) AssignString(string) error {
	return mixins.FloatAssembler{"schemadmt.Float"}.AssignString("")
}
func (_Float__Assembler) AssignBytes([]byte) error {
	return mixins.FloatAssembler{"schemadmt.Float"}.AssignBytes(nil)
}
func (_Float__Assembler) AssignLink(ipld.Link) error {
	return mixins.FloatAssembler{"schemadmt.Float"}.AssignLink(nil)
}
func (na *_Float__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Float); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsFloat(); err != nil {
		return err
	} else {
		return na.AssignFloat(v2)
	}
}
func (_Float__Assembler) Prototype() ipld.NodePrototype {
	return _Float__Prototype{}
}
func (Float) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Float) Representation() ipld.Node {
	return (*_Float__Repr)(n)
}
type _Float__Repr = _Float
var _ ipld.Node = &_Float__Repr{}
type _Float__ReprPrototype = _Float__Prototype
type _Float__ReprAssembler = _Float__Assembler

func (n Int) Int() int {
	return n.x
}
func (_Int__Prototype) FromInt(v int) (Int, error) {
	n := _Int{v}
	return &n, nil
}
type _Int__Maybe struct {
	m schema.Maybe
	v Int
}
type MaybeInt = *_Int__Maybe

func (m MaybeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeInt) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeInt) Must() Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Int)(&_Int{})
var _ schema.TypedNode = (Int)(&_Int{})
func (Int) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Int
}
func (Int) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"schemadmt.Int"}.LookupByString("")
}
func (Int) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"schemadmt.Int"}.LookupByNode(nil)
}
func (Int) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Int{"schemadmt.Int"}.LookupByIndex(0)
}
func (Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"schemadmt.Int"}.LookupBySegment(seg)
}
func (Int) MapIterator() ipld.MapIterator {
	return nil
}
func (Int) ListIterator() ipld.ListIterator {
	return nil
}
func (Int) Length() int {
	return -1
}
func (Int) IsAbsent() bool {
	return false
}
func (Int) IsNull() bool {
	return false
}
func (Int) AsBool() (bool, error) {
	return mixins.Int{"schemadmt.Int"}.AsBool()
}
func (n Int) AsInt() (int, error) {
	return n.x, nil
}
func (Int) AsFloat() (float64, error) {
	return mixins.Int{"schemadmt.Int"}.AsFloat()
}
func (Int) AsString() (string, error) {
	return mixins.Int{"schemadmt.Int"}.AsString()
}
func (Int) AsBytes() ([]byte, error) {
	return mixins.Int{"schemadmt.Int"}.AsBytes()
}
func (Int) AsLink() (ipld.Link, error) {
	return mixins.Int{"schemadmt.Int"}.AsLink()
}
func (Int) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
type _Int__Prototype struct{}

func (_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Int__Builder
	nb.Reset()
	return &nb
}
type _Int__Builder struct {
	_Int__Assembler
}
func (nb *_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Int__Builder) Reset() {
	var w _Int
	var m schema.Maybe
	*nb = _Int__Builder{_Int__Assembler{w: &w, m: &m}}
}
type _Int__Assembler struct {
	w *_Int
	m *schema.Maybe
}

func (na *_Int__Assembler) reset() {}
func (_Int__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"schemadmt.Int"}.BeginMap(0)
}
func (_Int__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"schemadmt.Int"}.BeginList(0)
}
func (na *_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"schemadmt.Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Int__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"schemadmt.Int"}.AssignBool(false)
}
func (na *_Int__Assembler) AssignInt(v int) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Int{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Int__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"schemadmt.Int"}.AssignFloat(0)
}
func (_Int__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"schemadmt.Int"}.AssignString("")
}
func (_Int__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"schemadmt.Int"}.AssignBytes(nil)
}
func (_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"schemadmt.Int"}.AssignLink(nil)
}
func (na *_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Int__Assembler) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Int) Representation() ipld.Node {
	return (*_Int__Repr)(n)
}
type _Int__Repr = _Int
var _ ipld.Node = &_Int__Repr{}
type _Int__ReprPrototype = _Int__Prototype
type _Int__ReprAssembler = _Int__Assembler

func (n _ListRepresentation) AsInterface() _ListRepresentation__iface {
	switch n.tag {
	case 1:
		return &n.x1
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _ListRepresentation__Maybe struct {
	m schema.Maybe
	v ListRepresentation
}
type MaybeListRepresentation = *_ListRepresentation__Maybe

func (m MaybeListRepresentation) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeListRepresentation) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeListRepresentation) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeListRepresentation) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeListRepresentation) Must() ListRepresentation {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__ListRepresentation_ListRepresentation_List = _String{"ListRepresentation_List"}
)
var _ ipld.Node = (ListRepresentation)(&_ListRepresentation{})
var _ schema.TypedNode = (ListRepresentation)(&_ListRepresentation{})
func (ListRepresentation) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n ListRepresentation) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ListRepresentation_List":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ListRepresentation) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ListRepresentation) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.LookupByIndex(0)
}
func (n ListRepresentation) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ListRepresentation) MapIterator() ipld.MapIterator {
	return &_ListRepresentation__MapItr{n, false}
}

type _ListRepresentation__MapItr struct {
	n ListRepresentation
	done bool
}

func (itr *_ListRepresentation__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__ListRepresentation_ListRepresentation_List, &itr.n.x1
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_ListRepresentation__MapItr) Done() bool {
	return itr.done
}

func (ListRepresentation) ListIterator() ipld.ListIterator {
	return nil
}
func (ListRepresentation) Length() int {
	return 1
}
func (ListRepresentation) IsAbsent() bool {
	return false
}
func (ListRepresentation) IsNull() bool {
	return false
}
func (ListRepresentation) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsBool()
}
func (ListRepresentation) AsInt() (int, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsInt()
}
func (ListRepresentation) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsFloat()
}
func (ListRepresentation) AsString() (string, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsString()
}
func (ListRepresentation) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsBytes()
}
func (ListRepresentation) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.ListRepresentation"}.AsLink()
}
func (ListRepresentation) Prototype() ipld.NodePrototype {
	return _ListRepresentation__Prototype{}
}
type _ListRepresentation__Prototype struct{}

func (_ListRepresentation__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ListRepresentation__Builder
	nb.Reset()
	return &nb
}
type _ListRepresentation__Builder struct {
	_ListRepresentation__Assembler
}
func (nb *_ListRepresentation__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ListRepresentation__Builder) Reset() {
	var w _ListRepresentation
	var m schema.Maybe
	*nb = _ListRepresentation__Builder{_ListRepresentation__Assembler{w: &w, m: &m}}
}
type _ListRepresentation__Assembler struct {
	w *_ListRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _ListRepresentation_List__Assembler
	ca uint
}
func (na *_ListRepresentation__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_ListRepresentation__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ListRepresentation{}
	}
	return na, nil
}
func (_ListRepresentation__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.BeginList(0)
}
func (na *_ListRepresentation__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ListRepresentation__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignBool(false)
}
func (_ListRepresentation__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignInt(0)
}
func (_ListRepresentation__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignFloat(0)
}
func (_ListRepresentation__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignString("")
}
func (_ListRepresentation__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignBytes(nil)
}
func (_ListRepresentation__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation"}.AssignLink(nil)
}
func (na *_ListRepresentation__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ListRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.ListRepresentation", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ListRepresentation__Assembler) Prototype() ipld.NodePrototype {
	return _ListRepresentation__Prototype{}
}
func (ma *_ListRepresentation__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_ListRepresentation__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "ListRepresentation_List":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation", Key:&_String{k}}
	}
}
func (ma *_ListRepresentation__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ListRepresentation__KeyAssembler)(ma)
}
func (ma *_ListRepresentation__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ListRepresentation__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ListRepresentation__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "ListRepresentation_List":
		return _ListRepresentation_List__Prototype{}
	default:
		return nil
	}
}
type _ListRepresentation__KeyAssembler _ListRepresentation__Assembler
func (_ListRepresentation__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.BeginMap(0)
}
func (_ListRepresentation__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.BeginList(0)
}
func (na *_ListRepresentation__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignNull()
}
func (_ListRepresentation__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignBool(false)
}
func (_ListRepresentation__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignInt(0)
}
func (_ListRepresentation__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ListRepresentation__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "ListRepresentation_List":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_ListRepresentation__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignBytes(nil)
}
func (_ListRepresentation__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ListRepresentation__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ListRepresentation__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ListRepresentation) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ListRepresentation) Representation() ipld.Node {
	return (*_ListRepresentation__Repr)(n)
}
type _ListRepresentation__Repr _ListRepresentation
var (
	memberName__ListRepresentation_ListRepresentation_List_serial = _String{"list"}
)
var _ ipld.Node = &_ListRepresentation__Repr{}
func (_ListRepresentation__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_ListRepresentation__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "list":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ListRepresentation__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ListRepresentation__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.LookupByIndex(0)
}
func (n _ListRepresentation__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ListRepresentation__Repr) MapIterator() ipld.MapIterator {
	return &_ListRepresentation__ReprMapItr{n, false}
}

type _ListRepresentation__ReprMapItr struct {
	n *_ListRepresentation__Repr
	done bool
}

func (itr *_ListRepresentation__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__ListRepresentation_ListRepresentation_List_serial, itr.n.x1.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_ListRepresentation__ReprMapItr) Done() bool {
	return itr.done
}

func (_ListRepresentation__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_ListRepresentation__Repr) Length() int {
	return 1
}
func (_ListRepresentation__Repr) IsAbsent() bool {
	return false
}
func (_ListRepresentation__Repr) IsNull() bool {
	return false
}
func (_ListRepresentation__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsBool()
}
func (_ListRepresentation__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsInt()
}
func (_ListRepresentation__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsFloat()
}
func (_ListRepresentation__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsString()
}
func (_ListRepresentation__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsBytes()
}
func (_ListRepresentation__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.ListRepresentation.Repr"}.AsLink()
}
func (_ListRepresentation__Repr) Prototype() ipld.NodePrototype {
	return _ListRepresentation__ReprPrototype{}
}
type _ListRepresentation__ReprPrototype struct{}

func (_ListRepresentation__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ListRepresentation__ReprBuilder
	nb.Reset()
	return &nb
}
type _ListRepresentation__ReprBuilder struct {
	_ListRepresentation__ReprAssembler
}
func (nb *_ListRepresentation__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ListRepresentation__ReprBuilder) Reset() {
	var w _ListRepresentation
	var m schema.Maybe
	*nb = _ListRepresentation__ReprBuilder{_ListRepresentation__ReprAssembler{w: &w, m: &m}}
}
type _ListRepresentation__ReprAssembler struct {
	w *_ListRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _ListRepresentation_List__ReprAssembler
	ca uint
}
func (na *_ListRepresentation__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_ListRepresentation__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ListRepresentation{}
	}
	return na, nil
}
func (_ListRepresentation__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.BeginList(0)
}
func (na *_ListRepresentation__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ListRepresentation__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignBool(false)
}
func (_ListRepresentation__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignInt(0)
}
func (_ListRepresentation__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignFloat(0)
}
func (_ListRepresentation__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignString("")
}
func (_ListRepresentation__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignBytes(nil)
}
func (_ListRepresentation__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation.Repr"}.AssignLink(nil)
}
func (na *_ListRepresentation__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ListRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.ListRepresentation.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ListRepresentation__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ListRepresentation__ReprPrototype{}
}
func (ma *_ListRepresentation__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_ListRepresentation__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "list":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation.Repr", Key:&_String{k}}
	}
}
func (ma *_ListRepresentation__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ListRepresentation__ReprKeyAssembler)(ma)
}
func (ma *_ListRepresentation__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ListRepresentation__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ListRepresentation__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "ListRepresentation_List":
		return _ListRepresentation_List__ReprPrototype{}
	default:
		return nil
	}
}
type _ListRepresentation__ReprKeyAssembler _ListRepresentation__ReprAssembler
func (_ListRepresentation__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ListRepresentation__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ListRepresentation__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignNull()
}
func (_ListRepresentation__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ListRepresentation__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ListRepresentation__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ListRepresentation__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.ListRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "list":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_ListRepresentation__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ListRepresentation__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ListRepresentation__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ListRepresentation__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _ListRepresentation_List__Maybe struct {
	m schema.Maybe
	v ListRepresentation_List
}
type MaybeListRepresentation_List = *_ListRepresentation_List__Maybe

func (m MaybeListRepresentation_List) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeListRepresentation_List) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeListRepresentation_List) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeListRepresentation_List) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeListRepresentation_List) Must() ListRepresentation_List {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (ListRepresentation_List)(&_ListRepresentation_List{})
var _ schema.TypedNode = (ListRepresentation_List)(&_ListRepresentation_List{})
func (ListRepresentation_List) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n ListRepresentation_List) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ListRepresentation_List) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ListRepresentation_List) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.LookupByIndex(0)
}
func (n ListRepresentation_List) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ListRepresentation_List) MapIterator() ipld.MapIterator {
	return &_ListRepresentation_List__MapItr{n, 0}
}

type _ListRepresentation_List__MapItr struct {
	n ListRepresentation_List
	idx  int
}

func (itr *_ListRepresentation_List__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ListRepresentation_List__MapItr) Done() bool {
	return itr.idx >= 0
}

func (ListRepresentation_List) ListIterator() ipld.ListIterator {
	return nil
}
func (ListRepresentation_List) Length() int {
	return 0
}
func (ListRepresentation_List) IsAbsent() bool {
	return false
}
func (ListRepresentation_List) IsNull() bool {
	return false
}
func (ListRepresentation_List) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsBool()
}
func (ListRepresentation_List) AsInt() (int, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsInt()
}
func (ListRepresentation_List) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsFloat()
}
func (ListRepresentation_List) AsString() (string, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsString()
}
func (ListRepresentation_List) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsBytes()
}
func (ListRepresentation_List) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List"}.AsLink()
}
func (ListRepresentation_List) Prototype() ipld.NodePrototype {
	return _ListRepresentation_List__Prototype{}
}
type _ListRepresentation_List__Prototype struct{}

func (_ListRepresentation_List__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ListRepresentation_List__Builder
	nb.Reset()
	return &nb
}
type _ListRepresentation_List__Builder struct {
	_ListRepresentation_List__Assembler
}
func (nb *_ListRepresentation_List__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ListRepresentation_List__Builder) Reset() {
	var w _ListRepresentation_List
	var m schema.Maybe
	*nb = _ListRepresentation_List__Builder{_ListRepresentation_List__Assembler{w: &w, m: &m}}
}
type _ListRepresentation_List__Assembler struct {
	w *_ListRepresentation_List
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_ListRepresentation_List__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__ListRepresentation_List_sufficient = 0
)
func (na *_ListRepresentation_List__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ListRepresentation_List{}
	}
	return na, nil
}
func (_ListRepresentation_List__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.BeginList(0)
}
func (na *_ListRepresentation_List__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ListRepresentation_List__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignBool(false)
}
func (_ListRepresentation_List__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignInt(0)
}
func (_ListRepresentation_List__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignFloat(0)
}
func (_ListRepresentation_List__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignString("")
}
func (_ListRepresentation_List__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignBytes(nil)
}
func (_ListRepresentation_List__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List"}.AssignLink(nil)
}
func (na *_ListRepresentation_List__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ListRepresentation_List); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.ListRepresentation_List", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ListRepresentation_List__Assembler) Prototype() ipld.NodePrototype {
	return _ListRepresentation_List__Prototype{}
}
func (ma *_ListRepresentation_List__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation_List__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation_List", Key:&_String{k}}
	}
}
func (ma *_ListRepresentation_List__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ListRepresentation_List__KeyAssembler)(ma)
}
func (ma *_ListRepresentation_List__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation_List__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ListRepresentation_List__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ListRepresentation_List__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _ListRepresentation_List__KeyAssembler _ListRepresentation_List__Assembler
func (_ListRepresentation_List__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.BeginMap(0)
}
func (_ListRepresentation_List__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.BeginList(0)
}
func (na *_ListRepresentation_List__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignNull()
}
func (_ListRepresentation_List__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignBool(false)
}
func (_ListRepresentation_List__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignInt(0)
}
func (_ListRepresentation_List__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ListRepresentation_List__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation_List", Key:&_String{k}}
	}
	return nil
}
func (_ListRepresentation_List__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignBytes(nil)
}
func (_ListRepresentation_List__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ListRepresentation_List__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ListRepresentation_List__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ListRepresentation_List) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ListRepresentation_List) Representation() ipld.Node {
	return (*_ListRepresentation_List__Repr)(n)
}
type _ListRepresentation_List__Repr _ListRepresentation_List
var (
)
var _ ipld.Node = &_ListRepresentation_List__Repr{}
func (_ListRepresentation_List__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_ListRepresentation_List__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ListRepresentation_List__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ListRepresentation_List__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.LookupByIndex(0)
}
func (n _ListRepresentation_List__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ListRepresentation_List__Repr) MapIterator() ipld.MapIterator {
	return &_ListRepresentation_List__ReprMapItr{n, 0}
}

type _ListRepresentation_List__ReprMapItr struct {
	n   *_ListRepresentation_List__Repr
	idx int
	
}

func (itr *_ListRepresentation_List__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ListRepresentation_List__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_ListRepresentation_List__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ListRepresentation_List__Repr) Length() int {
	l := 0
	return l
}
func (_ListRepresentation_List__Repr) IsAbsent() bool {
	return false
}
func (_ListRepresentation_List__Repr) IsNull() bool {
	return false
}
func (_ListRepresentation_List__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsBool()
}
func (_ListRepresentation_List__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsInt()
}
func (_ListRepresentation_List__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsFloat()
}
func (_ListRepresentation_List__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsString()
}
func (_ListRepresentation_List__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsBytes()
}
func (_ListRepresentation_List__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.ListRepresentation_List.Repr"}.AsLink()
}
func (_ListRepresentation_List__Repr) Prototype() ipld.NodePrototype {
	return _ListRepresentation_List__ReprPrototype{}
}
type _ListRepresentation_List__ReprPrototype struct{}

func (_ListRepresentation_List__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ListRepresentation_List__ReprBuilder
	nb.Reset()
	return &nb
}
type _ListRepresentation_List__ReprBuilder struct {
	_ListRepresentation_List__ReprAssembler
}
func (nb *_ListRepresentation_List__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ListRepresentation_List__ReprBuilder) Reset() {
	var w _ListRepresentation_List
	var m schema.Maybe
	*nb = _ListRepresentation_List__ReprBuilder{_ListRepresentation_List__ReprAssembler{w: &w, m: &m}}
}
type _ListRepresentation_List__ReprAssembler struct {
	w *_ListRepresentation_List
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_ListRepresentation_List__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_ListRepresentation_List__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ListRepresentation_List{}
	}
	return na, nil
}
func (_ListRepresentation_List__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.BeginList(0)
}
func (na *_ListRepresentation_List__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ListRepresentation_List__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignBool(false)
}
func (_ListRepresentation_List__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignInt(0)
}
func (_ListRepresentation_List__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignFloat(0)
}
func (_ListRepresentation_List__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignString("")
}
func (_ListRepresentation_List__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignBytes(nil)
}
func (_ListRepresentation_List__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.ListRepresentation_List.Repr"}.AssignLink(nil)
}
func (na *_ListRepresentation_List__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ListRepresentation_List); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.ListRepresentation_List.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ListRepresentation_List__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ListRepresentation_List__ReprPrototype{}
}
func (ma *_ListRepresentation_List__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation_List__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation_List.Repr", Key:&_String{k}}
	}
}
func (ma *_ListRepresentation_List__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ListRepresentation_List__ReprKeyAssembler)(ma)
}
func (ma *_ListRepresentation_List__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_ListRepresentation_List__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ListRepresentation_List__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ListRepresentation_List__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _ListRepresentation_List__ReprKeyAssembler _ListRepresentation_List__ReprAssembler
func (_ListRepresentation_List__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ListRepresentation_List__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ListRepresentation_List__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignNull()
}
func (_ListRepresentation_List__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ListRepresentation_List__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ListRepresentation_List__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ListRepresentation_List__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.ListRepresentation_List.Repr", Key:&_String{k}}
	}
	return nil
}
func (_ListRepresentation_List__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ListRepresentation_List__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.ListRepresentation_List.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ListRepresentation_List__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ListRepresentation_List__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_List__FieldName) Lookup(idx int) FieldName {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_List__FieldName) LookupMaybe(idx int) MaybeFieldName {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_FieldName__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _List__FieldName__valueAbsent = _FieldName__Maybe{m:schema.Maybe_Absent}
func (n List__FieldName) Iterator() *List__FieldName__Itr {
	return &List__FieldName__Itr{n, 0}
}

type List__FieldName__Itr struct {
	n List__FieldName
	idx  int
}

func (itr *List__FieldName__Itr) Next() (idx int, v FieldName) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = itr.idx
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List__FieldName__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List__FieldName__Maybe struct {
	m schema.Maybe
	v List__FieldName
}
type MaybeList__FieldName = *_List__FieldName__Maybe

func (m MaybeList__FieldName) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList__FieldName) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList__FieldName) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList__FieldName) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList__FieldName) Must() List__FieldName {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List__FieldName)(&_List__FieldName{})
var _ schema.TypedNode = (List__FieldName)(&_List__FieldName{})
func (List__FieldName) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_List
}
func (List__FieldName) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"schemadmt.List__FieldName"}.LookupByString("")
}
func (n List__FieldName) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List__FieldName) LookupByIndex(idx int) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n List__FieldName) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "schemadmt.List__FieldName", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List__FieldName) MapIterator() ipld.MapIterator {
	return nil
}
func (n List__FieldName) ListIterator() ipld.ListIterator {
	return &_List__FieldName__ListItr{n, 0}
}

type _List__FieldName__ListItr struct {
	n List__FieldName
	idx  int
}

func (itr *_List__FieldName__ListItr) Next() (idx int, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = itr.idx
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_List__FieldName__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List__FieldName) Length() int {
	return len(n.x)
}
func (List__FieldName) IsAbsent() bool {
	return false
}
func (List__FieldName) IsNull() bool {
	return false
}
func (List__FieldName) AsBool() (bool, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsBool()
}
func (List__FieldName) AsInt() (int, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsInt()
}
func (List__FieldName) AsFloat() (float64, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsFloat()
}
func (List__FieldName) AsString() (string, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsString()
}
func (List__FieldName) AsBytes() ([]byte, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsBytes()
}
func (List__FieldName) AsLink() (ipld.Link, error) {
	return mixins.List{"schemadmt.List__FieldName"}.AsLink()
}
func (List__FieldName) Prototype() ipld.NodePrototype {
	return _List__FieldName__Prototype{}
}
type _List__FieldName__Prototype struct{}

func (_List__FieldName__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__FieldName__Builder
	nb.Reset()
	return &nb
}
type _List__FieldName__Builder struct {
	_List__FieldName__Assembler
}
func (nb *_List__FieldName__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__FieldName__Builder) Reset() {
	var w _List__FieldName
	var m schema.Maybe
	*nb = _List__FieldName__Builder{_List__FieldName__Assembler{w: &w, m: &m}}
}
type _List__FieldName__Assembler struct {
	w *_List__FieldName
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _FieldName__Assembler
}

func (na *_List__FieldName__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__FieldName__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.BeginMap(0)
}
func (na *_List__FieldName__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List__FieldName{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_FieldName, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__FieldName__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__FieldName__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignBool(false)
}
func (_List__FieldName__Assembler) AssignInt(int) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignInt(0)
}
func (_List__FieldName__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignFloat(0)
}
func (_List__FieldName__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignString("")
}
func (_List__FieldName__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignBytes(nil)
}
func (_List__FieldName__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName"}.AssignLink(nil)
}
func (na *_List__FieldName__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List__FieldName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_List {
		return ipld.ErrWrongKind{TypeName: "schemadmt.List__FieldName", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: v.ReprKind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__FieldName__Assembler) Prototype() ipld.NodePrototype {
	return _List__FieldName__Prototype{}
}
func (la *_List__FieldName__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__FieldName__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _FieldName{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List__FieldName__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__FieldName__Assembler) ValuePrototype(_ int) ipld.NodePrototype {
	return _FieldName__Prototype{}
}
func (List__FieldName) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List__FieldName) Representation() ipld.Node {
	return (*_List__FieldName__Repr)(n)
}
type _List__FieldName__Repr _List__FieldName
var _ ipld.Node = &_List__FieldName__Repr{}
func (_List__FieldName__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_List
}
func (_List__FieldName__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.LookupByString("")
}
func (nr *_List__FieldName__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List__FieldName)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(FieldName).Representation(), nil
}
func (nr *_List__FieldName__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	v, err := (List__FieldName)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(FieldName).Representation(), nil
}
func (n _List__FieldName__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "schemadmt.List__FieldName.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List__FieldName__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List__FieldName__Repr) ListIterator() ipld.ListIterator {
	return &_List__FieldName__ReprListItr{(List__FieldName)(nr), 0}
}

type _List__FieldName__ReprListItr _List__FieldName__ListItr

func (itr *_List__FieldName__ReprListItr) Next() (idx int, v ipld.Node, err error) {
	idx, v, err = (*_List__FieldName__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(FieldName).Representation(), nil
}
func (itr *_List__FieldName__ReprListItr) Done() bool {
	return (*_List__FieldName__ListItr)(itr).Done()
}

func (rn *_List__FieldName__Repr) Length() int {
	return len(rn.x)
}
func (_List__FieldName__Repr) IsAbsent() bool {
	return false
}
func (_List__FieldName__Repr) IsNull() bool {
	return false
}
func (_List__FieldName__Repr) AsBool() (bool, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsBool()
}
func (_List__FieldName__Repr) AsInt() (int, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsInt()
}
func (_List__FieldName__Repr) AsFloat() (float64, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsFloat()
}
func (_List__FieldName__Repr) AsString() (string, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsString()
}
func (_List__FieldName__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsBytes()
}
func (_List__FieldName__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"schemadmt.List__FieldName.Repr"}.AsLink()
}
func (_List__FieldName__Repr) Prototype() ipld.NodePrototype {
	return _List__FieldName__ReprPrototype{}
}
type _List__FieldName__ReprPrototype struct{}

func (_List__FieldName__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__FieldName__ReprBuilder
	nb.Reset()
	return &nb
}
type _List__FieldName__ReprBuilder struct {
	_List__FieldName__ReprAssembler
}
func (nb *_List__FieldName__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__FieldName__ReprBuilder) Reset() {
	var w _List__FieldName
	var m schema.Maybe
	*nb = _List__FieldName__ReprBuilder{_List__FieldName__ReprAssembler{w: &w, m: &m}}
}
type _List__FieldName__ReprAssembler struct {
	w *_List__FieldName
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _FieldName__ReprAssembler
}

func (na *_List__FieldName__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__FieldName__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.BeginMap(0)
}
func (na *_List__FieldName__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List__FieldName{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_FieldName, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__FieldName__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"schemadmt.List__FieldName.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__FieldName__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignBool(false)
}
func (_List__FieldName__ReprAssembler) AssignInt(int) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignInt(0)
}
func (_List__FieldName__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignFloat(0)
}
func (_List__FieldName__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignString("")
}
func (_List__FieldName__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignBytes(nil)
}
func (_List__FieldName__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"schemadmt.List__FieldName.Repr"}.AssignLink(nil)
}
func (na *_List__FieldName__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List__FieldName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_List {
		return ipld.ErrWrongKind{TypeName: "schemadmt.List__FieldName.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: v.ReprKind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__FieldName__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List__FieldName__ReprPrototype{}
}
func (la *_List__FieldName__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__FieldName__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _FieldName{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List__FieldName__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__FieldName__ReprAssembler) ValuePrototype(_ int) ipld.NodePrototype {
	return _FieldName__ReprPrototype{}
}

func (n *_List__TypeName) Lookup(idx int) TypeName {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_List__TypeName) LookupMaybe(idx int) MaybeTypeName {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_TypeName__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _List__TypeName__valueAbsent = _TypeName__Maybe{m:schema.Maybe_Absent}
func (n List__TypeName) Iterator() *List__TypeName__Itr {
	return &List__TypeName__Itr{n, 0}
}

type List__TypeName__Itr struct {
	n List__TypeName
	idx  int
}

func (itr *List__TypeName__Itr) Next() (idx int, v TypeName) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = itr.idx
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List__TypeName__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List__TypeName__Maybe struct {
	m schema.Maybe
	v List__TypeName
}
type MaybeList__TypeName = *_List__TypeName__Maybe

func (m MaybeList__TypeName) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList__TypeName) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList__TypeName) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList__TypeName) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList__TypeName) Must() List__TypeName {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List__TypeName)(&_List__TypeName{})
var _ schema.TypedNode = (List__TypeName)(&_List__TypeName{})
func (List__TypeName) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_List
}
func (List__TypeName) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"schemadmt.List__TypeName"}.LookupByString("")
}
func (n List__TypeName) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List__TypeName) LookupByIndex(idx int) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n List__TypeName) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "schemadmt.List__TypeName", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List__TypeName) MapIterator() ipld.MapIterator {
	return nil
}
func (n List__TypeName) ListIterator() ipld.ListIterator {
	return &_List__TypeName__ListItr{n, 0}
}

type _List__TypeName__ListItr struct {
	n List__TypeName
	idx  int
}

func (itr *_List__TypeName__ListItr) Next() (idx int, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = itr.idx
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_List__TypeName__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List__TypeName) Length() int {
	return len(n.x)
}
func (List__TypeName) IsAbsent() bool {
	return false
}
func (List__TypeName) IsNull() bool {
	return false
}
func (List__TypeName) AsBool() (bool, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsBool()
}
func (List__TypeName) AsInt() (int, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsInt()
}
func (List__TypeName) AsFloat() (float64, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsFloat()
}
func (List__TypeName) AsString() (string, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsString()
}
func (List__TypeName) AsBytes() ([]byte, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsBytes()
}
func (List__TypeName) AsLink() (ipld.Link, error) {
	return mixins.List{"schemadmt.List__TypeName"}.AsLink()
}
func (List__TypeName) Prototype() ipld.NodePrototype {
	return _List__TypeName__Prototype{}
}
type _List__TypeName__Prototype struct{}

func (_List__TypeName__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__TypeName__Builder
	nb.Reset()
	return &nb
}
type _List__TypeName__Builder struct {
	_List__TypeName__Assembler
}
func (nb *_List__TypeName__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__TypeName__Builder) Reset() {
	var w _List__TypeName
	var m schema.Maybe
	*nb = _List__TypeName__Builder{_List__TypeName__Assembler{w: &w, m: &m}}
}
type _List__TypeName__Assembler struct {
	w *_List__TypeName
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _TypeName__Assembler
}

func (na *_List__TypeName__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__TypeName__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.BeginMap(0)
}
func (na *_List__TypeName__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List__TypeName{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_TypeName, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__TypeName__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__TypeName__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignBool(false)
}
func (_List__TypeName__Assembler) AssignInt(int) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignInt(0)
}
func (_List__TypeName__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignFloat(0)
}
func (_List__TypeName__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignString("")
}
func (_List__TypeName__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignBytes(nil)
}
func (_List__TypeName__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName"}.AssignLink(nil)
}
func (na *_List__TypeName__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List__TypeName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_List {
		return ipld.ErrWrongKind{TypeName: "schemadmt.List__TypeName", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: v.ReprKind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__TypeName__Assembler) Prototype() ipld.NodePrototype {
	return _List__TypeName__Prototype{}
}
func (la *_List__TypeName__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__TypeName__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _TypeName{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List__TypeName__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__TypeName__Assembler) ValuePrototype(_ int) ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (List__TypeName) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List__TypeName) Representation() ipld.Node {
	return (*_List__TypeName__Repr)(n)
}
type _List__TypeName__Repr _List__TypeName
var _ ipld.Node = &_List__TypeName__Repr{}
func (_List__TypeName__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_List
}
func (_List__TypeName__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.LookupByString("")
}
func (nr *_List__TypeName__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List__TypeName)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (nr *_List__TypeName__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	v, err := (List__TypeName)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (n _List__TypeName__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "schemadmt.List__TypeName.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List__TypeName__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List__TypeName__Repr) ListIterator() ipld.ListIterator {
	return &_List__TypeName__ReprListItr{(List__TypeName)(nr), 0}
}

type _List__TypeName__ReprListItr _List__TypeName__ListItr

func (itr *_List__TypeName__ReprListItr) Next() (idx int, v ipld.Node, err error) {
	idx, v, err = (*_List__TypeName__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(TypeName).Representation(), nil
}
func (itr *_List__TypeName__ReprListItr) Done() bool {
	return (*_List__TypeName__ListItr)(itr).Done()
}

func (rn *_List__TypeName__Repr) Length() int {
	return len(rn.x)
}
func (_List__TypeName__Repr) IsAbsent() bool {
	return false
}
func (_List__TypeName__Repr) IsNull() bool {
	return false
}
func (_List__TypeName__Repr) AsBool() (bool, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsBool()
}
func (_List__TypeName__Repr) AsInt() (int, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsInt()
}
func (_List__TypeName__Repr) AsFloat() (float64, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsFloat()
}
func (_List__TypeName__Repr) AsString() (string, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsString()
}
func (_List__TypeName__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsBytes()
}
func (_List__TypeName__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"schemadmt.List__TypeName.Repr"}.AsLink()
}
func (_List__TypeName__Repr) Prototype() ipld.NodePrototype {
	return _List__TypeName__ReprPrototype{}
}
type _List__TypeName__ReprPrototype struct{}

func (_List__TypeName__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__TypeName__ReprBuilder
	nb.Reset()
	return &nb
}
type _List__TypeName__ReprBuilder struct {
	_List__TypeName__ReprAssembler
}
func (nb *_List__TypeName__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__TypeName__ReprBuilder) Reset() {
	var w _List__TypeName
	var m schema.Maybe
	*nb = _List__TypeName__ReprBuilder{_List__TypeName__ReprAssembler{w: &w, m: &m}}
}
type _List__TypeName__ReprAssembler struct {
	w *_List__TypeName
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _TypeName__ReprAssembler
}

func (na *_List__TypeName__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__TypeName__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.BeginMap(0)
}
func (na *_List__TypeName__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List__TypeName{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_TypeName, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__TypeName__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"schemadmt.List__TypeName.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__TypeName__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignBool(false)
}
func (_List__TypeName__ReprAssembler) AssignInt(int) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignInt(0)
}
func (_List__TypeName__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignFloat(0)
}
func (_List__TypeName__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignString("")
}
func (_List__TypeName__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignBytes(nil)
}
func (_List__TypeName__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"schemadmt.List__TypeName.Repr"}.AssignLink(nil)
}
func (na *_List__TypeName__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List__TypeName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_List {
		return ipld.ErrWrongKind{TypeName: "schemadmt.List__TypeName.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: v.ReprKind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__TypeName__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List__TypeName__ReprPrototype{}
}
func (la *_List__TypeName__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__TypeName__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _TypeName{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List__TypeName__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__TypeName__ReprAssembler) ValuePrototype(_ int) ipld.NodePrototype {
	return _TypeName__ReprPrototype{}
}

func (n _MapRepresentation) AsInterface() _MapRepresentation__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _MapRepresentation__Maybe struct {
	m schema.Maybe
	v MapRepresentation
}
type MaybeMapRepresentation = *_MapRepresentation__Maybe

func (m MaybeMapRepresentation) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMapRepresentation) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMapRepresentation) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMapRepresentation) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMapRepresentation) Must() MapRepresentation {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__MapRepresentation_MapRepresentation_Map = _String{"MapRepresentation_Map"}
	memberName__MapRepresentation_MapRepresentation_Stringpairs = _String{"MapRepresentation_Stringpairs"}
	memberName__MapRepresentation_MapRepresentation_Listpairs = _String{"MapRepresentation_Listpairs"}
)
var _ ipld.Node = (MapRepresentation)(&_MapRepresentation{})
var _ schema.TypedNode = (MapRepresentation)(&_MapRepresentation{})
func (MapRepresentation) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n MapRepresentation) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MapRepresentation_Map":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "MapRepresentation_Stringpairs":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "MapRepresentation_Listpairs":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MapRepresentation) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MapRepresentation) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.LookupByIndex(0)
}
func (n MapRepresentation) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MapRepresentation) MapIterator() ipld.MapIterator {
	return &_MapRepresentation__MapItr{n, false}
}

type _MapRepresentation__MapItr struct {
	n MapRepresentation
	done bool
}

func (itr *_MapRepresentation__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__MapRepresentation_MapRepresentation_Map, &itr.n.x1
	case 2:
		k, v = &memberName__MapRepresentation_MapRepresentation_Stringpairs, &itr.n.x2
	case 3:
		k, v = &memberName__MapRepresentation_MapRepresentation_Listpairs, &itr.n.x3
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_MapRepresentation__MapItr) Done() bool {
	return itr.done
}

func (MapRepresentation) ListIterator() ipld.ListIterator {
	return nil
}
func (MapRepresentation) Length() int {
	return 1
}
func (MapRepresentation) IsAbsent() bool {
	return false
}
func (MapRepresentation) IsNull() bool {
	return false
}
func (MapRepresentation) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsBool()
}
func (MapRepresentation) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsInt()
}
func (MapRepresentation) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsFloat()
}
func (MapRepresentation) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsString()
}
func (MapRepresentation) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsBytes()
}
func (MapRepresentation) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation"}.AsLink()
}
func (MapRepresentation) Prototype() ipld.NodePrototype {
	return _MapRepresentation__Prototype{}
}
type _MapRepresentation__Prototype struct{}

func (_MapRepresentation__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation__Builder
	nb.Reset()
	return &nb
}
type _MapRepresentation__Builder struct {
	_MapRepresentation__Assembler
}
func (nb *_MapRepresentation__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation__Builder) Reset() {
	var w _MapRepresentation
	var m schema.Maybe
	*nb = _MapRepresentation__Builder{_MapRepresentation__Assembler{w: &w, m: &m}}
}
type _MapRepresentation__Assembler struct {
	w *_MapRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _MapRepresentation_Map__Assembler
	
	ca2 _MapRepresentation_Stringpairs__Assembler
	
	ca3 _MapRepresentation_Listpairs__Assembler
	ca uint
}
func (na *_MapRepresentation__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_MapRepresentation__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation{}
	}
	return na, nil
}
func (_MapRepresentation__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.BeginList(0)
}
func (na *_MapRepresentation__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignBool(false)
}
func (_MapRepresentation__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignInt(0)
}
func (_MapRepresentation__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignFloat(0)
}
func (_MapRepresentation__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignString("")
}
func (_MapRepresentation__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignBytes(nil)
}
func (_MapRepresentation__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation"}.AssignLink(nil)
}
func (na *_MapRepresentation__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation__Assembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation__Prototype{}
}
func (ma *_MapRepresentation__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_MapRepresentation__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MapRepresentation_Map":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "MapRepresentation_Stringpairs":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "MapRepresentation_Listpairs":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation__KeyAssembler)(ma)
}
func (ma *_MapRepresentation__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "MapRepresentation_Map":
		return _MapRepresentation_Map__Prototype{}
	case "MapRepresentation_Stringpairs":
		return _MapRepresentation_Stringpairs__Prototype{}
	case "MapRepresentation_Listpairs":
		return _MapRepresentation_Listpairs__Prototype{}
	default:
		return nil
	}
}
type _MapRepresentation__KeyAssembler _MapRepresentation__Assembler
func (_MapRepresentation__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MapRepresentation_Map":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "MapRepresentation_Stringpairs":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "MapRepresentation_Listpairs":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_MapRepresentation__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MapRepresentation) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MapRepresentation) Representation() ipld.Node {
	return (*_MapRepresentation__Repr)(n)
}
type _MapRepresentation__Repr _MapRepresentation
var (
	memberName__MapRepresentation_MapRepresentation_Map_serial = _String{"map"}
	memberName__MapRepresentation_MapRepresentation_Stringpairs_serial = _String{"stringpairs"}
	memberName__MapRepresentation_MapRepresentation_Listpairs_serial = _String{"listpairs"}
)
var _ ipld.Node = &_MapRepresentation__Repr{}
func (_MapRepresentation__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_MapRepresentation__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "map":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "stringpairs":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "listpairs":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MapRepresentation__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MapRepresentation__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.LookupByIndex(0)
}
func (n _MapRepresentation__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MapRepresentation__Repr) MapIterator() ipld.MapIterator {
	return &_MapRepresentation__ReprMapItr{n, false}
}

type _MapRepresentation__ReprMapItr struct {
	n *_MapRepresentation__Repr
	done bool
}

func (itr *_MapRepresentation__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__MapRepresentation_MapRepresentation_Map_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__MapRepresentation_MapRepresentation_Stringpairs_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__MapRepresentation_MapRepresentation_Listpairs_serial, itr.n.x3.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_MapRepresentation__ReprMapItr) Done() bool {
	return itr.done
}

func (_MapRepresentation__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_MapRepresentation__Repr) Length() int {
	return 1
}
func (_MapRepresentation__Repr) IsAbsent() bool {
	return false
}
func (_MapRepresentation__Repr) IsNull() bool {
	return false
}
func (_MapRepresentation__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsBool()
}
func (_MapRepresentation__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsInt()
}
func (_MapRepresentation__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsFloat()
}
func (_MapRepresentation__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsString()
}
func (_MapRepresentation__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsBytes()
}
func (_MapRepresentation__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation.Repr"}.AsLink()
}
func (_MapRepresentation__Repr) Prototype() ipld.NodePrototype {
	return _MapRepresentation__ReprPrototype{}
}
type _MapRepresentation__ReprPrototype struct{}

func (_MapRepresentation__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation__ReprBuilder
	nb.Reset()
	return &nb
}
type _MapRepresentation__ReprBuilder struct {
	_MapRepresentation__ReprAssembler
}
func (nb *_MapRepresentation__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation__ReprBuilder) Reset() {
	var w _MapRepresentation
	var m schema.Maybe
	*nb = _MapRepresentation__ReprBuilder{_MapRepresentation__ReprAssembler{w: &w, m: &m}}
}
type _MapRepresentation__ReprAssembler struct {
	w *_MapRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _MapRepresentation_Map__ReprAssembler
	
	ca2 _MapRepresentation_Stringpairs__ReprAssembler
	
	ca3 _MapRepresentation_Listpairs__ReprAssembler
	ca uint
}
func (na *_MapRepresentation__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_MapRepresentation__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation{}
	}
	return na, nil
}
func (_MapRepresentation__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.BeginList(0)
}
func (na *_MapRepresentation__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignBool(false)
}
func (_MapRepresentation__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignInt(0)
}
func (_MapRepresentation__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignFloat(0)
}
func (_MapRepresentation__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignString("")
}
func (_MapRepresentation__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignBytes(nil)
}
func (_MapRepresentation__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation.Repr"}.AssignLink(nil)
}
func (na *_MapRepresentation__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation__ReprPrototype{}
}
func (ma *_MapRepresentation__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_MapRepresentation__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "stringpairs":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "listpairs":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation.Repr", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation__ReprKeyAssembler)(ma)
}
func (ma *_MapRepresentation__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "MapRepresentation_Map":
		return _MapRepresentation_Map__ReprPrototype{}
	case "MapRepresentation_Stringpairs":
		return _MapRepresentation_Stringpairs__ReprPrototype{}
	case "MapRepresentation_Listpairs":
		return _MapRepresentation_Listpairs__ReprPrototype{}
	default:
		return nil
	}
}
type _MapRepresentation__ReprKeyAssembler _MapRepresentation__ReprAssembler
func (_MapRepresentation__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.MapRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "stringpairs":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "listpairs":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_MapRepresentation__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _MapRepresentation_Listpairs__Maybe struct {
	m schema.Maybe
	v MapRepresentation_Listpairs
}
type MaybeMapRepresentation_Listpairs = *_MapRepresentation_Listpairs__Maybe

func (m MaybeMapRepresentation_Listpairs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMapRepresentation_Listpairs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMapRepresentation_Listpairs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMapRepresentation_Listpairs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMapRepresentation_Listpairs) Must() MapRepresentation_Listpairs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (MapRepresentation_Listpairs)(&_MapRepresentation_Listpairs{})
var _ schema.TypedNode = (MapRepresentation_Listpairs)(&_MapRepresentation_Listpairs{})
func (MapRepresentation_Listpairs) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n MapRepresentation_Listpairs) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MapRepresentation_Listpairs) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MapRepresentation_Listpairs) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.LookupByIndex(0)
}
func (n MapRepresentation_Listpairs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MapRepresentation_Listpairs) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Listpairs__MapItr{n, 0}
}

type _MapRepresentation_Listpairs__MapItr struct {
	n MapRepresentation_Listpairs
	idx  int
}

func (itr *_MapRepresentation_Listpairs__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Listpairs__MapItr) Done() bool {
	return itr.idx >= 0
}

func (MapRepresentation_Listpairs) ListIterator() ipld.ListIterator {
	return nil
}
func (MapRepresentation_Listpairs) Length() int {
	return 0
}
func (MapRepresentation_Listpairs) IsAbsent() bool {
	return false
}
func (MapRepresentation_Listpairs) IsNull() bool {
	return false
}
func (MapRepresentation_Listpairs) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsBool()
}
func (MapRepresentation_Listpairs) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsInt()
}
func (MapRepresentation_Listpairs) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsFloat()
}
func (MapRepresentation_Listpairs) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsString()
}
func (MapRepresentation_Listpairs) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsBytes()
}
func (MapRepresentation_Listpairs) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs"}.AsLink()
}
func (MapRepresentation_Listpairs) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Listpairs__Prototype{}
}
type _MapRepresentation_Listpairs__Prototype struct{}

func (_MapRepresentation_Listpairs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Listpairs__Builder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Listpairs__Builder struct {
	_MapRepresentation_Listpairs__Assembler
}
func (nb *_MapRepresentation_Listpairs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Listpairs__Builder) Reset() {
	var w _MapRepresentation_Listpairs
	var m schema.Maybe
	*nb = _MapRepresentation_Listpairs__Builder{_MapRepresentation_Listpairs__Assembler{w: &w, m: &m}}
}
type _MapRepresentation_Listpairs__Assembler struct {
	w *_MapRepresentation_Listpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_MapRepresentation_Listpairs__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__MapRepresentation_Listpairs_sufficient = 0
)
func (na *_MapRepresentation_Listpairs__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Listpairs{}
	}
	return na, nil
}
func (_MapRepresentation_Listpairs__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.BeginList(0)
}
func (na *_MapRepresentation_Listpairs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Listpairs__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignBool(false)
}
func (_MapRepresentation_Listpairs__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignInt(0)
}
func (_MapRepresentation_Listpairs__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignFloat(0)
}
func (_MapRepresentation_Listpairs__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignString("")
}
func (_MapRepresentation_Listpairs__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignBytes(nil)
}
func (_MapRepresentation_Listpairs__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs"}.AssignLink(nil)
}
func (na *_MapRepresentation_Listpairs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Listpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Listpairs", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Listpairs__Assembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Listpairs__Prototype{}
}
func (ma *_MapRepresentation_Listpairs__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Listpairs__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Listpairs", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Listpairs__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Listpairs__KeyAssembler)(ma)
}
func (ma *_MapRepresentation_Listpairs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Listpairs__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Listpairs__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Listpairs__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _MapRepresentation_Listpairs__KeyAssembler _MapRepresentation_Listpairs__Assembler
func (_MapRepresentation_Listpairs__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Listpairs__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Listpairs__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Listpairs__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Listpairs__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Listpairs__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Listpairs__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Listpairs", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Listpairs__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Listpairs__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Listpairs__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Listpairs__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MapRepresentation_Listpairs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MapRepresentation_Listpairs) Representation() ipld.Node {
	return (*_MapRepresentation_Listpairs__Repr)(n)
}
type _MapRepresentation_Listpairs__Repr _MapRepresentation_Listpairs
var (
)
var _ ipld.Node = &_MapRepresentation_Listpairs__Repr{}
func (_MapRepresentation_Listpairs__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_MapRepresentation_Listpairs__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MapRepresentation_Listpairs__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MapRepresentation_Listpairs__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.LookupByIndex(0)
}
func (n _MapRepresentation_Listpairs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MapRepresentation_Listpairs__Repr) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Listpairs__ReprMapItr{n, 0}
}

type _MapRepresentation_Listpairs__ReprMapItr struct {
	n   *_MapRepresentation_Listpairs__Repr
	idx int
	
}

func (itr *_MapRepresentation_Listpairs__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Listpairs__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_MapRepresentation_Listpairs__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_MapRepresentation_Listpairs__Repr) Length() int {
	l := 0
	return l
}
func (_MapRepresentation_Listpairs__Repr) IsAbsent() bool {
	return false
}
func (_MapRepresentation_Listpairs__Repr) IsNull() bool {
	return false
}
func (_MapRepresentation_Listpairs__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsBool()
}
func (_MapRepresentation_Listpairs__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsInt()
}
func (_MapRepresentation_Listpairs__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsFloat()
}
func (_MapRepresentation_Listpairs__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsString()
}
func (_MapRepresentation_Listpairs__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsBytes()
}
func (_MapRepresentation_Listpairs__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Listpairs.Repr"}.AsLink()
}
func (_MapRepresentation_Listpairs__Repr) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Listpairs__ReprPrototype{}
}
type _MapRepresentation_Listpairs__ReprPrototype struct{}

func (_MapRepresentation_Listpairs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Listpairs__ReprBuilder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Listpairs__ReprBuilder struct {
	_MapRepresentation_Listpairs__ReprAssembler
}
func (nb *_MapRepresentation_Listpairs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Listpairs__ReprBuilder) Reset() {
	var w _MapRepresentation_Listpairs
	var m schema.Maybe
	*nb = _MapRepresentation_Listpairs__ReprBuilder{_MapRepresentation_Listpairs__ReprAssembler{w: &w, m: &m}}
}
type _MapRepresentation_Listpairs__ReprAssembler struct {
	w *_MapRepresentation_Listpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_MapRepresentation_Listpairs__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_MapRepresentation_Listpairs__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Listpairs{}
	}
	return na, nil
}
func (_MapRepresentation_Listpairs__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.BeginList(0)
}
func (na *_MapRepresentation_Listpairs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignBool(false)
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignInt(0)
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignFloat(0)
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignString("")
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignBytes(nil)
}
func (_MapRepresentation_Listpairs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Listpairs.Repr"}.AssignLink(nil)
}
func (na *_MapRepresentation_Listpairs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Listpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Listpairs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Listpairs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Listpairs__ReprPrototype{}
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Listpairs.Repr", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Listpairs__ReprKeyAssembler)(ma)
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Listpairs__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _MapRepresentation_Listpairs__ReprKeyAssembler _MapRepresentation_Listpairs__ReprAssembler
func (_MapRepresentation_Listpairs__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Listpairs__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Listpairs__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Listpairs.Repr", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Listpairs.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Listpairs__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Listpairs__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _MapRepresentation_Map__Maybe struct {
	m schema.Maybe
	v MapRepresentation_Map
}
type MaybeMapRepresentation_Map = *_MapRepresentation_Map__Maybe

func (m MaybeMapRepresentation_Map) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMapRepresentation_Map) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMapRepresentation_Map) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMapRepresentation_Map) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMapRepresentation_Map) Must() MapRepresentation_Map {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (MapRepresentation_Map)(&_MapRepresentation_Map{})
var _ schema.TypedNode = (MapRepresentation_Map)(&_MapRepresentation_Map{})
func (MapRepresentation_Map) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n MapRepresentation_Map) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MapRepresentation_Map) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MapRepresentation_Map) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.LookupByIndex(0)
}
func (n MapRepresentation_Map) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MapRepresentation_Map) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Map__MapItr{n, 0}
}

type _MapRepresentation_Map__MapItr struct {
	n MapRepresentation_Map
	idx  int
}

func (itr *_MapRepresentation_Map__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Map__MapItr) Done() bool {
	return itr.idx >= 0
}

func (MapRepresentation_Map) ListIterator() ipld.ListIterator {
	return nil
}
func (MapRepresentation_Map) Length() int {
	return 0
}
func (MapRepresentation_Map) IsAbsent() bool {
	return false
}
func (MapRepresentation_Map) IsNull() bool {
	return false
}
func (MapRepresentation_Map) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsBool()
}
func (MapRepresentation_Map) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsInt()
}
func (MapRepresentation_Map) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsFloat()
}
func (MapRepresentation_Map) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsString()
}
func (MapRepresentation_Map) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsBytes()
}
func (MapRepresentation_Map) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map"}.AsLink()
}
func (MapRepresentation_Map) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Map__Prototype{}
}
type _MapRepresentation_Map__Prototype struct{}

func (_MapRepresentation_Map__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Map__Builder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Map__Builder struct {
	_MapRepresentation_Map__Assembler
}
func (nb *_MapRepresentation_Map__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Map__Builder) Reset() {
	var w _MapRepresentation_Map
	var m schema.Maybe
	*nb = _MapRepresentation_Map__Builder{_MapRepresentation_Map__Assembler{w: &w, m: &m}}
}
type _MapRepresentation_Map__Assembler struct {
	w *_MapRepresentation_Map
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_MapRepresentation_Map__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__MapRepresentation_Map_sufficient = 0
)
func (na *_MapRepresentation_Map__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Map{}
	}
	return na, nil
}
func (_MapRepresentation_Map__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.BeginList(0)
}
func (na *_MapRepresentation_Map__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Map__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignBool(false)
}
func (_MapRepresentation_Map__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignInt(0)
}
func (_MapRepresentation_Map__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignFloat(0)
}
func (_MapRepresentation_Map__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignString("")
}
func (_MapRepresentation_Map__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignBytes(nil)
}
func (_MapRepresentation_Map__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map"}.AssignLink(nil)
}
func (na *_MapRepresentation_Map__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Map", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Map__Assembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Map__Prototype{}
}
func (ma *_MapRepresentation_Map__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Map__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Map", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Map__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Map__KeyAssembler)(ma)
}
func (ma *_MapRepresentation_Map__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Map__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Map__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Map__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _MapRepresentation_Map__KeyAssembler _MapRepresentation_Map__Assembler
func (_MapRepresentation_Map__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Map__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Map__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Map__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Map__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Map__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Map__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Map", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Map__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Map__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Map__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Map__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MapRepresentation_Map) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MapRepresentation_Map) Representation() ipld.Node {
	return (*_MapRepresentation_Map__Repr)(n)
}
type _MapRepresentation_Map__Repr _MapRepresentation_Map
var (
)
var _ ipld.Node = &_MapRepresentation_Map__Repr{}
func (_MapRepresentation_Map__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_MapRepresentation_Map__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MapRepresentation_Map__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MapRepresentation_Map__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.LookupByIndex(0)
}
func (n _MapRepresentation_Map__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MapRepresentation_Map__Repr) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Map__ReprMapItr{n, 0}
}

type _MapRepresentation_Map__ReprMapItr struct {
	n   *_MapRepresentation_Map__Repr
	idx int
	
}

func (itr *_MapRepresentation_Map__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Map__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_MapRepresentation_Map__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_MapRepresentation_Map__Repr) Length() int {
	l := 0
	return l
}
func (_MapRepresentation_Map__Repr) IsAbsent() bool {
	return false
}
func (_MapRepresentation_Map__Repr) IsNull() bool {
	return false
}
func (_MapRepresentation_Map__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsBool()
}
func (_MapRepresentation_Map__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsInt()
}
func (_MapRepresentation_Map__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsFloat()
}
func (_MapRepresentation_Map__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsString()
}
func (_MapRepresentation_Map__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsBytes()
}
func (_MapRepresentation_Map__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Map.Repr"}.AsLink()
}
func (_MapRepresentation_Map__Repr) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Map__ReprPrototype{}
}
type _MapRepresentation_Map__ReprPrototype struct{}

func (_MapRepresentation_Map__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Map__ReprBuilder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Map__ReprBuilder struct {
	_MapRepresentation_Map__ReprAssembler
}
func (nb *_MapRepresentation_Map__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Map__ReprBuilder) Reset() {
	var w _MapRepresentation_Map
	var m schema.Maybe
	*nb = _MapRepresentation_Map__ReprBuilder{_MapRepresentation_Map__ReprAssembler{w: &w, m: &m}}
}
type _MapRepresentation_Map__ReprAssembler struct {
	w *_MapRepresentation_Map
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_MapRepresentation_Map__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_MapRepresentation_Map__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Map{}
	}
	return na, nil
}
func (_MapRepresentation_Map__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.BeginList(0)
}
func (na *_MapRepresentation_Map__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Map__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignBool(false)
}
func (_MapRepresentation_Map__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignInt(0)
}
func (_MapRepresentation_Map__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignFloat(0)
}
func (_MapRepresentation_Map__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignString("")
}
func (_MapRepresentation_Map__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignBytes(nil)
}
func (_MapRepresentation_Map__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Map.Repr"}.AssignLink(nil)
}
func (na *_MapRepresentation_Map__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Map.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Map__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Map__ReprPrototype{}
}
func (ma *_MapRepresentation_Map__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Map__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Map.Repr", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Map__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Map__ReprKeyAssembler)(ma)
}
func (ma *_MapRepresentation_Map__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Map__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Map__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Map__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _MapRepresentation_Map__ReprKeyAssembler _MapRepresentation_Map__ReprAssembler
func (_MapRepresentation_Map__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Map__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Map__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Map__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Map__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Map__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Map__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Map.Repr", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Map__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Map__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Map.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Map__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Map__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _MapRepresentation_Stringpairs) FieldInnerDelim() String {
	return &n.innerDelim
}
func (n _MapRepresentation_Stringpairs) FieldEntryDelim() String {
	return &n.entryDelim
}
type _MapRepresentation_Stringpairs__Maybe struct {
	m schema.Maybe
	v MapRepresentation_Stringpairs
}
type MaybeMapRepresentation_Stringpairs = *_MapRepresentation_Stringpairs__Maybe

func (m MaybeMapRepresentation_Stringpairs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMapRepresentation_Stringpairs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMapRepresentation_Stringpairs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMapRepresentation_Stringpairs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMapRepresentation_Stringpairs) Must() MapRepresentation_Stringpairs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__MapRepresentation_Stringpairs_InnerDelim = _String{"innerDelim"}
	fieldName__MapRepresentation_Stringpairs_EntryDelim = _String{"entryDelim"}
)
var _ ipld.Node = (MapRepresentation_Stringpairs)(&_MapRepresentation_Stringpairs{})
var _ schema.TypedNode = (MapRepresentation_Stringpairs)(&_MapRepresentation_Stringpairs{})
func (MapRepresentation_Stringpairs) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n MapRepresentation_Stringpairs) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "innerDelim":
		return &n.innerDelim, nil
	case "entryDelim":
		return &n.entryDelim, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MapRepresentation_Stringpairs) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MapRepresentation_Stringpairs) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.LookupByIndex(0)
}
func (n MapRepresentation_Stringpairs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MapRepresentation_Stringpairs) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Stringpairs__MapItr{n, 0}
}

type _MapRepresentation_Stringpairs__MapItr struct {
	n MapRepresentation_Stringpairs
	idx  int
}

func (itr *_MapRepresentation_Stringpairs__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MapRepresentation_Stringpairs_InnerDelim
		v = &itr.n.innerDelim
	case 1:
		k = &fieldName__MapRepresentation_Stringpairs_EntryDelim
		v = &itr.n.entryDelim
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Stringpairs__MapItr) Done() bool {
	return itr.idx >= 2
}

func (MapRepresentation_Stringpairs) ListIterator() ipld.ListIterator {
	return nil
}
func (MapRepresentation_Stringpairs) Length() int {
	return 2
}
func (MapRepresentation_Stringpairs) IsAbsent() bool {
	return false
}
func (MapRepresentation_Stringpairs) IsNull() bool {
	return false
}
func (MapRepresentation_Stringpairs) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsBool()
}
func (MapRepresentation_Stringpairs) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsInt()
}
func (MapRepresentation_Stringpairs) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsFloat()
}
func (MapRepresentation_Stringpairs) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsString()
}
func (MapRepresentation_Stringpairs) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsBytes()
}
func (MapRepresentation_Stringpairs) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs"}.AsLink()
}
func (MapRepresentation_Stringpairs) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Stringpairs__Prototype{}
}
type _MapRepresentation_Stringpairs__Prototype struct{}

func (_MapRepresentation_Stringpairs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Stringpairs__Builder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Stringpairs__Builder struct {
	_MapRepresentation_Stringpairs__Assembler
}
func (nb *_MapRepresentation_Stringpairs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Stringpairs__Builder) Reset() {
	var w _MapRepresentation_Stringpairs
	var m schema.Maybe
	*nb = _MapRepresentation_Stringpairs__Builder{_MapRepresentation_Stringpairs__Assembler{w: &w, m: &m}}
}
type _MapRepresentation_Stringpairs__Assembler struct {
	w *_MapRepresentation_Stringpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_innerDelim _String__Assembler
	ca_entryDelim _String__Assembler
	}

func (na *_MapRepresentation_Stringpairs__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_innerDelim.reset()
	na.ca_entryDelim.reset()
}

var (
	fieldBit__MapRepresentation_Stringpairs_InnerDelim = 1 << 0
	fieldBit__MapRepresentation_Stringpairs_EntryDelim = 1 << 1
	fieldBits__MapRepresentation_Stringpairs_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_MapRepresentation_Stringpairs__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Stringpairs{}
	}
	return na, nil
}
func (_MapRepresentation_Stringpairs__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.BeginList(0)
}
func (na *_MapRepresentation_Stringpairs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Stringpairs__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignBool(false)
}
func (_MapRepresentation_Stringpairs__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignInt(0)
}
func (_MapRepresentation_Stringpairs__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignFloat(0)
}
func (_MapRepresentation_Stringpairs__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignString("")
}
func (_MapRepresentation_Stringpairs__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignBytes(nil)
}
func (_MapRepresentation_Stringpairs__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs"}.AssignLink(nil)
}
func (na *_MapRepresentation_Stringpairs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Stringpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Stringpairs", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Stringpairs__Assembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Stringpairs__Prototype{}
}
func (ma *_MapRepresentation_Stringpairs__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_innerDelim.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_entryDelim.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Stringpairs__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "innerDelim":
		if ma.s & fieldBit__MapRepresentation_Stringpairs_InnerDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_InnerDelim}
		}
		ma.s += fieldBit__MapRepresentation_Stringpairs_InnerDelim
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim, nil
	case "entryDelim":
		if ma.s & fieldBit__MapRepresentation_Stringpairs_EntryDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_EntryDelim}
		}
		ma.s += fieldBit__MapRepresentation_Stringpairs_EntryDelim
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Stringpairs", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Stringpairs__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Stringpairs__KeyAssembler)(ma)
}
func (ma *_MapRepresentation_Stringpairs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim
	case 1:
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Stringpairs__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Stringpairs__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Stringpairs__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _MapRepresentation_Stringpairs__KeyAssembler _MapRepresentation_Stringpairs__Assembler
func (_MapRepresentation_Stringpairs__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Stringpairs__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Stringpairs__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Stringpairs__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Stringpairs__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Stringpairs__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Stringpairs__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "innerDelim":
		if ka.s & fieldBit__MapRepresentation_Stringpairs_InnerDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_InnerDelim}
		}
		ka.s += fieldBit__MapRepresentation_Stringpairs_InnerDelim
		ka.state = maState_expectValue
		ka.f = 0
	case "entryDelim":
		if ka.s & fieldBit__MapRepresentation_Stringpairs_EntryDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_EntryDelim}
		}
		ka.s += fieldBit__MapRepresentation_Stringpairs_EntryDelim
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Stringpairs", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Stringpairs__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Stringpairs__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Stringpairs__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Stringpairs__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MapRepresentation_Stringpairs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MapRepresentation_Stringpairs) Representation() ipld.Node {
	return (*_MapRepresentation_Stringpairs__Repr)(n)
}
type _MapRepresentation_Stringpairs__Repr _MapRepresentation_Stringpairs
var (
	fieldName__MapRepresentation_Stringpairs_InnerDelim_serial = _String{"innerDelim"}
	fieldName__MapRepresentation_Stringpairs_EntryDelim_serial = _String{"entryDelim"}
)
var _ ipld.Node = &_MapRepresentation_Stringpairs__Repr{}
func (_MapRepresentation_Stringpairs__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_MapRepresentation_Stringpairs__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "innerDelim":
		return n.innerDelim.Representation(), nil
	case "entryDelim":
		return n.entryDelim.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MapRepresentation_Stringpairs__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MapRepresentation_Stringpairs__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.LookupByIndex(0)
}
func (n _MapRepresentation_Stringpairs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MapRepresentation_Stringpairs__Repr) MapIterator() ipld.MapIterator {
	return &_MapRepresentation_Stringpairs__ReprMapItr{n, 0}
}

type _MapRepresentation_Stringpairs__ReprMapItr struct {
	n   *_MapRepresentation_Stringpairs__Repr
	idx int
	
}

func (itr *_MapRepresentation_Stringpairs__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MapRepresentation_Stringpairs_InnerDelim_serial
		v = itr.n.innerDelim.Representation()
	case 1:
		k = &fieldName__MapRepresentation_Stringpairs_EntryDelim_serial
		v = itr.n.entryDelim.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MapRepresentation_Stringpairs__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_MapRepresentation_Stringpairs__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_MapRepresentation_Stringpairs__Repr) Length() int {
	l := 2
	return l
}
func (_MapRepresentation_Stringpairs__Repr) IsAbsent() bool {
	return false
}
func (_MapRepresentation_Stringpairs__Repr) IsNull() bool {
	return false
}
func (_MapRepresentation_Stringpairs__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsBool()
}
func (_MapRepresentation_Stringpairs__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsInt()
}
func (_MapRepresentation_Stringpairs__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsFloat()
}
func (_MapRepresentation_Stringpairs__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsString()
}
func (_MapRepresentation_Stringpairs__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsBytes()
}
func (_MapRepresentation_Stringpairs__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AsLink()
}
func (_MapRepresentation_Stringpairs__Repr) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Stringpairs__ReprPrototype{}
}
type _MapRepresentation_Stringpairs__ReprPrototype struct{}

func (_MapRepresentation_Stringpairs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MapRepresentation_Stringpairs__ReprBuilder
	nb.Reset()
	return &nb
}
type _MapRepresentation_Stringpairs__ReprBuilder struct {
	_MapRepresentation_Stringpairs__ReprAssembler
}
func (nb *_MapRepresentation_Stringpairs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MapRepresentation_Stringpairs__ReprBuilder) Reset() {
	var w _MapRepresentation_Stringpairs
	var m schema.Maybe
	*nb = _MapRepresentation_Stringpairs__ReprBuilder{_MapRepresentation_Stringpairs__ReprAssembler{w: &w, m: &m}}
}
type _MapRepresentation_Stringpairs__ReprAssembler struct {
	w *_MapRepresentation_Stringpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_innerDelim _String__ReprAssembler
	ca_entryDelim _String__ReprAssembler
	}

func (na *_MapRepresentation_Stringpairs__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_innerDelim.reset()
	na.ca_entryDelim.reset()
}
func (na *_MapRepresentation_Stringpairs__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MapRepresentation_Stringpairs{}
	}
	return na, nil
}
func (_MapRepresentation_Stringpairs__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.BeginList(0)
}
func (na *_MapRepresentation_Stringpairs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignBool(false)
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignInt(0)
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignFloat(0)
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignString("")
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignBytes(nil)
}
func (_MapRepresentation_Stringpairs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr"}.AssignLink(nil)
}
func (na *_MapRepresentation_Stringpairs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MapRepresentation_Stringpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.MapRepresentation_Stringpairs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MapRepresentation_Stringpairs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MapRepresentation_Stringpairs__ReprPrototype{}
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "innerDelim":
		if ma.s & fieldBit__MapRepresentation_Stringpairs_InnerDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_InnerDelim_serial}
		}
		ma.s += fieldBit__MapRepresentation_Stringpairs_InnerDelim
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim, nil
	case "entryDelim":
		if ma.s & fieldBit__MapRepresentation_Stringpairs_EntryDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_EntryDelim_serial}
		}
		ma.s += fieldBit__MapRepresentation_Stringpairs_EntryDelim
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Stringpairs.Repr", Key:&_String{k}}
	}
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MapRepresentation_Stringpairs__ReprKeyAssembler)(ma)
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim
	case 1:
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim
	default:
		panic("unreachable")
	}
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MapRepresentation_Stringpairs__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _MapRepresentation_Stringpairs__ReprKeyAssembler _MapRepresentation_Stringpairs__ReprAssembler
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignNull()
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "innerDelim":
		if ka.s & fieldBit__MapRepresentation_Stringpairs_InnerDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_InnerDelim_serial}
		}
		ka.s += fieldBit__MapRepresentation_Stringpairs_InnerDelim
		ka.state = maState_expectValue
		ka.f = 0
	case "entryDelim":
		if ka.s & fieldBit__MapRepresentation_Stringpairs_EntryDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__MapRepresentation_Stringpairs_EntryDelim_serial}
		}
		ka.s += fieldBit__MapRepresentation_Stringpairs_EntryDelim
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.MapRepresentation_Stringpairs.Repr", Key:&_String{k}}
	}
	return nil
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.MapRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MapRepresentation_Stringpairs__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MapRepresentation_Stringpairs__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Map__EnumValue__Unit) Lookup(k EnumValue) Unit {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_Map__EnumValue__Unit) LookupMaybe(k EnumValue) MaybeUnit {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__EnumValue__Unit__valueAbsent
	}
	return &_Unit__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Map__EnumValue__Unit__valueAbsent = _Unit__Maybe{m:schema.Maybe_Absent}
func (n Map__EnumValue__Unit) Iterator() *Map__EnumValue__Unit__Itr {
	return &Map__EnumValue__Unit__Itr{n, 0}
}

type Map__EnumValue__Unit__Itr struct {
	n Map__EnumValue__Unit
	idx  int
}

func (itr *Map__EnumValue__Unit__Itr) Next() (k EnumValue, v Unit) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__EnumValue__Unit__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__EnumValue__Unit__Maybe struct {
	m schema.Maybe
	v Map__EnumValue__Unit
}
type MaybeMap__EnumValue__Unit = *_Map__EnumValue__Unit__Maybe

func (m MaybeMap__EnumValue__Unit) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap__EnumValue__Unit) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap__EnumValue__Unit) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap__EnumValue__Unit) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap__EnumValue__Unit) Must() Map__EnumValue__Unit {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map__EnumValue__Unit)(&_Map__EnumValue__Unit{})
var _ schema.TypedNode = (Map__EnumValue__Unit)(&_Map__EnumValue__Unit{})
func (Map__EnumValue__Unit) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Map__EnumValue__Unit) LookupByString(k string) (ipld.Node, error) {
	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n Map__EnumValue__Unit) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(EnumValue)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.Map__EnumValue__Unit", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (Map__EnumValue__Unit) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.LookupByIndex(0)
}
func (n Map__EnumValue__Unit) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map__EnumValue__Unit) MapIterator() ipld.MapIterator {
	return &_Map__EnumValue__Unit__MapItr{n, 0}
}

type _Map__EnumValue__Unit__MapItr struct {
	n Map__EnumValue__Unit
	idx  int
}

func (itr *_Map__EnumValue__Unit__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_Map__EnumValue__Unit__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map__EnumValue__Unit) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map__EnumValue__Unit) Length() int {
	return len(n.t)
}
func (Map__EnumValue__Unit) IsAbsent() bool {
	return false
}
func (Map__EnumValue__Unit) IsNull() bool {
	return false
}
func (Map__EnumValue__Unit) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsBool()
}
func (Map__EnumValue__Unit) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsInt()
}
func (Map__EnumValue__Unit) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsFloat()
}
func (Map__EnumValue__Unit) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsString()
}
func (Map__EnumValue__Unit) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsBytes()
}
func (Map__EnumValue__Unit) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit"}.AsLink()
}
func (Map__EnumValue__Unit) Prototype() ipld.NodePrototype {
	return _Map__EnumValue__Unit__Prototype{}
}
type _Map__EnumValue__Unit__Prototype struct{}

func (_Map__EnumValue__Unit__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__EnumValue__Unit__Builder
	nb.Reset()
	return &nb
}
type _Map__EnumValue__Unit__Builder struct {
	_Map__EnumValue__Unit__Assembler
}
func (nb *_Map__EnumValue__Unit__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__EnumValue__Unit__Builder) Reset() {
	var w _Map__EnumValue__Unit
	var m schema.Maybe
	*nb = _Map__EnumValue__Unit__Builder{_Map__EnumValue__Unit__Assembler{w: &w, m: &m}}
}
type _Map__EnumValue__Unit__Assembler struct {
	w *_Map__EnumValue__Unit
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__Assembler
	va _Unit__Assembler
}

func (na *_Map__EnumValue__Unit__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__EnumValue__Unit__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__EnumValue__Unit{}
	}
	na.w.m = make(map[_EnumValue]*_Unit, sizeHint)
	na.w.t = make([]_Map__EnumValue__Unit__entry, 0, sizeHint)
	return na, nil
}
func (_Map__EnumValue__Unit__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.BeginList(0)
}
func (na *_Map__EnumValue__Unit__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__EnumValue__Unit__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignBool(false)
}
func (_Map__EnumValue__Unit__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignInt(0)
}
func (_Map__EnumValue__Unit__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignFloat(0)
}
func (_Map__EnumValue__Unit__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignString("")
}
func (_Map__EnumValue__Unit__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignBytes(nil)
}
func (_Map__EnumValue__Unit__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit"}.AssignLink(nil)
}
func (na *_Map__EnumValue__Unit__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__EnumValue__Unit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__EnumValue__Unit", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__EnumValue__Unit__Assembler) Prototype() ipld.NodePrototype {
	return _Map__EnumValue__Unit__Prototype{}
}
func (ma *_Map__EnumValue__Unit__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__EnumValue__Unit__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__EnumValue__Unit__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__EnumValue__Unit__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__EnumValue__Unit__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__EnumValue__Unit__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__EnumValue__Unit__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__EnumValue__Unit__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__EnumValue__Unit__Assembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__Prototype{}
}
func (ma *_Map__EnumValue__Unit__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Unit__Prototype{}
}
func (Map__EnumValue__Unit) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map__EnumValue__Unit) Representation() ipld.Node {
	return (*_Map__EnumValue__Unit__Repr)(n)
}
type _Map__EnumValue__Unit__Repr _Map__EnumValue__Unit
var _ ipld.Node = &_Map__EnumValue__Unit__Repr{}
func (_Map__EnumValue__Unit__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_Map__EnumValue__Unit__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map__EnumValue__Unit)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Unit).Representation(), nil
}
func (nr *_Map__EnumValue__Unit__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map__EnumValue__Unit)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Unit).Representation(), nil
}
func (_Map__EnumValue__Unit__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.LookupByIndex(0)
}
func (n _Map__EnumValue__Unit__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__EnumValue__Unit__Repr) MapIterator() ipld.MapIterator {
	return &_Map__EnumValue__Unit__ReprMapItr{(Map__EnumValue__Unit)(nr), 0}
}

type _Map__EnumValue__Unit__ReprMapItr _Map__EnumValue__Unit__MapItr

func (itr *_Map__EnumValue__Unit__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__EnumValue__Unit__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(Unit).Representation(), nil
}
func (itr *_Map__EnumValue__Unit__ReprMapItr) Done() bool {
	return (*_Map__EnumValue__Unit__MapItr)(itr).Done()
}

func (_Map__EnumValue__Unit__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__EnumValue__Unit__Repr) Length() int {
	return len(rn.t)
}
func (_Map__EnumValue__Unit__Repr) IsAbsent() bool {
	return false
}
func (_Map__EnumValue__Unit__Repr) IsNull() bool {
	return false
}
func (_Map__EnumValue__Unit__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsBool()
}
func (_Map__EnumValue__Unit__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsInt()
}
func (_Map__EnumValue__Unit__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsFloat()
}
func (_Map__EnumValue__Unit__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsString()
}
func (_Map__EnumValue__Unit__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsBytes()
}
func (_Map__EnumValue__Unit__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__EnumValue__Unit.Repr"}.AsLink()
}
func (_Map__EnumValue__Unit__Repr) Prototype() ipld.NodePrototype {
	return _Map__EnumValue__Unit__ReprPrototype{}
}
type _Map__EnumValue__Unit__ReprPrototype struct{}

func (_Map__EnumValue__Unit__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__EnumValue__Unit__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__EnumValue__Unit__ReprBuilder struct {
	_Map__EnumValue__Unit__ReprAssembler
}
func (nb *_Map__EnumValue__Unit__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__EnumValue__Unit__ReprBuilder) Reset() {
	var w _Map__EnumValue__Unit
	var m schema.Maybe
	*nb = _Map__EnumValue__Unit__ReprBuilder{_Map__EnumValue__Unit__ReprAssembler{w: &w, m: &m}}
}
type _Map__EnumValue__Unit__ReprAssembler struct {
	w *_Map__EnumValue__Unit
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _EnumValue__ReprAssembler
	va _Unit__ReprAssembler
}

func (na *_Map__EnumValue__Unit__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__EnumValue__Unit__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__EnumValue__Unit{}
	}
	na.w.m = make(map[_EnumValue]*_Unit, sizeHint)
	na.w.t = make([]_Map__EnumValue__Unit__entry, 0, sizeHint)
	return na, nil
}
func (_Map__EnumValue__Unit__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.BeginList(0)
}
func (na *_Map__EnumValue__Unit__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignBool(false)
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignInt(0)
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignFloat(0)
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignString("")
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignBytes(nil)
}
func (_Map__EnumValue__Unit__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__EnumValue__Unit.Repr"}.AssignLink(nil)
}
func (na *_Map__EnumValue__Unit__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__EnumValue__Unit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__EnumValue__Unit.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__EnumValue__Unit__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__EnumValue__Unit__ReprPrototype{}
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _EnumValue
	if err := (_EnumValue__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__EnumValue__Unit__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__EnumValue__Unit__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _EnumValue__ReprPrototype{}
}
func (ma *_Map__EnumValue__Unit__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Unit__ReprPrototype{}
}

func (n *_Map__FieldName__StructField) Lookup(k FieldName) StructField {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_Map__FieldName__StructField) LookupMaybe(k FieldName) MaybeStructField {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__FieldName__StructField__valueAbsent
	}
	return &_StructField__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Map__FieldName__StructField__valueAbsent = _StructField__Maybe{m:schema.Maybe_Absent}
func (n Map__FieldName__StructField) Iterator() *Map__FieldName__StructField__Itr {
	return &Map__FieldName__StructField__Itr{n, 0}
}

type Map__FieldName__StructField__Itr struct {
	n Map__FieldName__StructField
	idx  int
}

func (itr *Map__FieldName__StructField__Itr) Next() (k FieldName, v StructField) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__FieldName__StructField__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__FieldName__StructField__Maybe struct {
	m schema.Maybe
	v Map__FieldName__StructField
}
type MaybeMap__FieldName__StructField = *_Map__FieldName__StructField__Maybe

func (m MaybeMap__FieldName__StructField) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap__FieldName__StructField) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap__FieldName__StructField) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap__FieldName__StructField) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap__FieldName__StructField) Must() Map__FieldName__StructField {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map__FieldName__StructField)(&_Map__FieldName__StructField{})
var _ schema.TypedNode = (Map__FieldName__StructField)(&_Map__FieldName__StructField{})
func (Map__FieldName__StructField) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Map__FieldName__StructField) LookupByString(k string) (ipld.Node, error) {
	var k2 _FieldName
	if err := (_FieldName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n Map__FieldName__StructField) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(FieldName)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.Map__FieldName__StructField", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (Map__FieldName__StructField) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.LookupByIndex(0)
}
func (n Map__FieldName__StructField) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map__FieldName__StructField) MapIterator() ipld.MapIterator {
	return &_Map__FieldName__StructField__MapItr{n, 0}
}

type _Map__FieldName__StructField__MapItr struct {
	n Map__FieldName__StructField
	idx  int
}

func (itr *_Map__FieldName__StructField__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_Map__FieldName__StructField__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map__FieldName__StructField) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map__FieldName__StructField) Length() int {
	return len(n.t)
}
func (Map__FieldName__StructField) IsAbsent() bool {
	return false
}
func (Map__FieldName__StructField) IsNull() bool {
	return false
}
func (Map__FieldName__StructField) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsBool()
}
func (Map__FieldName__StructField) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsInt()
}
func (Map__FieldName__StructField) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsFloat()
}
func (Map__FieldName__StructField) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsString()
}
func (Map__FieldName__StructField) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsBytes()
}
func (Map__FieldName__StructField) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField"}.AsLink()
}
func (Map__FieldName__StructField) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructField__Prototype{}
}
type _Map__FieldName__StructField__Prototype struct{}

func (_Map__FieldName__StructField__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__FieldName__StructField__Builder
	nb.Reset()
	return &nb
}
type _Map__FieldName__StructField__Builder struct {
	_Map__FieldName__StructField__Assembler
}
func (nb *_Map__FieldName__StructField__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__FieldName__StructField__Builder) Reset() {
	var w _Map__FieldName__StructField
	var m schema.Maybe
	*nb = _Map__FieldName__StructField__Builder{_Map__FieldName__StructField__Assembler{w: &w, m: &m}}
}
type _Map__FieldName__StructField__Assembler struct {
	w *_Map__FieldName__StructField
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _FieldName__Assembler
	va _StructField__Assembler
}

func (na *_Map__FieldName__StructField__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__FieldName__StructField__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__FieldName__StructField{}
	}
	na.w.m = make(map[_FieldName]*_StructField, sizeHint)
	na.w.t = make([]_Map__FieldName__StructField__entry, 0, sizeHint)
	return na, nil
}
func (_Map__FieldName__StructField__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.BeginList(0)
}
func (na *_Map__FieldName__StructField__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__FieldName__StructField__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignBool(false)
}
func (_Map__FieldName__StructField__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignInt(0)
}
func (_Map__FieldName__StructField__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignFloat(0)
}
func (_Map__FieldName__StructField__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignString("")
}
func (_Map__FieldName__StructField__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignBytes(nil)
}
func (_Map__FieldName__StructField__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField"}.AssignLink(nil)
}
func (na *_Map__FieldName__StructField__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__FieldName__StructField); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__FieldName__StructField", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__FieldName__StructField__Assembler) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructField__Prototype{}
}
func (ma *_Map__FieldName__StructField__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructField__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructField__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _FieldName
	if err := (_FieldName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructField__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__FieldName__StructField__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructField__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__FieldName__StructField__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__FieldName__StructField__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__FieldName__StructField__Assembler) KeyPrototype() ipld.NodePrototype {
	return _FieldName__Prototype{}
}
func (ma *_Map__FieldName__StructField__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _StructField__Prototype{}
}
func (Map__FieldName__StructField) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map__FieldName__StructField) Representation() ipld.Node {
	return (*_Map__FieldName__StructField__Repr)(n)
}
type _Map__FieldName__StructField__Repr _Map__FieldName__StructField
var _ ipld.Node = &_Map__FieldName__StructField__Repr{}
func (_Map__FieldName__StructField__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_Map__FieldName__StructField__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map__FieldName__StructField)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StructField).Representation(), nil
}
func (nr *_Map__FieldName__StructField__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map__FieldName__StructField)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StructField).Representation(), nil
}
func (_Map__FieldName__StructField__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.LookupByIndex(0)
}
func (n _Map__FieldName__StructField__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__FieldName__StructField__Repr) MapIterator() ipld.MapIterator {
	return &_Map__FieldName__StructField__ReprMapItr{(Map__FieldName__StructField)(nr), 0}
}

type _Map__FieldName__StructField__ReprMapItr _Map__FieldName__StructField__MapItr

func (itr *_Map__FieldName__StructField__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__FieldName__StructField__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(StructField).Representation(), nil
}
func (itr *_Map__FieldName__StructField__ReprMapItr) Done() bool {
	return (*_Map__FieldName__StructField__MapItr)(itr).Done()
}

func (_Map__FieldName__StructField__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__FieldName__StructField__Repr) Length() int {
	return len(rn.t)
}
func (_Map__FieldName__StructField__Repr) IsAbsent() bool {
	return false
}
func (_Map__FieldName__StructField__Repr) IsNull() bool {
	return false
}
func (_Map__FieldName__StructField__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsBool()
}
func (_Map__FieldName__StructField__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsInt()
}
func (_Map__FieldName__StructField__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsFloat()
}
func (_Map__FieldName__StructField__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsString()
}
func (_Map__FieldName__StructField__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsBytes()
}
func (_Map__FieldName__StructField__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructField.Repr"}.AsLink()
}
func (_Map__FieldName__StructField__Repr) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructField__ReprPrototype{}
}
type _Map__FieldName__StructField__ReprPrototype struct{}

func (_Map__FieldName__StructField__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__FieldName__StructField__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__FieldName__StructField__ReprBuilder struct {
	_Map__FieldName__StructField__ReprAssembler
}
func (nb *_Map__FieldName__StructField__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__FieldName__StructField__ReprBuilder) Reset() {
	var w _Map__FieldName__StructField
	var m schema.Maybe
	*nb = _Map__FieldName__StructField__ReprBuilder{_Map__FieldName__StructField__ReprAssembler{w: &w, m: &m}}
}
type _Map__FieldName__StructField__ReprAssembler struct {
	w *_Map__FieldName__StructField
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _FieldName__ReprAssembler
	va _StructField__ReprAssembler
}

func (na *_Map__FieldName__StructField__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__FieldName__StructField__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__FieldName__StructField{}
	}
	na.w.m = make(map[_FieldName]*_StructField, sizeHint)
	na.w.t = make([]_Map__FieldName__StructField__entry, 0, sizeHint)
	return na, nil
}
func (_Map__FieldName__StructField__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.BeginList(0)
}
func (na *_Map__FieldName__StructField__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__FieldName__StructField__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignBool(false)
}
func (_Map__FieldName__StructField__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignInt(0)
}
func (_Map__FieldName__StructField__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignFloat(0)
}
func (_Map__FieldName__StructField__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignString("")
}
func (_Map__FieldName__StructField__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignBytes(nil)
}
func (_Map__FieldName__StructField__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructField.Repr"}.AssignLink(nil)
}
func (na *_Map__FieldName__StructField__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__FieldName__StructField); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__FieldName__StructField.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__FieldName__StructField__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructField__ReprPrototype{}
}
func (ma *_Map__FieldName__StructField__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructField__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructField__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _FieldName
	if err := (_FieldName__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructField__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__FieldName__StructField__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructField__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__FieldName__StructField__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__FieldName__StructField__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__FieldName__StructField__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _FieldName__ReprPrototype{}
}
func (ma *_Map__FieldName__StructField__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _StructField__ReprPrototype{}
}

func (n *_Map__FieldName__StructRepresentation_Map_FieldDetails) Lookup(k FieldName) StructRepresentation_Map_FieldDetails {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_Map__FieldName__StructRepresentation_Map_FieldDetails) LookupMaybe(k FieldName) MaybeStructRepresentation_Map_FieldDetails {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__FieldName__StructRepresentation_Map_FieldDetails__valueAbsent
	}
	return &_StructRepresentation_Map_FieldDetails__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Map__FieldName__StructRepresentation_Map_FieldDetails__valueAbsent = _StructRepresentation_Map_FieldDetails__Maybe{m:schema.Maybe_Absent}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) Iterator() *Map__FieldName__StructRepresentation_Map_FieldDetails__Itr {
	return &Map__FieldName__StructRepresentation_Map_FieldDetails__Itr{n, 0}
}

type Map__FieldName__StructRepresentation_Map_FieldDetails__Itr struct {
	n Map__FieldName__StructRepresentation_Map_FieldDetails
	idx  int
}

func (itr *Map__FieldName__StructRepresentation_Map_FieldDetails__Itr) Next() (k FieldName, v StructRepresentation_Map_FieldDetails) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__FieldName__StructRepresentation_Map_FieldDetails__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__FieldName__StructRepresentation_Map_FieldDetails__Maybe struct {
	m schema.Maybe
	v Map__FieldName__StructRepresentation_Map_FieldDetails
}
type MaybeMap__FieldName__StructRepresentation_Map_FieldDetails = *_Map__FieldName__StructRepresentation_Map_FieldDetails__Maybe

func (m MaybeMap__FieldName__StructRepresentation_Map_FieldDetails) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap__FieldName__StructRepresentation_Map_FieldDetails) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap__FieldName__StructRepresentation_Map_FieldDetails) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap__FieldName__StructRepresentation_Map_FieldDetails) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap__FieldName__StructRepresentation_Map_FieldDetails) Must() Map__FieldName__StructRepresentation_Map_FieldDetails {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map__FieldName__StructRepresentation_Map_FieldDetails)(&_Map__FieldName__StructRepresentation_Map_FieldDetails{})
var _ schema.TypedNode = (Map__FieldName__StructRepresentation_Map_FieldDetails)(&_Map__FieldName__StructRepresentation_Map_FieldDetails{})
func (Map__FieldName__StructRepresentation_Map_FieldDetails) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) LookupByString(k string) (ipld.Node, error) {
	var k2 _FieldName
	if err := (_FieldName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(FieldName)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.LookupByIndex(0)
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) MapIterator() ipld.MapIterator {
	return &_Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr{n, 0}
}

type _Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr struct {
	n Map__FieldName__StructRepresentation_Map_FieldDetails
	idx  int
}

func (itr *_Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map__FieldName__StructRepresentation_Map_FieldDetails) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) Length() int {
	return len(n.t)
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) IsAbsent() bool {
	return false
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) IsNull() bool {
	return false
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsBool()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsInt()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsFloat()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsString()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsBytes()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AsLink()
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructRepresentation_Map_FieldDetails__Prototype{}
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__Prototype struct{}

func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__FieldName__StructRepresentation_Map_FieldDetails__Builder
	nb.Reset()
	return &nb
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__Builder struct {
	_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler
}
func (nb *_Map__FieldName__StructRepresentation_Map_FieldDetails__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__FieldName__StructRepresentation_Map_FieldDetails__Builder) Reset() {
	var w _Map__FieldName__StructRepresentation_Map_FieldDetails
	var m schema.Maybe
	*nb = _Map__FieldName__StructRepresentation_Map_FieldDetails__Builder{_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler{w: &w, m: &m}}
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler struct {
	w *_Map__FieldName__StructRepresentation_Map_FieldDetails
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _FieldName__Assembler
	va _StructRepresentation_Map_FieldDetails__Assembler
}

func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__FieldName__StructRepresentation_Map_FieldDetails{}
	}
	na.w.m = make(map[_FieldName]*_StructRepresentation_Map_FieldDetails, sizeHint)
	na.w.t = make([]_Map__FieldName__StructRepresentation_Map_FieldDetails__entry, 0, sizeHint)
	return na, nil
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.BeginList(0)
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignBool(false)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignInt(0)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignFloat(0)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignString("")
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignBytes(nil)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails"}.AssignLink(nil)
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__FieldName__StructRepresentation_Map_FieldDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructRepresentation_Map_FieldDetails__Prototype{}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _FieldName
	if err := (_FieldName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructRepresentation_Map_FieldDetails__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructRepresentation_Map_FieldDetails__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) KeyPrototype() ipld.NodePrototype {
	return _FieldName__Prototype{}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__Prototype{}
}
func (Map__FieldName__StructRepresentation_Map_FieldDetails) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map__FieldName__StructRepresentation_Map_FieldDetails) Representation() ipld.Node {
	return (*_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr)(n)
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__Repr _Map__FieldName__StructRepresentation_Map_FieldDetails
var _ ipld.Node = &_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr{}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map__FieldName__StructRepresentation_Map_FieldDetails)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StructRepresentation_Map_FieldDetails).Representation(), nil
}
func (nr *_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map__FieldName__StructRepresentation_Map_FieldDetails)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StructRepresentation_Map_FieldDetails).Representation(), nil
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.LookupByIndex(0)
}
func (n _Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) MapIterator() ipld.MapIterator {
	return &_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprMapItr{(Map__FieldName__StructRepresentation_Map_FieldDetails)(nr), 0}
}

type _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprMapItr _Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr

func (itr *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(StructRepresentation_Map_FieldDetails).Representation(), nil
}
func (itr *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprMapItr) Done() bool {
	return (*_Map__FieldName__StructRepresentation_Map_FieldDetails__MapItr)(itr).Done()
}

func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) Length() int {
	return len(rn.t)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) IsAbsent() bool {
	return false
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) IsNull() bool {
	return false
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsBool()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsInt()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsFloat()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsString()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsBytes()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AsLink()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__Repr) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprPrototype{}
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprPrototype struct{}

func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprBuilder struct {
	_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler
}
func (nb *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprBuilder) Reset() {
	var w _Map__FieldName__StructRepresentation_Map_FieldDetails
	var m schema.Maybe
	*nb = _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprBuilder{_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler{w: &w, m: &m}}
}
type _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler struct {
	w *_Map__FieldName__StructRepresentation_Map_FieldDetails
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _FieldName__ReprAssembler
	va _StructRepresentation_Map_FieldDetails__ReprAssembler
}

func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__FieldName__StructRepresentation_Map_FieldDetails{}
	}
	na.w.m = make(map[_FieldName]*_StructRepresentation_Map_FieldDetails, sizeHint)
	na.w.t = make([]_Map__FieldName__StructRepresentation_Map_FieldDetails__entry, 0, sizeHint)
	return na, nil
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.BeginList(0)
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignBool(false)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignInt(0)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignFloat(0)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignString("")
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignBytes(nil)
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr"}.AssignLink(nil)
}
func (na *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__FieldName__StructRepresentation_Map_FieldDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__FieldName__StructRepresentation_Map_FieldDetails.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprPrototype{}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _FieldName
	if err := (_FieldName__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructRepresentation_Map_FieldDetails__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__FieldName__StructRepresentation_Map_FieldDetails__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _FieldName__ReprPrototype{}
}
func (ma *_Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__ReprPrototype{}
}

func (n *_Map__String__TypeName) Lookup(k String) TypeName {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_Map__String__TypeName) LookupMaybe(k String) MaybeTypeName {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__String__TypeName__valueAbsent
	}
	return &_TypeName__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Map__String__TypeName__valueAbsent = _TypeName__Maybe{m:schema.Maybe_Absent}
func (n Map__String__TypeName) Iterator() *Map__String__TypeName__Itr {
	return &Map__String__TypeName__Itr{n, 0}
}

type Map__String__TypeName__Itr struct {
	n Map__String__TypeName
	idx  int
}

func (itr *Map__String__TypeName__Itr) Next() (k String, v TypeName) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__String__TypeName__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__String__TypeName__Maybe struct {
	m schema.Maybe
	v Map__String__TypeName
}
type MaybeMap__String__TypeName = *_Map__String__TypeName__Maybe

func (m MaybeMap__String__TypeName) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap__String__TypeName) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap__String__TypeName) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap__String__TypeName) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap__String__TypeName) Must() Map__String__TypeName {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map__String__TypeName)(&_Map__String__TypeName{})
var _ schema.TypedNode = (Map__String__TypeName)(&_Map__String__TypeName{})
func (Map__String__TypeName) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Map__String__TypeName) LookupByString(k string) (ipld.Node, error) {
	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n Map__String__TypeName) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(String)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.Map__String__TypeName", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (Map__String__TypeName) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.LookupByIndex(0)
}
func (n Map__String__TypeName) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map__String__TypeName) MapIterator() ipld.MapIterator {
	return &_Map__String__TypeName__MapItr{n, 0}
}

type _Map__String__TypeName__MapItr struct {
	n Map__String__TypeName
	idx  int
}

func (itr *_Map__String__TypeName__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_Map__String__TypeName__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map__String__TypeName) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map__String__TypeName) Length() int {
	return len(n.t)
}
func (Map__String__TypeName) IsAbsent() bool {
	return false
}
func (Map__String__TypeName) IsNull() bool {
	return false
}
func (Map__String__TypeName) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsBool()
}
func (Map__String__TypeName) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsInt()
}
func (Map__String__TypeName) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsFloat()
}
func (Map__String__TypeName) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsString()
}
func (Map__String__TypeName) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsBytes()
}
func (Map__String__TypeName) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName"}.AsLink()
}
func (Map__String__TypeName) Prototype() ipld.NodePrototype {
	return _Map__String__TypeName__Prototype{}
}
type _Map__String__TypeName__Prototype struct{}

func (_Map__String__TypeName__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__String__TypeName__Builder
	nb.Reset()
	return &nb
}
type _Map__String__TypeName__Builder struct {
	_Map__String__TypeName__Assembler
}
func (nb *_Map__String__TypeName__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__String__TypeName__Builder) Reset() {
	var w _Map__String__TypeName
	var m schema.Maybe
	*nb = _Map__String__TypeName__Builder{_Map__String__TypeName__Assembler{w: &w, m: &m}}
}
type _Map__String__TypeName__Assembler struct {
	w *_Map__String__TypeName
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__Assembler
	va _TypeName__Assembler
}

func (na *_Map__String__TypeName__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__String__TypeName__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__String__TypeName{}
	}
	na.w.m = make(map[_String]*_TypeName, sizeHint)
	na.w.t = make([]_Map__String__TypeName__entry, 0, sizeHint)
	return na, nil
}
func (_Map__String__TypeName__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.BeginList(0)
}
func (na *_Map__String__TypeName__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__String__TypeName__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignBool(false)
}
func (_Map__String__TypeName__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignInt(0)
}
func (_Map__String__TypeName__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignFloat(0)
}
func (_Map__String__TypeName__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignString("")
}
func (_Map__String__TypeName__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignBytes(nil)
}
func (_Map__String__TypeName__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName"}.AssignLink(nil)
}
func (na *_Map__String__TypeName__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__String__TypeName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__String__TypeName", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__String__TypeName__Assembler) Prototype() ipld.NodePrototype {
	return _Map__String__TypeName__Prototype{}
}
func (ma *_Map__String__TypeName__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__String__TypeName__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__String__TypeName__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__String__TypeName__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__String__TypeName__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__String__TypeName__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__String__TypeName__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__String__TypeName__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__String__TypeName__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Map__String__TypeName__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (Map__String__TypeName) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map__String__TypeName) Representation() ipld.Node {
	return (*_Map__String__TypeName__Repr)(n)
}
type _Map__String__TypeName__Repr _Map__String__TypeName
var _ ipld.Node = &_Map__String__TypeName__Repr{}
func (_Map__String__TypeName__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_Map__String__TypeName__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map__String__TypeName)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (nr *_Map__String__TypeName__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map__String__TypeName)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (_Map__String__TypeName__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.LookupByIndex(0)
}
func (n _Map__String__TypeName__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__String__TypeName__Repr) MapIterator() ipld.MapIterator {
	return &_Map__String__TypeName__ReprMapItr{(Map__String__TypeName)(nr), 0}
}

type _Map__String__TypeName__ReprMapItr _Map__String__TypeName__MapItr

func (itr *_Map__String__TypeName__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__String__TypeName__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(TypeName).Representation(), nil
}
func (itr *_Map__String__TypeName__ReprMapItr) Done() bool {
	return (*_Map__String__TypeName__MapItr)(itr).Done()
}

func (_Map__String__TypeName__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__String__TypeName__Repr) Length() int {
	return len(rn.t)
}
func (_Map__String__TypeName__Repr) IsAbsent() bool {
	return false
}
func (_Map__String__TypeName__Repr) IsNull() bool {
	return false
}
func (_Map__String__TypeName__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsBool()
}
func (_Map__String__TypeName__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsInt()
}
func (_Map__String__TypeName__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsFloat()
}
func (_Map__String__TypeName__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsString()
}
func (_Map__String__TypeName__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsBytes()
}
func (_Map__String__TypeName__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__String__TypeName.Repr"}.AsLink()
}
func (_Map__String__TypeName__Repr) Prototype() ipld.NodePrototype {
	return _Map__String__TypeName__ReprPrototype{}
}
type _Map__String__TypeName__ReprPrototype struct{}

func (_Map__String__TypeName__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__String__TypeName__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__String__TypeName__ReprBuilder struct {
	_Map__String__TypeName__ReprAssembler
}
func (nb *_Map__String__TypeName__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__String__TypeName__ReprBuilder) Reset() {
	var w _Map__String__TypeName
	var m schema.Maybe
	*nb = _Map__String__TypeName__ReprBuilder{_Map__String__TypeName__ReprAssembler{w: &w, m: &m}}
}
type _Map__String__TypeName__ReprAssembler struct {
	w *_Map__String__TypeName
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__ReprAssembler
	va _TypeName__ReprAssembler
}

func (na *_Map__String__TypeName__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__String__TypeName__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__String__TypeName{}
	}
	na.w.m = make(map[_String]*_TypeName, sizeHint)
	na.w.t = make([]_Map__String__TypeName__entry, 0, sizeHint)
	return na, nil
}
func (_Map__String__TypeName__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.BeginList(0)
}
func (na *_Map__String__TypeName__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__String__TypeName__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignBool(false)
}
func (_Map__String__TypeName__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignInt(0)
}
func (_Map__String__TypeName__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignFloat(0)
}
func (_Map__String__TypeName__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignString("")
}
func (_Map__String__TypeName__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignBytes(nil)
}
func (_Map__String__TypeName__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__String__TypeName.Repr"}.AssignLink(nil)
}
func (na *_Map__String__TypeName__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__String__TypeName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__String__TypeName.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__String__TypeName__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__String__TypeName__ReprPrototype{}
}
func (ma *_Map__String__TypeName__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__String__TypeName__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__String__TypeName__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__String__TypeName__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__String__TypeName__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__String__TypeName__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__String__TypeName__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__String__TypeName__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__String__TypeName__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__ReprPrototype{}
}
func (ma *_Map__String__TypeName__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__ReprPrototype{}
}

func (n *_Map__TypeName__Int) Lookup(k String) Int {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_Map__TypeName__Int) LookupMaybe(k String) MaybeInt {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__TypeName__Int__valueAbsent
	}
	return &_Int__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Map__TypeName__Int__valueAbsent = _Int__Maybe{m:schema.Maybe_Absent}
func (n Map__TypeName__Int) Iterator() *Map__TypeName__Int__Itr {
	return &Map__TypeName__Int__Itr{n, 0}
}

type Map__TypeName__Int__Itr struct {
	n Map__TypeName__Int
	idx  int
}

func (itr *Map__TypeName__Int__Itr) Next() (k String, v Int) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__TypeName__Int__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__TypeName__Int__Maybe struct {
	m schema.Maybe
	v Map__TypeName__Int
}
type MaybeMap__TypeName__Int = *_Map__TypeName__Int__Maybe

func (m MaybeMap__TypeName__Int) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap__TypeName__Int) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap__TypeName__Int) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap__TypeName__Int) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap__TypeName__Int) Must() Map__TypeName__Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map__TypeName__Int)(&_Map__TypeName__Int{})
var _ schema.TypedNode = (Map__TypeName__Int)(&_Map__TypeName__Int{})
func (Map__TypeName__Int) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Map__TypeName__Int) LookupByString(k string) (ipld.Node, error) {
	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n Map__TypeName__Int) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(String)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.Map__TypeName__Int", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (Map__TypeName__Int) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.LookupByIndex(0)
}
func (n Map__TypeName__Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map__TypeName__Int) MapIterator() ipld.MapIterator {
	return &_Map__TypeName__Int__MapItr{n, 0}
}

type _Map__TypeName__Int__MapItr struct {
	n Map__TypeName__Int
	idx  int
}

func (itr *_Map__TypeName__Int__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_Map__TypeName__Int__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map__TypeName__Int) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map__TypeName__Int) Length() int {
	return len(n.t)
}
func (Map__TypeName__Int) IsAbsent() bool {
	return false
}
func (Map__TypeName__Int) IsNull() bool {
	return false
}
func (Map__TypeName__Int) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsBool()
}
func (Map__TypeName__Int) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsInt()
}
func (Map__TypeName__Int) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsFloat()
}
func (Map__TypeName__Int) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsString()
}
func (Map__TypeName__Int) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsBytes()
}
func (Map__TypeName__Int) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int"}.AsLink()
}
func (Map__TypeName__Int) Prototype() ipld.NodePrototype {
	return _Map__TypeName__Int__Prototype{}
}
type _Map__TypeName__Int__Prototype struct{}

func (_Map__TypeName__Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__TypeName__Int__Builder
	nb.Reset()
	return &nb
}
type _Map__TypeName__Int__Builder struct {
	_Map__TypeName__Int__Assembler
}
func (nb *_Map__TypeName__Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__TypeName__Int__Builder) Reset() {
	var w _Map__TypeName__Int
	var m schema.Maybe
	*nb = _Map__TypeName__Int__Builder{_Map__TypeName__Int__Assembler{w: &w, m: &m}}
}
type _Map__TypeName__Int__Assembler struct {
	w *_Map__TypeName__Int
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__Assembler
	va _Int__Assembler
}

func (na *_Map__TypeName__Int__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__TypeName__Int__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__TypeName__Int{}
	}
	na.w.m = make(map[_String]*_Int, sizeHint)
	na.w.t = make([]_Map__TypeName__Int__entry, 0, sizeHint)
	return na, nil
}
func (_Map__TypeName__Int__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.BeginList(0)
}
func (na *_Map__TypeName__Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__TypeName__Int__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignBool(false)
}
func (_Map__TypeName__Int__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignInt(0)
}
func (_Map__TypeName__Int__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignFloat(0)
}
func (_Map__TypeName__Int__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignString("")
}
func (_Map__TypeName__Int__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignBytes(nil)
}
func (_Map__TypeName__Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int"}.AssignLink(nil)
}
func (na *_Map__TypeName__Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__TypeName__Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__TypeName__Int", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__TypeName__Int__Assembler) Prototype() ipld.NodePrototype {
	return _Map__TypeName__Int__Prototype{}
}
func (ma *_Map__TypeName__Int__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__TypeName__Int__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__TypeName__Int__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__TypeName__Int__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__TypeName__Int__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__TypeName__Int__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__TypeName__Int__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__TypeName__Int__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__TypeName__Int__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Map__TypeName__Int__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Map__TypeName__Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map__TypeName__Int) Representation() ipld.Node {
	return (*_Map__TypeName__Int__Repr)(n)
}
type _Map__TypeName__Int__Repr _Map__TypeName__Int
var _ ipld.Node = &_Map__TypeName__Int__Repr{}
func (_Map__TypeName__Int__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_Map__TypeName__Int__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map__TypeName__Int)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Int).Representation(), nil
}
func (nr *_Map__TypeName__Int__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map__TypeName__Int)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Int).Representation(), nil
}
func (_Map__TypeName__Int__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.LookupByIndex(0)
}
func (n _Map__TypeName__Int__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__TypeName__Int__Repr) MapIterator() ipld.MapIterator {
	return &_Map__TypeName__Int__ReprMapItr{(Map__TypeName__Int)(nr), 0}
}

type _Map__TypeName__Int__ReprMapItr _Map__TypeName__Int__MapItr

func (itr *_Map__TypeName__Int__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__TypeName__Int__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(Int).Representation(), nil
}
func (itr *_Map__TypeName__Int__ReprMapItr) Done() bool {
	return (*_Map__TypeName__Int__MapItr)(itr).Done()
}

func (_Map__TypeName__Int__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__TypeName__Int__Repr) Length() int {
	return len(rn.t)
}
func (_Map__TypeName__Int__Repr) IsAbsent() bool {
	return false
}
func (_Map__TypeName__Int__Repr) IsNull() bool {
	return false
}
func (_Map__TypeName__Int__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsBool()
}
func (_Map__TypeName__Int__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsInt()
}
func (_Map__TypeName__Int__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsFloat()
}
func (_Map__TypeName__Int__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsString()
}
func (_Map__TypeName__Int__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsBytes()
}
func (_Map__TypeName__Int__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Map__TypeName__Int.Repr"}.AsLink()
}
func (_Map__TypeName__Int__Repr) Prototype() ipld.NodePrototype {
	return _Map__TypeName__Int__ReprPrototype{}
}
type _Map__TypeName__Int__ReprPrototype struct{}

func (_Map__TypeName__Int__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__TypeName__Int__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__TypeName__Int__ReprBuilder struct {
	_Map__TypeName__Int__ReprAssembler
}
func (nb *_Map__TypeName__Int__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__TypeName__Int__ReprBuilder) Reset() {
	var w _Map__TypeName__Int
	var m schema.Maybe
	*nb = _Map__TypeName__Int__ReprBuilder{_Map__TypeName__Int__ReprAssembler{w: &w, m: &m}}
}
type _Map__TypeName__Int__ReprAssembler struct {
	w *_Map__TypeName__Int
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__ReprAssembler
	va _Int__ReprAssembler
}

func (na *_Map__TypeName__Int__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__TypeName__Int__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map__TypeName__Int{}
	}
	na.w.m = make(map[_String]*_Int, sizeHint)
	na.w.t = make([]_Map__TypeName__Int__entry, 0, sizeHint)
	return na, nil
}
func (_Map__TypeName__Int__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.BeginList(0)
}
func (na *_Map__TypeName__Int__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__TypeName__Int__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignBool(false)
}
func (_Map__TypeName__Int__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignInt(0)
}
func (_Map__TypeName__Int__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignFloat(0)
}
func (_Map__TypeName__Int__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignString("")
}
func (_Map__TypeName__Int__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignBytes(nil)
}
func (_Map__TypeName__Int__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Map__TypeName__Int.Repr"}.AssignLink(nil)
}
func (na *_Map__TypeName__Int__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map__TypeName__Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Map__TypeName__Int.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__TypeName__Int__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__TypeName__Int__ReprPrototype{}
}
func (ma *_Map__TypeName__Int__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__TypeName__Int__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__TypeName__Int__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__TypeName__Int__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_Map__TypeName__Int__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__TypeName__Int__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__TypeName__Int__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__TypeName__Int__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__TypeName__Int__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__ReprPrototype{}
}
func (ma *_Map__TypeName__Int__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Int__ReprPrototype{}
}

func (n RepresentationKind) String() string {
	return n.x
}
func (_RepresentationKind__Prototype) fromString(w *_RepresentationKind, v string) error {
	*w = _RepresentationKind{v}
	return nil
}
func (_RepresentationKind__Prototype) FromString(v string) (RepresentationKind, error) {
	n := _RepresentationKind{v}
	return &n, nil
}
type _RepresentationKind__Maybe struct {
	m schema.Maybe
	v RepresentationKind
}
type MaybeRepresentationKind = *_RepresentationKind__Maybe

func (m MaybeRepresentationKind) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeRepresentationKind) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeRepresentationKind) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeRepresentationKind) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeRepresentationKind) Must() RepresentationKind {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (RepresentationKind)(&_RepresentationKind{})
var _ schema.TypedNode = (RepresentationKind)(&_RepresentationKind{})
func (RepresentationKind) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_String
}
func (RepresentationKind) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.LookupByString("")
}
func (RepresentationKind) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.LookupByNode(nil)
}
func (RepresentationKind) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.LookupByIndex(0)
}
func (RepresentationKind) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.LookupBySegment(seg)
}
func (RepresentationKind) MapIterator() ipld.MapIterator {
	return nil
}
func (RepresentationKind) ListIterator() ipld.ListIterator {
	return nil
}
func (RepresentationKind) Length() int {
	return -1
}
func (RepresentationKind) IsAbsent() bool {
	return false
}
func (RepresentationKind) IsNull() bool {
	return false
}
func (RepresentationKind) AsBool() (bool, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.AsBool()
}
func (RepresentationKind) AsInt() (int, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.AsInt()
}
func (RepresentationKind) AsFloat() (float64, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.AsFloat()
}
func (n RepresentationKind) AsString() (string, error) {
	return n.x, nil
}
func (RepresentationKind) AsBytes() ([]byte, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.AsBytes()
}
func (RepresentationKind) AsLink() (ipld.Link, error) {
	return mixins.String{"schemadmt.RepresentationKind"}.AsLink()
}
func (RepresentationKind) Prototype() ipld.NodePrototype {
	return _RepresentationKind__Prototype{}
}
type _RepresentationKind__Prototype struct{}

func (_RepresentationKind__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _RepresentationKind__Builder
	nb.Reset()
	return &nb
}
type _RepresentationKind__Builder struct {
	_RepresentationKind__Assembler
}
func (nb *_RepresentationKind__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_RepresentationKind__Builder) Reset() {
	var w _RepresentationKind
	var m schema.Maybe
	*nb = _RepresentationKind__Builder{_RepresentationKind__Assembler{w: &w, m: &m}}
}
type _RepresentationKind__Assembler struct {
	w *_RepresentationKind
	m *schema.Maybe
}

func (na *_RepresentationKind__Assembler) reset() {}
func (_RepresentationKind__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.BeginMap(0)
}
func (_RepresentationKind__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.BeginList(0)
}
func (na *_RepresentationKind__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_RepresentationKind__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignBool(false)
}
func (_RepresentationKind__Assembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignInt(0)
}
func (_RepresentationKind__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignFloat(0)
}
func (na *_RepresentationKind__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_RepresentationKind{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_RepresentationKind__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignBytes(nil)
}
func (_RepresentationKind__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.RepresentationKind"}.AssignLink(nil)
}
func (na *_RepresentationKind__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_RepresentationKind); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_RepresentationKind__Assembler) Prototype() ipld.NodePrototype {
	return _RepresentationKind__Prototype{}
}
func (RepresentationKind) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n RepresentationKind) Representation() ipld.Node {
	return (*_RepresentationKind__Repr)(n)
}
type _RepresentationKind__Repr = _RepresentationKind
var _ ipld.Node = &_RepresentationKind__Repr{}
type _RepresentationKind__ReprPrototype = _RepresentationKind__Prototype
type _RepresentationKind__ReprAssembler = _RepresentationKind__Assembler


func (n _Schema) FieldTypes() SchemaMap {
	return &n.types
}
type _Schema__Maybe struct {
	m schema.Maybe
	v Schema
}
type MaybeSchema = *_Schema__Maybe

func (m MaybeSchema) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSchema) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSchema) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSchema) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeSchema) Must() Schema {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__Schema_Types = _String{"types"}
)
var _ ipld.Node = (Schema)(&_Schema{})
var _ schema.TypedNode = (Schema)(&_Schema{})
func (Schema) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Schema) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "types":
		return &n.types, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Schema) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Schema) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Schema"}.LookupByIndex(0)
}
func (n Schema) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Schema) MapIterator() ipld.MapIterator {
	return &_Schema__MapItr{n, 0}
}

type _Schema__MapItr struct {
	n Schema
	idx  int
}

func (itr *_Schema__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Schema_Types
		v = &itr.n.types
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Schema__MapItr) Done() bool {
	return itr.idx >= 1
}

func (Schema) ListIterator() ipld.ListIterator {
	return nil
}
func (Schema) Length() int {
	return 1
}
func (Schema) IsAbsent() bool {
	return false
}
func (Schema) IsNull() bool {
	return false
}
func (Schema) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Schema"}.AsBool()
}
func (Schema) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Schema"}.AsInt()
}
func (Schema) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Schema"}.AsFloat()
}
func (Schema) AsString() (string, error) {
	return mixins.Map{"schemadmt.Schema"}.AsString()
}
func (Schema) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Schema"}.AsBytes()
}
func (Schema) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Schema"}.AsLink()
}
func (Schema) Prototype() ipld.NodePrototype {
	return _Schema__Prototype{}
}
type _Schema__Prototype struct{}

func (_Schema__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Schema__Builder
	nb.Reset()
	return &nb
}
type _Schema__Builder struct {
	_Schema__Assembler
}
func (nb *_Schema__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Schema__Builder) Reset() {
	var w _Schema
	var m schema.Maybe
	*nb = _Schema__Builder{_Schema__Assembler{w: &w, m: &m}}
}
type _Schema__Assembler struct {
	w *_Schema
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_types _SchemaMap__Assembler
	}

func (na *_Schema__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_types.reset()
}

var (
	fieldBit__Schema_Types = 1 << 0
	fieldBits__Schema_sufficient = 0 + 1 << 0
)
func (na *_Schema__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Schema{}
	}
	return na, nil
}
func (_Schema__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Schema"}.BeginList(0)
}
func (na *_Schema__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Schema"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Schema__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignBool(false)
}
func (_Schema__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignInt(0)
}
func (_Schema__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignFloat(0)
}
func (_Schema__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignString("")
}
func (_Schema__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignBytes(nil)
}
func (_Schema__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Schema"}.AssignLink(nil)
}
func (na *_Schema__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Schema); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Schema", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Schema__Assembler) Prototype() ipld.NodePrototype {
	return _Schema__Prototype{}
}
func (ma *_Schema__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_types.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Schema__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "types":
		if ma.s & fieldBit__Schema_Types != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Schema_Types}
		}
		ma.s += fieldBit__Schema_Types
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_types.w = &ma.w.types
		ma.ca_types.m = &ma.cm
		return &ma.ca_types, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.Schema", Key:&_String{k}}
	}
}
func (ma *_Schema__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Schema__KeyAssembler)(ma)
}
func (ma *_Schema__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_types.w = &ma.w.types
		ma.ca_types.m = &ma.cm
		return &ma.ca_types
	default:
		panic("unreachable")
	}
}
func (ma *_Schema__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Schema__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Schema__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _Schema__KeyAssembler _Schema__Assembler
func (_Schema__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.BeginMap(0)
}
func (_Schema__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.BeginList(0)
}
func (na *_Schema__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignNull()
}
func (_Schema__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignBool(false)
}
func (_Schema__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignInt(0)
}
func (_Schema__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Schema__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "types":
		if ka.s & fieldBit__Schema_Types != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Schema_Types}
		}
		ka.s += fieldBit__Schema_Types
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.Schema", Key:&_String{k}}
	}
	return nil
}
func (_Schema__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignBytes(nil)
}
func (_Schema__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.Schema.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Schema__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Schema__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Schema) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Schema) Representation() ipld.Node {
	return (*_Schema__Repr)(n)
}
type _Schema__Repr _Schema
var (
	fieldName__Schema_Types_serial = _String{"types"}
)
var _ ipld.Node = &_Schema__Repr{}
func (_Schema__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_Schema__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "types":
		return n.types.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Schema__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Schema__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.LookupByIndex(0)
}
func (n _Schema__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Schema__Repr) MapIterator() ipld.MapIterator {
	return &_Schema__ReprMapItr{n, 0}
}

type _Schema__ReprMapItr struct {
	n   *_Schema__Repr
	idx int
	
}

func (itr *_Schema__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Schema_Types_serial
		v = itr.n.types.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Schema__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_Schema__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Schema__Repr) Length() int {
	l := 1
	return l
}
func (_Schema__Repr) IsAbsent() bool {
	return false
}
func (_Schema__Repr) IsNull() bool {
	return false
}
func (_Schema__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsBool()
}
func (_Schema__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsInt()
}
func (_Schema__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsFloat()
}
func (_Schema__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsString()
}
func (_Schema__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsBytes()
}
func (_Schema__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Schema.Repr"}.AsLink()
}
func (_Schema__Repr) Prototype() ipld.NodePrototype {
	return _Schema__ReprPrototype{}
}
type _Schema__ReprPrototype struct{}

func (_Schema__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Schema__ReprBuilder
	nb.Reset()
	return &nb
}
type _Schema__ReprBuilder struct {
	_Schema__ReprAssembler
}
func (nb *_Schema__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Schema__ReprBuilder) Reset() {
	var w _Schema
	var m schema.Maybe
	*nb = _Schema__ReprBuilder{_Schema__ReprAssembler{w: &w, m: &m}}
}
type _Schema__ReprAssembler struct {
	w *_Schema
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_types _SchemaMap__ReprAssembler
	}

func (na *_Schema__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_types.reset()
}
func (na *_Schema__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Schema{}
	}
	return na, nil
}
func (_Schema__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.BeginList(0)
}
func (na *_Schema__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Schema.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Schema__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignBool(false)
}
func (_Schema__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignInt(0)
}
func (_Schema__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignFloat(0)
}
func (_Schema__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignString("")
}
func (_Schema__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignBytes(nil)
}
func (_Schema__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Schema.Repr"}.AssignLink(nil)
}
func (na *_Schema__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Schema); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Schema.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Schema__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Schema__ReprPrototype{}
}
func (ma *_Schema__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Schema__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "types":
		if ma.s & fieldBit__Schema_Types != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Schema_Types_serial}
		}
		ma.s += fieldBit__Schema_Types
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_types.w = &ma.w.types
		ma.ca_types.m = &ma.cm
		return &ma.ca_types, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.Schema.Repr", Key:&_String{k}}
	}
}
func (ma *_Schema__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Schema__ReprKeyAssembler)(ma)
}
func (ma *_Schema__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_types.w = &ma.w.types
		ma.ca_types.m = &ma.cm
		return &ma.ca_types
	default:
		panic("unreachable")
	}
}
func (ma *_Schema__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Schema__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Schema__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _Schema__ReprKeyAssembler _Schema__ReprAssembler
func (_Schema__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Schema__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Schema__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignNull()
}
func (_Schema__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Schema__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Schema__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Schema__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "types":
		if ka.s & fieldBit__Schema_Types != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Schema_Types_serial}
		}
		ka.s += fieldBit__Schema_Types
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.Schema.Repr", Key:&_String{k}}
	}
	return nil
}
func (_Schema__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Schema__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.Schema.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Schema__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Schema__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_SchemaMap) Lookup(k TypeName) TypeDefn {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_SchemaMap) LookupMaybe(k TypeName) MaybeTypeDefn {
	v, exists := n.m[*k]
	if !exists {
		return &_SchemaMap__valueAbsent
	}
	return &_TypeDefn__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _SchemaMap__valueAbsent = _TypeDefn__Maybe{m:schema.Maybe_Absent}
func (n SchemaMap) Iterator() *SchemaMap__Itr {
	return &SchemaMap__Itr{n, 0}
}

type SchemaMap__Itr struct {
	n SchemaMap
	idx  int
}

func (itr *SchemaMap__Itr) Next() (k TypeName, v TypeDefn) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *SchemaMap__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _SchemaMap__Maybe struct {
	m schema.Maybe
	v SchemaMap
}
type MaybeSchemaMap = *_SchemaMap__Maybe

func (m MaybeSchemaMap) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSchemaMap) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSchemaMap) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSchemaMap) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeSchemaMap) Must() SchemaMap {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (SchemaMap)(&_SchemaMap{})
var _ schema.TypedNode = (SchemaMap)(&_SchemaMap{})
func (SchemaMap) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n SchemaMap) LookupByString(k string) (ipld.Node, error) {
	var k2 _TypeName
	if err := (_TypeName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n SchemaMap) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(TypeName)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.SchemaMap", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (SchemaMap) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.LookupByIndex(0)
}
func (n SchemaMap) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SchemaMap) MapIterator() ipld.MapIterator {
	return &_SchemaMap__MapItr{n, 0}
}

type _SchemaMap__MapItr struct {
	n SchemaMap
	idx  int
}

func (itr *_SchemaMap__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_SchemaMap__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (SchemaMap) ListIterator() ipld.ListIterator {
	return nil
}
func (n SchemaMap) Length() int {
	return len(n.t)
}
func (SchemaMap) IsAbsent() bool {
	return false
}
func (SchemaMap) IsNull() bool {
	return false
}
func (SchemaMap) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsBool()
}
func (SchemaMap) AsInt() (int, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsInt()
}
func (SchemaMap) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsFloat()
}
func (SchemaMap) AsString() (string, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsString()
}
func (SchemaMap) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsBytes()
}
func (SchemaMap) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.SchemaMap"}.AsLink()
}
func (SchemaMap) Prototype() ipld.NodePrototype {
	return _SchemaMap__Prototype{}
}
type _SchemaMap__Prototype struct{}

func (_SchemaMap__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SchemaMap__Builder
	nb.Reset()
	return &nb
}
type _SchemaMap__Builder struct {
	_SchemaMap__Assembler
}
func (nb *_SchemaMap__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SchemaMap__Builder) Reset() {
	var w _SchemaMap
	var m schema.Maybe
	*nb = _SchemaMap__Builder{_SchemaMap__Assembler{w: &w, m: &m}}
}
type _SchemaMap__Assembler struct {
	w *_SchemaMap
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _TypeName__Assembler
	va _TypeDefn__Assembler
}

func (na *_SchemaMap__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_SchemaMap__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_SchemaMap{}
	}
	na.w.m = make(map[_TypeName]*_TypeDefn, sizeHint)
	na.w.t = make([]_SchemaMap__entry, 0, sizeHint)
	return na, nil
}
func (_SchemaMap__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.BeginList(0)
}
func (na *_SchemaMap__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SchemaMap__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignBool(false)
}
func (_SchemaMap__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignInt(0)
}
func (_SchemaMap__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignFloat(0)
}
func (_SchemaMap__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignString("")
}
func (_SchemaMap__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignBytes(nil)
}
func (_SchemaMap__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap"}.AssignLink(nil)
}
func (na *_SchemaMap__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SchemaMap); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.SchemaMap", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SchemaMap__Assembler) Prototype() ipld.NodePrototype {
	return _SchemaMap__Prototype{}
}
func (ma *_SchemaMap__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_SchemaMap__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_SchemaMap__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _TypeName
	if err := (_TypeName__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _SchemaMap__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_SchemaMap__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _SchemaMap__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_SchemaMap__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_SchemaMap__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SchemaMap__Assembler) KeyPrototype() ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (ma *_SchemaMap__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeDefn__Prototype{}
}
func (SchemaMap) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SchemaMap) Representation() ipld.Node {
	return (*_SchemaMap__Repr)(n)
}
type _SchemaMap__Repr _SchemaMap
var _ ipld.Node = &_SchemaMap__Repr{}
func (_SchemaMap__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_SchemaMap__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (SchemaMap)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeDefn).Representation(), nil
}
func (nr *_SchemaMap__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (SchemaMap)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeDefn).Representation(), nil
}
func (_SchemaMap__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.LookupByIndex(0)
}
func (n _SchemaMap__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_SchemaMap__Repr) MapIterator() ipld.MapIterator {
	return &_SchemaMap__ReprMapItr{(SchemaMap)(nr), 0}
}

type _SchemaMap__ReprMapItr _SchemaMap__MapItr

func (itr *_SchemaMap__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_SchemaMap__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(TypeDefn).Representation(), nil
}
func (itr *_SchemaMap__ReprMapItr) Done() bool {
	return (*_SchemaMap__MapItr)(itr).Done()
}

func (_SchemaMap__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SchemaMap__Repr) Length() int {
	return len(rn.t)
}
func (_SchemaMap__Repr) IsAbsent() bool {
	return false
}
func (_SchemaMap__Repr) IsNull() bool {
	return false
}
func (_SchemaMap__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsBool()
}
func (_SchemaMap__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsInt()
}
func (_SchemaMap__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsFloat()
}
func (_SchemaMap__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsString()
}
func (_SchemaMap__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsBytes()
}
func (_SchemaMap__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.SchemaMap.Repr"}.AsLink()
}
func (_SchemaMap__Repr) Prototype() ipld.NodePrototype {
	return _SchemaMap__ReprPrototype{}
}
type _SchemaMap__ReprPrototype struct{}

func (_SchemaMap__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SchemaMap__ReprBuilder
	nb.Reset()
	return &nb
}
type _SchemaMap__ReprBuilder struct {
	_SchemaMap__ReprAssembler
}
func (nb *_SchemaMap__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SchemaMap__ReprBuilder) Reset() {
	var w _SchemaMap
	var m schema.Maybe
	*nb = _SchemaMap__ReprBuilder{_SchemaMap__ReprAssembler{w: &w, m: &m}}
}
type _SchemaMap__ReprAssembler struct {
	w *_SchemaMap
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _TypeName__ReprAssembler
	va _TypeDefn__ReprAssembler
}

func (na *_SchemaMap__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_SchemaMap__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_SchemaMap{}
	}
	na.w.m = make(map[_TypeName]*_TypeDefn, sizeHint)
	na.w.t = make([]_SchemaMap__entry, 0, sizeHint)
	return na, nil
}
func (_SchemaMap__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.BeginList(0)
}
func (na *_SchemaMap__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.SchemaMap.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SchemaMap__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignBool(false)
}
func (_SchemaMap__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignInt(0)
}
func (_SchemaMap__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignFloat(0)
}
func (_SchemaMap__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignString("")
}
func (_SchemaMap__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignBytes(nil)
}
func (_SchemaMap__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.SchemaMap.Repr"}.AssignLink(nil)
}
func (na *_SchemaMap__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SchemaMap); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.SchemaMap.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SchemaMap__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SchemaMap__ReprPrototype{}
}
func (ma *_SchemaMap__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_SchemaMap__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_SchemaMap__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _TypeName
	if err := (_TypeName__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _SchemaMap__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_SchemaMap__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _SchemaMap__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_SchemaMap__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_SchemaMap__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SchemaMap__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _TypeName__ReprPrototype{}
}
func (ma *_SchemaMap__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeDefn__ReprPrototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}
type _String__Maybe struct {
	m schema.Maybe
	v String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})
func (String) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"schemadmt.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"schemadmt.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.String{"schemadmt.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"schemadmt.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{"schemadmt.String"}.AsBool()
}
func (String) AsInt() (int, error) {
	return mixins.String{"schemadmt.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{"schemadmt.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{"schemadmt.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{"schemadmt.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}
type _String__Builder struct {
	_String__Assembler
}
func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}
type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"schemadmt.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_String{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}
type _String__Repr = _String
var _ ipld.Node = &_String__Repr{}
type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler


func (n _StructField) FieldType() TypeNameOrInlineDefn {
	return &n.typ
}
func (n _StructField) FieldOptional() Bool {
	return &n.optional
}
func (n _StructField) FieldNullable() Bool {
	return &n.nullable
}
type _StructField__Maybe struct {
	m schema.Maybe
	v StructField
}
type MaybeStructField = *_StructField__Maybe

func (m MaybeStructField) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructField) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructField) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructField) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructField) Must() StructField {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructField_Type = _String{"type"}
	fieldName__StructField_Optional = _String{"optional"}
	fieldName__StructField_Nullable = _String{"nullable"}
)
var _ ipld.Node = (StructField)(&_StructField{})
var _ schema.TypedNode = (StructField)(&_StructField{})
func (StructField) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructField) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "type":
		return &n.typ, nil
	case "optional":
		return &n.optional, nil
	case "nullable":
		return &n.nullable, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructField) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructField) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructField"}.LookupByIndex(0)
}
func (n StructField) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructField) MapIterator() ipld.MapIterator {
	return &_StructField__MapItr{n, 0}
}

type _StructField__MapItr struct {
	n StructField
	idx  int
}

func (itr *_StructField__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructField_Type
		v = &itr.n.typ
	case 1:
		k = &fieldName__StructField_Optional
		v = &itr.n.optional
	case 2:
		k = &fieldName__StructField_Nullable
		v = &itr.n.nullable
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructField__MapItr) Done() bool {
	return itr.idx >= 3
}

func (StructField) ListIterator() ipld.ListIterator {
	return nil
}
func (StructField) Length() int {
	return 3
}
func (StructField) IsAbsent() bool {
	return false
}
func (StructField) IsNull() bool {
	return false
}
func (StructField) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructField"}.AsBool()
}
func (StructField) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructField"}.AsInt()
}
func (StructField) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructField"}.AsFloat()
}
func (StructField) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructField"}.AsString()
}
func (StructField) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructField"}.AsBytes()
}
func (StructField) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructField"}.AsLink()
}
func (StructField) Prototype() ipld.NodePrototype {
	return _StructField__Prototype{}
}
type _StructField__Prototype struct{}

func (_StructField__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructField__Builder
	nb.Reset()
	return &nb
}
type _StructField__Builder struct {
	_StructField__Assembler
}
func (nb *_StructField__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructField__Builder) Reset() {
	var w _StructField
	var m schema.Maybe
	*nb = _StructField__Builder{_StructField__Assembler{w: &w, m: &m}}
}
type _StructField__Assembler struct {
	w *_StructField
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_typ _TypeNameOrInlineDefn__Assembler
	ca_optional _Bool__Assembler
	ca_nullable _Bool__Assembler
	}

func (na *_StructField__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_typ.reset()
	na.ca_optional.reset()
	na.ca_nullable.reset()
}

var (
	fieldBit__StructField_Type = 1 << 0
	fieldBit__StructField_Optional = 1 << 1
	fieldBit__StructField_Nullable = 1 << 2
	fieldBits__StructField_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2
)
func (na *_StructField__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructField{}
	}
	return na, nil
}
func (_StructField__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructField"}.BeginList(0)
}
func (na *_StructField__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructField"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructField__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignBool(false)
}
func (_StructField__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignInt(0)
}
func (_StructField__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignFloat(0)
}
func (_StructField__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignString("")
}
func (_StructField__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignBytes(nil)
}
func (_StructField__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructField"}.AssignLink(nil)
}
func (na *_StructField__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructField); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructField", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructField__Assembler) Prototype() ipld.NodePrototype {
	return _StructField__Prototype{}
}
func (ma *_StructField__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_typ.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_optional.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_nullable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructField__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "type":
		if ma.s & fieldBit__StructField_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Type}
		}
		ma.s += fieldBit__StructField_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_typ.w = &ma.w.typ
		ma.ca_typ.m = &ma.cm
		return &ma.ca_typ, nil
	case "optional":
		if ma.s & fieldBit__StructField_Optional != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Optional}
		}
		ma.s += fieldBit__StructField_Optional
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_optional.w = &ma.w.optional
		ma.ca_optional.m = &ma.cm
		return &ma.ca_optional, nil
	case "nullable":
		if ma.s & fieldBit__StructField_Nullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Nullable}
		}
		ma.s += fieldBit__StructField_Nullable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_nullable.w = &ma.w.nullable
		ma.ca_nullable.m = &ma.cm
		return &ma.ca_nullable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructField", Key:&_String{k}}
	}
}
func (ma *_StructField__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructField__KeyAssembler)(ma)
}
func (ma *_StructField__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_typ.w = &ma.w.typ
		ma.ca_typ.m = &ma.cm
		return &ma.ca_typ
	case 1:
		ma.ca_optional.w = &ma.w.optional
		ma.ca_optional.m = &ma.cm
		return &ma.ca_optional
	case 2:
		ma.ca_nullable.w = &ma.w.nullable
		ma.ca_nullable.m = &ma.cm
		return &ma.ca_nullable
	default:
		panic("unreachable")
	}
}
func (ma *_StructField__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructField__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructField__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructField__KeyAssembler _StructField__Assembler
func (_StructField__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.BeginMap(0)
}
func (_StructField__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.BeginList(0)
}
func (na *_StructField__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignNull()
}
func (_StructField__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignBool(false)
}
func (_StructField__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignInt(0)
}
func (_StructField__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructField__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "type":
		if ka.s & fieldBit__StructField_Type != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Type}
		}
		ka.s += fieldBit__StructField_Type
		ka.state = maState_expectValue
		ka.f = 0
	case "optional":
		if ka.s & fieldBit__StructField_Optional != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Optional}
		}
		ka.s += fieldBit__StructField_Optional
		ka.state = maState_expectValue
		ka.f = 1
	case "nullable":
		if ka.s & fieldBit__StructField_Nullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Nullable}
		}
		ka.s += fieldBit__StructField_Nullable
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructField", Key:&_String{k}}
	}
	return nil
}
func (_StructField__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignBytes(nil)
}
func (_StructField__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructField.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructField__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructField__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructField) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructField) Representation() ipld.Node {
	return (*_StructField__Repr)(n)
}
type _StructField__Repr _StructField
var (
	fieldName__StructField_Type_serial = _String{"type"}
	fieldName__StructField_Optional_serial = _String{"optional"}
	fieldName__StructField_Nullable_serial = _String{"nullable"}
)
var _ ipld.Node = &_StructField__Repr{}
func (_StructField__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructField__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "type":
		return n.typ.Representation(), nil
	case "optional":
		return n.optional.Representation(), nil
	case "nullable":
		return n.nullable.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructField__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructField__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.LookupByIndex(0)
}
func (n _StructField__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructField__Repr) MapIterator() ipld.MapIterator {
	return &_StructField__ReprMapItr{n, 0}
}

type _StructField__ReprMapItr struct {
	n   *_StructField__Repr
	idx int
	
}

func (itr *_StructField__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructField_Type_serial
		v = itr.n.typ.Representation()
	case 1:
		k = &fieldName__StructField_Optional_serial
		v = itr.n.optional.Representation()
	case 2:
		k = &fieldName__StructField_Nullable_serial
		v = itr.n.nullable.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructField__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_StructField__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructField__Repr) Length() int {
	l := 3
	return l
}
func (_StructField__Repr) IsAbsent() bool {
	return false
}
func (_StructField__Repr) IsNull() bool {
	return false
}
func (_StructField__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsBool()
}
func (_StructField__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsInt()
}
func (_StructField__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsFloat()
}
func (_StructField__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsString()
}
func (_StructField__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsBytes()
}
func (_StructField__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructField.Repr"}.AsLink()
}
func (_StructField__Repr) Prototype() ipld.NodePrototype {
	return _StructField__ReprPrototype{}
}
type _StructField__ReprPrototype struct{}

func (_StructField__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructField__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructField__ReprBuilder struct {
	_StructField__ReprAssembler
}
func (nb *_StructField__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructField__ReprBuilder) Reset() {
	var w _StructField
	var m schema.Maybe
	*nb = _StructField__ReprBuilder{_StructField__ReprAssembler{w: &w, m: &m}}
}
type _StructField__ReprAssembler struct {
	w *_StructField
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_typ _TypeNameOrInlineDefn__ReprAssembler
	ca_optional _Bool__ReprAssembler
	ca_nullable _Bool__ReprAssembler
	}

func (na *_StructField__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_typ.reset()
	na.ca_optional.reset()
	na.ca_nullable.reset()
}
func (na *_StructField__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructField{}
	}
	return na, nil
}
func (_StructField__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.BeginList(0)
}
func (na *_StructField__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructField.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructField__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignBool(false)
}
func (_StructField__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignInt(0)
}
func (_StructField__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignFloat(0)
}
func (_StructField__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignString("")
}
func (_StructField__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignBytes(nil)
}
func (_StructField__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructField.Repr"}.AssignLink(nil)
}
func (na *_StructField__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructField); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructField.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructField__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructField__ReprPrototype{}
}
func (ma *_StructField__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructField__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "type":
		if ma.s & fieldBit__StructField_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Type_serial}
		}
		ma.s += fieldBit__StructField_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_typ.w = &ma.w.typ
		ma.ca_typ.m = &ma.cm
		return &ma.ca_typ, nil
	case "optional":
		if ma.s & fieldBit__StructField_Optional != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Optional_serial}
		}
		ma.s += fieldBit__StructField_Optional
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_optional.w = &ma.w.optional
		ma.ca_optional.m = &ma.cm
		return &ma.ca_optional, nil
	case "nullable":
		if ma.s & fieldBit__StructField_Nullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructField_Nullable_serial}
		}
		ma.s += fieldBit__StructField_Nullable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_nullable.w = &ma.w.nullable
		ma.ca_nullable.m = &ma.cm
		return &ma.ca_nullable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructField.Repr", Key:&_String{k}}
	}
}
func (ma *_StructField__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructField__ReprKeyAssembler)(ma)
}
func (ma *_StructField__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_typ.w = &ma.w.typ
		ma.ca_typ.m = &ma.cm
		return &ma.ca_typ
	case 1:
		ma.ca_optional.w = &ma.w.optional
		ma.ca_optional.m = &ma.cm
		return &ma.ca_optional
	case 2:
		ma.ca_nullable.w = &ma.w.nullable
		ma.ca_nullable.m = &ma.cm
		return &ma.ca_nullable
	default:
		panic("unreachable")
	}
}
func (ma *_StructField__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructField__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructField__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructField__ReprKeyAssembler _StructField__ReprAssembler
func (_StructField__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructField__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructField__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignNull()
}
func (_StructField__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructField__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructField__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructField__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "type":
		if ka.s & fieldBit__StructField_Type != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Type_serial}
		}
		ka.s += fieldBit__StructField_Type
		ka.state = maState_expectValue
		ka.f = 0
	case "optional":
		if ka.s & fieldBit__StructField_Optional != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Optional_serial}
		}
		ka.s += fieldBit__StructField_Optional
		ka.state = maState_expectValue
		ka.f = 1
	case "nullable":
		if ka.s & fieldBit__StructField_Nullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructField_Nullable_serial}
		}
		ka.s += fieldBit__StructField_Nullable
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructField.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructField__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructField__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructField.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructField__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructField__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _StructRepresentation) AsInterface() _StructRepresentation__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _StructRepresentation__Maybe struct {
	m schema.Maybe
	v StructRepresentation
}
type MaybeStructRepresentation = *_StructRepresentation__Maybe

func (m MaybeStructRepresentation) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation) Must() StructRepresentation {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__StructRepresentation_StructRepresentation_Map = _String{"StructRepresentation_Map"}
	memberName__StructRepresentation_StructRepresentation_Tuple = _String{"StructRepresentation_Tuple"}
	memberName__StructRepresentation_StructRepresentation_Stringpairs = _String{"StructRepresentation_Stringpairs"}
	memberName__StructRepresentation_StructRepresentation_Stringjoin = _String{"StructRepresentation_Stringjoin"}
	memberName__StructRepresentation_StructRepresentation_Listpairs = _String{"StructRepresentation_Listpairs"}
)
var _ ipld.Node = (StructRepresentation)(&_StructRepresentation{})
var _ schema.TypedNode = (StructRepresentation)(&_StructRepresentation{})
func (StructRepresentation) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "StructRepresentation_Map":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "StructRepresentation_Tuple":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "StructRepresentation_Stringpairs":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "StructRepresentation_Stringjoin":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "StructRepresentation_Listpairs":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.LookupByIndex(0)
}
func (n StructRepresentation) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation) MapIterator() ipld.MapIterator {
	return &_StructRepresentation__MapItr{n, false}
}

type _StructRepresentation__MapItr struct {
	n StructRepresentation
	done bool
}

func (itr *_StructRepresentation__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__StructRepresentation_StructRepresentation_Map, &itr.n.x1
	case 2:
		k, v = &memberName__StructRepresentation_StructRepresentation_Tuple, &itr.n.x2
	case 3:
		k, v = &memberName__StructRepresentation_StructRepresentation_Stringpairs, &itr.n.x3
	case 4:
		k, v = &memberName__StructRepresentation_StructRepresentation_Stringjoin, &itr.n.x4
	case 5:
		k, v = &memberName__StructRepresentation_StructRepresentation_Listpairs, &itr.n.x5
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_StructRepresentation__MapItr) Done() bool {
	return itr.done
}

func (StructRepresentation) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation) Length() int {
	return 1
}
func (StructRepresentation) IsAbsent() bool {
	return false
}
func (StructRepresentation) IsNull() bool {
	return false
}
func (StructRepresentation) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsBool()
}
func (StructRepresentation) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsInt()
}
func (StructRepresentation) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsFloat()
}
func (StructRepresentation) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsString()
}
func (StructRepresentation) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsBytes()
}
func (StructRepresentation) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation"}.AsLink()
}
func (StructRepresentation) Prototype() ipld.NodePrototype {
	return _StructRepresentation__Prototype{}
}
type _StructRepresentation__Prototype struct{}

func (_StructRepresentation__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation__Builder struct {
	_StructRepresentation__Assembler
}
func (nb *_StructRepresentation__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation__Builder) Reset() {
	var w _StructRepresentation
	var m schema.Maybe
	*nb = _StructRepresentation__Builder{_StructRepresentation__Assembler{w: &w, m: &m}}
}
type _StructRepresentation__Assembler struct {
	w *_StructRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _StructRepresentation_Map__Assembler
	
	ca2 _StructRepresentation_Tuple__Assembler
	
	ca3 _StructRepresentation_Stringpairs__Assembler
	
	ca4 _StructRepresentation_Stringjoin__Assembler
	
	ca5 _StructRepresentation_Listpairs__Assembler
	ca uint
}
func (na *_StructRepresentation__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_StructRepresentation__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation{}
	}
	return na, nil
}
func (_StructRepresentation__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.BeginList(0)
}
func (na *_StructRepresentation__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignBool(false)
}
func (_StructRepresentation__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignInt(0)
}
func (_StructRepresentation__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignFloat(0)
}
func (_StructRepresentation__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignString("")
}
func (_StructRepresentation__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignBytes(nil)
}
func (_StructRepresentation__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation"}.AssignLink(nil)
}
func (na *_StructRepresentation__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation__Prototype{}
}
func (ma *_StructRepresentation__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_StructRepresentation__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "StructRepresentation_Map":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "StructRepresentation_Tuple":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "StructRepresentation_Stringpairs":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "StructRepresentation_Stringjoin":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "StructRepresentation_Listpairs":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation__KeyAssembler)(ma)
}
func (ma *_StructRepresentation__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "StructRepresentation_Map":
		return _StructRepresentation_Map__Prototype{}
	case "StructRepresentation_Tuple":
		return _StructRepresentation_Tuple__Prototype{}
	case "StructRepresentation_Stringpairs":
		return _StructRepresentation_Stringpairs__Prototype{}
	case "StructRepresentation_Stringjoin":
		return _StructRepresentation_Stringjoin__Prototype{}
	case "StructRepresentation_Listpairs":
		return _StructRepresentation_Listpairs__Prototype{}
	default:
		return nil
	}
}
type _StructRepresentation__KeyAssembler _StructRepresentation__Assembler
func (_StructRepresentation__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "StructRepresentation_Map":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "StructRepresentation_Tuple":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "StructRepresentation_Stringpairs":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "StructRepresentation_Stringjoin":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "StructRepresentation_Listpairs":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_StructRepresentation__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation) Representation() ipld.Node {
	return (*_StructRepresentation__Repr)(n)
}
type _StructRepresentation__Repr _StructRepresentation
var (
	memberName__StructRepresentation_StructRepresentation_Map_serial = _String{"map"}
	memberName__StructRepresentation_StructRepresentation_Tuple_serial = _String{"tuple"}
	memberName__StructRepresentation_StructRepresentation_Stringpairs_serial = _String{"stringpairs"}
	memberName__StructRepresentation_StructRepresentation_Stringjoin_serial = _String{"stringjoin"}
	memberName__StructRepresentation_StructRepresentation_Listpairs_serial = _String{"listpairs"}
)
var _ ipld.Node = &_StructRepresentation__Repr{}
func (_StructRepresentation__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "map":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "tuple":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "stringpairs":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "stringjoin":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	case "listpairs":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x5.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation__Repr) MapIterator() ipld.MapIterator {
	return &_StructRepresentation__ReprMapItr{n, false}
}

type _StructRepresentation__ReprMapItr struct {
	n *_StructRepresentation__Repr
	done bool
}

func (itr *_StructRepresentation__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__StructRepresentation_StructRepresentation_Map_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__StructRepresentation_StructRepresentation_Tuple_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__StructRepresentation_StructRepresentation_Stringpairs_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__StructRepresentation_StructRepresentation_Stringjoin_serial, itr.n.x4.Representation()
	case 5:
		k, v = &memberName__StructRepresentation_StructRepresentation_Listpairs_serial, itr.n.x5.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_StructRepresentation__ReprMapItr) Done() bool {
	return itr.done
}

func (_StructRepresentation__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_StructRepresentation__Repr) Length() int {
	return 1
}
func (_StructRepresentation__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsBool()
}
func (_StructRepresentation__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsInt()
}
func (_StructRepresentation__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsFloat()
}
func (_StructRepresentation__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsString()
}
func (_StructRepresentation__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsBytes()
}
func (_StructRepresentation__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation.Repr"}.AsLink()
}
func (_StructRepresentation__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation__ReprPrototype{}
}
type _StructRepresentation__ReprPrototype struct{}

func (_StructRepresentation__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation__ReprBuilder struct {
	_StructRepresentation__ReprAssembler
}
func (nb *_StructRepresentation__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation__ReprBuilder) Reset() {
	var w _StructRepresentation
	var m schema.Maybe
	*nb = _StructRepresentation__ReprBuilder{_StructRepresentation__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation__ReprAssembler struct {
	w *_StructRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _StructRepresentation_Map__ReprAssembler
	
	ca2 _StructRepresentation_Tuple__ReprAssembler
	
	ca3 _StructRepresentation_Stringpairs__ReprAssembler
	
	ca4 _StructRepresentation_Stringjoin__ReprAssembler
	
	ca5 _StructRepresentation_Listpairs__ReprAssembler
	ca uint
}
func (na *_StructRepresentation__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_StructRepresentation__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation{}
	}
	return na, nil
}
func (_StructRepresentation__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.BeginList(0)
}
func (na *_StructRepresentation__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignBool(false)
}
func (_StructRepresentation__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignInt(0)
}
func (_StructRepresentation__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignFloat(0)
}
func (_StructRepresentation__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignString("")
}
func (_StructRepresentation__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation__ReprPrototype{}
}
func (ma *_StructRepresentation__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_StructRepresentation__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "tuple":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "stringpairs":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "stringjoin":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "listpairs":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "StructRepresentation_Map":
		return _StructRepresentation_Map__ReprPrototype{}
	case "StructRepresentation_Tuple":
		return _StructRepresentation_Tuple__ReprPrototype{}
	case "StructRepresentation_Stringpairs":
		return _StructRepresentation_Stringpairs__ReprPrototype{}
	case "StructRepresentation_Stringjoin":
		return _StructRepresentation_Stringjoin__ReprPrototype{}
	case "StructRepresentation_Listpairs":
		return _StructRepresentation_Listpairs__ReprPrototype{}
	default:
		return nil
	}
}
type _StructRepresentation__ReprKeyAssembler _StructRepresentation__ReprAssembler
func (_StructRepresentation__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.StructRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "tuple":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "stringpairs":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "stringjoin":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "listpairs":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_StructRepresentation__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _StructRepresentation_Listpairs__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Listpairs
}
type MaybeStructRepresentation_Listpairs = *_StructRepresentation_Listpairs__Maybe

func (m MaybeStructRepresentation_Listpairs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Listpairs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Listpairs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Listpairs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Listpairs) Must() StructRepresentation_Listpairs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (StructRepresentation_Listpairs)(&_StructRepresentation_Listpairs{})
var _ schema.TypedNode = (StructRepresentation_Listpairs)(&_StructRepresentation_Listpairs{})
func (StructRepresentation_Listpairs) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Listpairs) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Listpairs) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Listpairs) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.LookupByIndex(0)
}
func (n StructRepresentation_Listpairs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Listpairs) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Listpairs__MapItr{n, 0}
}

type _StructRepresentation_Listpairs__MapItr struct {
	n StructRepresentation_Listpairs
	idx  int
}

func (itr *_StructRepresentation_Listpairs__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Listpairs__MapItr) Done() bool {
	return itr.idx >= 0
}

func (StructRepresentation_Listpairs) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Listpairs) Length() int {
	return 0
}
func (StructRepresentation_Listpairs) IsAbsent() bool {
	return false
}
func (StructRepresentation_Listpairs) IsNull() bool {
	return false
}
func (StructRepresentation_Listpairs) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsBool()
}
func (StructRepresentation_Listpairs) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsInt()
}
func (StructRepresentation_Listpairs) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsFloat()
}
func (StructRepresentation_Listpairs) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsString()
}
func (StructRepresentation_Listpairs) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsBytes()
}
func (StructRepresentation_Listpairs) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs"}.AsLink()
}
func (StructRepresentation_Listpairs) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Listpairs__Prototype{}
}
type _StructRepresentation_Listpairs__Prototype struct{}

func (_StructRepresentation_Listpairs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Listpairs__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Listpairs__Builder struct {
	_StructRepresentation_Listpairs__Assembler
}
func (nb *_StructRepresentation_Listpairs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Listpairs__Builder) Reset() {
	var w _StructRepresentation_Listpairs
	var m schema.Maybe
	*nb = _StructRepresentation_Listpairs__Builder{_StructRepresentation_Listpairs__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Listpairs__Assembler struct {
	w *_StructRepresentation_Listpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_StructRepresentation_Listpairs__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__StructRepresentation_Listpairs_sufficient = 0
)
func (na *_StructRepresentation_Listpairs__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Listpairs{}
	}
	return na, nil
}
func (_StructRepresentation_Listpairs__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.BeginList(0)
}
func (na *_StructRepresentation_Listpairs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Listpairs__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignBool(false)
}
func (_StructRepresentation_Listpairs__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignInt(0)
}
func (_StructRepresentation_Listpairs__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignFloat(0)
}
func (_StructRepresentation_Listpairs__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignString("")
}
func (_StructRepresentation_Listpairs__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignBytes(nil)
}
func (_StructRepresentation_Listpairs__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs"}.AssignLink(nil)
}
func (na *_StructRepresentation_Listpairs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Listpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Listpairs", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Listpairs__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Listpairs__Prototype{}
}
func (ma *_StructRepresentation_Listpairs__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Listpairs__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Listpairs", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Listpairs__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Listpairs__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Listpairs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Listpairs__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Listpairs__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Listpairs__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Listpairs__KeyAssembler _StructRepresentation_Listpairs__Assembler
func (_StructRepresentation_Listpairs__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Listpairs__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Listpairs__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Listpairs__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Listpairs__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Listpairs__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Listpairs__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Listpairs", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Listpairs__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Listpairs__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Listpairs__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Listpairs__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Listpairs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Listpairs) Representation() ipld.Node {
	return (*_StructRepresentation_Listpairs__Repr)(n)
}
type _StructRepresentation_Listpairs__Repr _StructRepresentation_Listpairs
var (
)
var _ ipld.Node = &_StructRepresentation_Listpairs__Repr{}
func (_StructRepresentation_Listpairs__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Listpairs__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Listpairs__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Listpairs__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Listpairs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Listpairs__Repr) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Listpairs__ReprMapItr{n, 0}
}

type _StructRepresentation_Listpairs__ReprMapItr struct {
	n   *_StructRepresentation_Listpairs__Repr
	idx int
	
}

func (itr *_StructRepresentation_Listpairs__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Listpairs__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_StructRepresentation_Listpairs__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Listpairs__Repr) Length() int {
	l := 0
	return l
}
func (_StructRepresentation_Listpairs__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Listpairs__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Listpairs__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsBool()
}
func (_StructRepresentation_Listpairs__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsInt()
}
func (_StructRepresentation_Listpairs__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsFloat()
}
func (_StructRepresentation_Listpairs__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsString()
}
func (_StructRepresentation_Listpairs__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsBytes()
}
func (_StructRepresentation_Listpairs__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Listpairs.Repr"}.AsLink()
}
func (_StructRepresentation_Listpairs__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Listpairs__ReprPrototype{}
}
type _StructRepresentation_Listpairs__ReprPrototype struct{}

func (_StructRepresentation_Listpairs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Listpairs__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Listpairs__ReprBuilder struct {
	_StructRepresentation_Listpairs__ReprAssembler
}
func (nb *_StructRepresentation_Listpairs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Listpairs__ReprBuilder) Reset() {
	var w _StructRepresentation_Listpairs
	var m schema.Maybe
	*nb = _StructRepresentation_Listpairs__ReprBuilder{_StructRepresentation_Listpairs__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Listpairs__ReprAssembler struct {
	w *_StructRepresentation_Listpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_StructRepresentation_Listpairs__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_StructRepresentation_Listpairs__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Listpairs{}
	}
	return na, nil
}
func (_StructRepresentation_Listpairs__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Listpairs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignString("")
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Listpairs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Listpairs.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Listpairs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Listpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Listpairs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Listpairs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Listpairs__ReprPrototype{}
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Listpairs.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Listpairs__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Listpairs__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Listpairs__ReprKeyAssembler _StructRepresentation_Listpairs__ReprAssembler
func (_StructRepresentation_Listpairs__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Listpairs__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Listpairs__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Listpairs.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Listpairs.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Listpairs__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Listpairs__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StructRepresentation_Map) FieldFields() MaybeMap__FieldName__StructRepresentation_Map_FieldDetails {
	return &n.fields
}
type _StructRepresentation_Map__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Map
}
type MaybeStructRepresentation_Map = *_StructRepresentation_Map__Maybe

func (m MaybeStructRepresentation_Map) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Map) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Map) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Map) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Map) Must() StructRepresentation_Map {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructRepresentation_Map_Fields = _String{"fields"}
)
var _ ipld.Node = (StructRepresentation_Map)(&_StructRepresentation_Map{})
var _ schema.TypedNode = (StructRepresentation_Map)(&_StructRepresentation_Map{})
func (StructRepresentation_Map) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Map) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fields":
		if n.fields.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.fields.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Map) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Map) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.LookupByIndex(0)
}
func (n StructRepresentation_Map) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Map) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Map__MapItr{n, 0}
}

type _StructRepresentation_Map__MapItr struct {
	n StructRepresentation_Map
	idx  int
}

func (itr *_StructRepresentation_Map__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Map_Fields
		if itr.n.fields.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.fields.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Map__MapItr) Done() bool {
	return itr.idx >= 1
}

func (StructRepresentation_Map) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Map) Length() int {
	return 1
}
func (StructRepresentation_Map) IsAbsent() bool {
	return false
}
func (StructRepresentation_Map) IsNull() bool {
	return false
}
func (StructRepresentation_Map) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsBool()
}
func (StructRepresentation_Map) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsInt()
}
func (StructRepresentation_Map) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsFloat()
}
func (StructRepresentation_Map) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsString()
}
func (StructRepresentation_Map) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsBytes()
}
func (StructRepresentation_Map) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map"}.AsLink()
}
func (StructRepresentation_Map) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map__Prototype{}
}
type _StructRepresentation_Map__Prototype struct{}

func (_StructRepresentation_Map__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Map__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Map__Builder struct {
	_StructRepresentation_Map__Assembler
}
func (nb *_StructRepresentation_Map__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Map__Builder) Reset() {
	var w _StructRepresentation_Map
	var m schema.Maybe
	*nb = _StructRepresentation_Map__Builder{_StructRepresentation_Map__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Map__Assembler struct {
	w *_StructRepresentation_Map
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fields _Map__FieldName__StructRepresentation_Map_FieldDetails__Assembler
	}

func (na *_StructRepresentation_Map__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fields.reset()
}

var (
	fieldBit__StructRepresentation_Map_Fields = 1 << 0
	fieldBits__StructRepresentation_Map_sufficient = 0
)
func (na *_StructRepresentation_Map__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Map{}
	}
	return na, nil
}
func (_StructRepresentation_Map__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.BeginList(0)
}
func (na *_StructRepresentation_Map__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Map__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignBool(false)
}
func (_StructRepresentation_Map__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignInt(0)
}
func (_StructRepresentation_Map__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignFloat(0)
}
func (_StructRepresentation_Map__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignString("")
}
func (_StructRepresentation_Map__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignBytes(nil)
}
func (_StructRepresentation_Map__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map"}.AssignLink(nil)
}
func (na *_StructRepresentation_Map__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Map", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Map__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map__Prototype{}
}
func (ma *_StructRepresentation_Map__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.fields.m {
		case schema.Maybe_Value:
			ma.w.fields.v = ma.ca_fields.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fields":
		if ma.s & fieldBit__StructRepresentation_Map_Fields != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_Fields}
		}
		ma.s += fieldBit__StructRepresentation_Map_Fields
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fields.w = ma.w.fields.v
		ma.ca_fields.m = &ma.w.fields.m
		return &ma.ca_fields, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Map__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Map__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Map__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fields.w = ma.w.fields.v
		ma.ca_fields.m = &ma.w.fields.m
		return &ma.ca_fields
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Map__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Map__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Map__KeyAssembler _StructRepresentation_Map__Assembler
func (_StructRepresentation_Map__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Map__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Map__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Map__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Map__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Map__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Map__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fields":
		if ka.s & fieldBit__StructRepresentation_Map_Fields != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_Fields}
		}
		ka.s += fieldBit__StructRepresentation_Map_Fields
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Map__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Map__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Map__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Map__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Map) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Map) Representation() ipld.Node {
	return (*_StructRepresentation_Map__Repr)(n)
}
type _StructRepresentation_Map__Repr _StructRepresentation_Map
var (
	fieldName__StructRepresentation_Map_Fields_serial = _String{"fields"}
)
var _ ipld.Node = &_StructRepresentation_Map__Repr{}
func (_StructRepresentation_Map__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Map__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fields":
		if n.fields.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.fields.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Map__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Map__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Map__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Map__Repr) MapIterator() ipld.MapIterator {
	end := 1
	if n.fields.m == schema.Maybe_Absent {
		end = 0
	} else {
		goto done
	}
done:
	return &_StructRepresentation_Map__ReprMapItr{n, 0, end}
}

type _StructRepresentation_Map__ReprMapItr struct {
	n   *_StructRepresentation_Map__Repr
	idx int
	end int
}

func (itr *_StructRepresentation_Map__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Map_Fields_serial
		if itr.n.fields.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.fields.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Map__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StructRepresentation_Map__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Map__Repr) Length() int {
	l := 1
	if rn.fields.m == schema.Maybe_Absent {
		l--
	}
	return l
}
func (_StructRepresentation_Map__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Map__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Map__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsBool()
}
func (_StructRepresentation_Map__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsInt()
}
func (_StructRepresentation_Map__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsFloat()
}
func (_StructRepresentation_Map__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsString()
}
func (_StructRepresentation_Map__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsBytes()
}
func (_StructRepresentation_Map__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map.Repr"}.AsLink()
}
func (_StructRepresentation_Map__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map__ReprPrototype{}
}
type _StructRepresentation_Map__ReprPrototype struct{}

func (_StructRepresentation_Map__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Map__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Map__ReprBuilder struct {
	_StructRepresentation_Map__ReprAssembler
}
func (nb *_StructRepresentation_Map__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Map__ReprBuilder) Reset() {
	var w _StructRepresentation_Map
	var m schema.Maybe
	*nb = _StructRepresentation_Map__ReprBuilder{_StructRepresentation_Map__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Map__ReprAssembler struct {
	w *_StructRepresentation_Map
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fields _Map__FieldName__StructRepresentation_Map_FieldDetails__ReprAssembler
	}

func (na *_StructRepresentation_Map__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fields.reset()
}
func (na *_StructRepresentation_Map__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Map{}
	}
	return na, nil
}
func (_StructRepresentation_Map__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Map__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Map__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Map__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Map__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Map__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignString("")
}
func (_StructRepresentation_Map__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Map__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Map__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Map.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Map__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map__ReprPrototype{}
}
func (ma *_StructRepresentation_Map__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.fields.m {
		case schema.Maybe_Value:
			ma.w.fields.v = ma.ca_fields.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fields":
		if ma.s & fieldBit__StructRepresentation_Map_Fields != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_Fields_serial}
		}
		ma.s += fieldBit__StructRepresentation_Map_Fields
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fields.w = ma.w.fields.v
		ma.ca_fields.m = &ma.w.fields.m
		
		return &ma.ca_fields, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Map__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Map__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Map__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fields.w = ma.w.fields.v
		ma.ca_fields.m = &ma.w.fields.m
		
		return &ma.ca_fields
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Map__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Map__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Map__ReprKeyAssembler _StructRepresentation_Map__ReprAssembler
func (_StructRepresentation_Map__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Map__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Map__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Map__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Map__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Map__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Map__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fields":
		if ka.s & fieldBit__StructRepresentation_Map_Fields != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_Fields_serial}
		}
		ka.s += fieldBit__StructRepresentation_Map_Fields
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Map__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Map__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Map__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Map__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StructRepresentation_Map_FieldDetails) FieldRename() MaybeString {
	return &n.rename
}
func (n _StructRepresentation_Map_FieldDetails) FieldImplicit() MaybeAnyScalar {
	return &n.implicit
}
type _StructRepresentation_Map_FieldDetails__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Map_FieldDetails
}
type MaybeStructRepresentation_Map_FieldDetails = *_StructRepresentation_Map_FieldDetails__Maybe

func (m MaybeStructRepresentation_Map_FieldDetails) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Map_FieldDetails) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Map_FieldDetails) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Map_FieldDetails) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Map_FieldDetails) Must() StructRepresentation_Map_FieldDetails {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructRepresentation_Map_FieldDetails_Rename = _String{"rename"}
	fieldName__StructRepresentation_Map_FieldDetails_Implicit = _String{"implicit"}
)
var _ ipld.Node = (StructRepresentation_Map_FieldDetails)(&_StructRepresentation_Map_FieldDetails{})
var _ schema.TypedNode = (StructRepresentation_Map_FieldDetails)(&_StructRepresentation_Map_FieldDetails{})
func (StructRepresentation_Map_FieldDetails) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Map_FieldDetails) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "rename":
		if n.rename.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.rename.v, nil
	case "implicit":
		if n.implicit.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.implicit.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Map_FieldDetails) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Map_FieldDetails) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.LookupByIndex(0)
}
func (n StructRepresentation_Map_FieldDetails) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Map_FieldDetails) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Map_FieldDetails__MapItr{n, 0}
}

type _StructRepresentation_Map_FieldDetails__MapItr struct {
	n StructRepresentation_Map_FieldDetails
	idx  int
}

func (itr *_StructRepresentation_Map_FieldDetails__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Map_FieldDetails_Rename
		if itr.n.rename.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.rename.v
	case 1:
		k = &fieldName__StructRepresentation_Map_FieldDetails_Implicit
		if itr.n.implicit.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.implicit.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Map_FieldDetails__MapItr) Done() bool {
	return itr.idx >= 2
}

func (StructRepresentation_Map_FieldDetails) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Map_FieldDetails) Length() int {
	return 2
}
func (StructRepresentation_Map_FieldDetails) IsAbsent() bool {
	return false
}
func (StructRepresentation_Map_FieldDetails) IsNull() bool {
	return false
}
func (StructRepresentation_Map_FieldDetails) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsBool()
}
func (StructRepresentation_Map_FieldDetails) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsInt()
}
func (StructRepresentation_Map_FieldDetails) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsFloat()
}
func (StructRepresentation_Map_FieldDetails) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsString()
}
func (StructRepresentation_Map_FieldDetails) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsBytes()
}
func (StructRepresentation_Map_FieldDetails) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails"}.AsLink()
}
func (StructRepresentation_Map_FieldDetails) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__Prototype{}
}
type _StructRepresentation_Map_FieldDetails__Prototype struct{}

func (_StructRepresentation_Map_FieldDetails__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Map_FieldDetails__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Map_FieldDetails__Builder struct {
	_StructRepresentation_Map_FieldDetails__Assembler
}
func (nb *_StructRepresentation_Map_FieldDetails__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Map_FieldDetails__Builder) Reset() {
	var w _StructRepresentation_Map_FieldDetails
	var m schema.Maybe
	*nb = _StructRepresentation_Map_FieldDetails__Builder{_StructRepresentation_Map_FieldDetails__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Map_FieldDetails__Assembler struct {
	w *_StructRepresentation_Map_FieldDetails
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_rename _String__Assembler
	ca_implicit _AnyScalar__Assembler
	}

func (na *_StructRepresentation_Map_FieldDetails__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_rename.reset()
	na.ca_implicit.reset()
}

var (
	fieldBit__StructRepresentation_Map_FieldDetails_Rename = 1 << 0
	fieldBit__StructRepresentation_Map_FieldDetails_Implicit = 1 << 1
	fieldBits__StructRepresentation_Map_FieldDetails_sufficient = 0
)
func (na *_StructRepresentation_Map_FieldDetails__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Map_FieldDetails{}
	}
	return na, nil
}
func (_StructRepresentation_Map_FieldDetails__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.BeginList(0)
}
func (na *_StructRepresentation_Map_FieldDetails__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignBool(false)
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignInt(0)
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignFloat(0)
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignString("")
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignBytes(nil)
}
func (_StructRepresentation_Map_FieldDetails__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails"}.AssignLink(nil)
}
func (na *_StructRepresentation_Map_FieldDetails__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Map_FieldDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Map_FieldDetails", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Map_FieldDetails__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__Prototype{}
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.rename.m {
		case schema.Maybe_Value:
			ma.w.rename.v = ma.ca_rename.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.implicit.m {
		case schema.Maybe_Value:
			ma.w.implicit.v = ma.ca_implicit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "rename":
		if ma.s & fieldBit__StructRepresentation_Map_FieldDetails_Rename != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Rename}
		}
		ma.s += fieldBit__StructRepresentation_Map_FieldDetails_Rename
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_rename.w = ma.w.rename.v
		ma.ca_rename.m = &ma.w.rename.m
		return &ma.ca_rename, nil
	case "implicit":
		if ma.s & fieldBit__StructRepresentation_Map_FieldDetails_Implicit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Implicit}
		}
		ma.s += fieldBit__StructRepresentation_Map_FieldDetails_Implicit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_implicit.w = ma.w.implicit.v
		ma.ca_implicit.m = &ma.w.implicit.m
		return &ma.ca_implicit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map_FieldDetails", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Map_FieldDetails__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_rename.w = ma.w.rename.v
		ma.ca_rename.m = &ma.w.rename.m
		return &ma.ca_rename
	case 1:
		ma.ca_implicit.w = ma.w.implicit.v
		ma.ca_implicit.m = &ma.w.implicit.m
		return &ma.ca_implicit
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Map_FieldDetails__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Map_FieldDetails__KeyAssembler _StructRepresentation_Map_FieldDetails__Assembler
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "rename":
		if ka.s & fieldBit__StructRepresentation_Map_FieldDetails_Rename != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Rename}
		}
		ka.s += fieldBit__StructRepresentation_Map_FieldDetails_Rename
		ka.state = maState_expectValue
		ka.f = 0
	case "implicit":
		if ka.s & fieldBit__StructRepresentation_Map_FieldDetails_Implicit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Implicit}
		}
		ka.s += fieldBit__StructRepresentation_Map_FieldDetails_Implicit
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map_FieldDetails", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Map_FieldDetails__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Map_FieldDetails__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Map_FieldDetails) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Map_FieldDetails) Representation() ipld.Node {
	return (*_StructRepresentation_Map_FieldDetails__Repr)(n)
}
type _StructRepresentation_Map_FieldDetails__Repr _StructRepresentation_Map_FieldDetails
var (
	fieldName__StructRepresentation_Map_FieldDetails_Rename_serial = _String{"rename"}
	fieldName__StructRepresentation_Map_FieldDetails_Implicit_serial = _String{"implicit"}
)
var _ ipld.Node = &_StructRepresentation_Map_FieldDetails__Repr{}
func (_StructRepresentation_Map_FieldDetails__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Map_FieldDetails__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "rename":
		if n.rename.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.rename.v.Representation(), nil
	case "implicit":
		if n.implicit.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.implicit.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Map_FieldDetails__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Map_FieldDetails__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Map_FieldDetails__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Map_FieldDetails__Repr) MapIterator() ipld.MapIterator {
	end := 2
	if n.implicit.m == schema.Maybe_Absent {
		end = 1
	} else {
		goto done
	}
	if n.rename.m == schema.Maybe_Absent {
		end = 0
	} else {
		goto done
	}
done:
	return &_StructRepresentation_Map_FieldDetails__ReprMapItr{n, 0, end}
}

type _StructRepresentation_Map_FieldDetails__ReprMapItr struct {
	n   *_StructRepresentation_Map_FieldDetails__Repr
	idx int
	end int
}

func (itr *_StructRepresentation_Map_FieldDetails__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Map_FieldDetails_Rename_serial
		if itr.n.rename.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.rename.v.Representation()
	case 1:
		k = &fieldName__StructRepresentation_Map_FieldDetails_Implicit_serial
		if itr.n.implicit.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.implicit.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Map_FieldDetails__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StructRepresentation_Map_FieldDetails__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Map_FieldDetails__Repr) Length() int {
	l := 2
	if rn.rename.m == schema.Maybe_Absent {
		l--
	}
	if rn.implicit.m == schema.Maybe_Absent {
		l--
	}
	return l
}
func (_StructRepresentation_Map_FieldDetails__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Map_FieldDetails__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsBool()
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsInt()
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsFloat()
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsString()
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsBytes()
}
func (_StructRepresentation_Map_FieldDetails__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AsLink()
}
func (_StructRepresentation_Map_FieldDetails__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__ReprPrototype{}
}
type _StructRepresentation_Map_FieldDetails__ReprPrototype struct{}

func (_StructRepresentation_Map_FieldDetails__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Map_FieldDetails__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Map_FieldDetails__ReprBuilder struct {
	_StructRepresentation_Map_FieldDetails__ReprAssembler
}
func (nb *_StructRepresentation_Map_FieldDetails__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Map_FieldDetails__ReprBuilder) Reset() {
	var w _StructRepresentation_Map_FieldDetails
	var m schema.Maybe
	*nb = _StructRepresentation_Map_FieldDetails__ReprBuilder{_StructRepresentation_Map_FieldDetails__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Map_FieldDetails__ReprAssembler struct {
	w *_StructRepresentation_Map_FieldDetails
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_rename _String__ReprAssembler
	ca_implicit _AnyScalar__ReprAssembler
	}

func (na *_StructRepresentation_Map_FieldDetails__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_rename.reset()
	na.ca_implicit.reset()
}
func (na *_StructRepresentation_Map_FieldDetails__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Map_FieldDetails{}
	}
	return na, nil
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignString("")
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Map_FieldDetails__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Map_FieldDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Map_FieldDetails.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Map_FieldDetails__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Map_FieldDetails__ReprPrototype{}
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.rename.m {
		case schema.Maybe_Value:
			ma.w.rename.v = ma.ca_rename.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.implicit.m {
		case schema.Maybe_Value:
			ma.w.implicit.v = ma.ca_implicit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "rename":
		if ma.s & fieldBit__StructRepresentation_Map_FieldDetails_Rename != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Rename_serial}
		}
		ma.s += fieldBit__StructRepresentation_Map_FieldDetails_Rename
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_rename.w = ma.w.rename.v
		ma.ca_rename.m = &ma.w.rename.m
		
		return &ma.ca_rename, nil
	case "implicit":
		if ma.s & fieldBit__StructRepresentation_Map_FieldDetails_Implicit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Implicit_serial}
		}
		ma.s += fieldBit__StructRepresentation_Map_FieldDetails_Implicit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_implicit.w = ma.w.implicit.v
		ma.ca_implicit.m = &ma.w.implicit.m
		
		return &ma.ca_implicit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map_FieldDetails.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Map_FieldDetails__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_rename.w = ma.w.rename.v
		ma.ca_rename.m = &ma.w.rename.m
		
		return &ma.ca_rename
	case 1:
		ma.ca_implicit.w = ma.w.implicit.v
		ma.ca_implicit.m = &ma.w.implicit.m
		
		return &ma.ca_implicit
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Map_FieldDetails__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Map_FieldDetails__ReprKeyAssembler _StructRepresentation_Map_FieldDetails__ReprAssembler
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "rename":
		if ka.s & fieldBit__StructRepresentation_Map_FieldDetails_Rename != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Rename_serial}
		}
		ka.s += fieldBit__StructRepresentation_Map_FieldDetails_Rename
		ka.state = maState_expectValue
		ka.f = 0
	case "implicit":
		if ka.s & fieldBit__StructRepresentation_Map_FieldDetails_Implicit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Map_FieldDetails_Implicit_serial}
		}
		ka.s += fieldBit__StructRepresentation_Map_FieldDetails_Implicit
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Map_FieldDetails.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Map_FieldDetails.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Map_FieldDetails__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StructRepresentation_Stringjoin) FieldJoin() String {
	return &n.join
}
func (n _StructRepresentation_Stringjoin) FieldFieldOrder() MaybeList__FieldName {
	return &n.fieldOrder
}
type _StructRepresentation_Stringjoin__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Stringjoin
}
type MaybeStructRepresentation_Stringjoin = *_StructRepresentation_Stringjoin__Maybe

func (m MaybeStructRepresentation_Stringjoin) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Stringjoin) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Stringjoin) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Stringjoin) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Stringjoin) Must() StructRepresentation_Stringjoin {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructRepresentation_Stringjoin_Join = _String{"join"}
	fieldName__StructRepresentation_Stringjoin_FieldOrder = _String{"fieldOrder"}
)
var _ ipld.Node = (StructRepresentation_Stringjoin)(&_StructRepresentation_Stringjoin{})
var _ schema.TypedNode = (StructRepresentation_Stringjoin)(&_StructRepresentation_Stringjoin{})
func (StructRepresentation_Stringjoin) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Stringjoin) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "join":
		return &n.join, nil
	case "fieldOrder":
		if n.fieldOrder.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.fieldOrder.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Stringjoin) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Stringjoin) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.LookupByIndex(0)
}
func (n StructRepresentation_Stringjoin) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Stringjoin) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Stringjoin__MapItr{n, 0}
}

type _StructRepresentation_Stringjoin__MapItr struct {
	n StructRepresentation_Stringjoin
	idx  int
}

func (itr *_StructRepresentation_Stringjoin__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Stringjoin_Join
		v = &itr.n.join
	case 1:
		k = &fieldName__StructRepresentation_Stringjoin_FieldOrder
		if itr.n.fieldOrder.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.fieldOrder.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Stringjoin__MapItr) Done() bool {
	return itr.idx >= 2
}

func (StructRepresentation_Stringjoin) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Stringjoin) Length() int {
	return 2
}
func (StructRepresentation_Stringjoin) IsAbsent() bool {
	return false
}
func (StructRepresentation_Stringjoin) IsNull() bool {
	return false
}
func (StructRepresentation_Stringjoin) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsBool()
}
func (StructRepresentation_Stringjoin) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsInt()
}
func (StructRepresentation_Stringjoin) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsFloat()
}
func (StructRepresentation_Stringjoin) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsString()
}
func (StructRepresentation_Stringjoin) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsBytes()
}
func (StructRepresentation_Stringjoin) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin"}.AsLink()
}
func (StructRepresentation_Stringjoin) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringjoin__Prototype{}
}
type _StructRepresentation_Stringjoin__Prototype struct{}

func (_StructRepresentation_Stringjoin__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Stringjoin__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Stringjoin__Builder struct {
	_StructRepresentation_Stringjoin__Assembler
}
func (nb *_StructRepresentation_Stringjoin__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Stringjoin__Builder) Reset() {
	var w _StructRepresentation_Stringjoin
	var m schema.Maybe
	*nb = _StructRepresentation_Stringjoin__Builder{_StructRepresentation_Stringjoin__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Stringjoin__Assembler struct {
	w *_StructRepresentation_Stringjoin
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_join _String__Assembler
	ca_fieldOrder _List__FieldName__Assembler
	}

func (na *_StructRepresentation_Stringjoin__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_join.reset()
	na.ca_fieldOrder.reset()
}

var (
	fieldBit__StructRepresentation_Stringjoin_Join = 1 << 0
	fieldBit__StructRepresentation_Stringjoin_FieldOrder = 1 << 1
	fieldBits__StructRepresentation_Stringjoin_sufficient = 0 + 1 << 0
)
func (na *_StructRepresentation_Stringjoin__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Stringjoin{}
	}
	return na, nil
}
func (_StructRepresentation_Stringjoin__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.BeginList(0)
}
func (na *_StructRepresentation_Stringjoin__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Stringjoin__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignBool(false)
}
func (_StructRepresentation_Stringjoin__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignInt(0)
}
func (_StructRepresentation_Stringjoin__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignFloat(0)
}
func (_StructRepresentation_Stringjoin__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignString("")
}
func (_StructRepresentation_Stringjoin__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringjoin__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin"}.AssignLink(nil)
}
func (na *_StructRepresentation_Stringjoin__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Stringjoin); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Stringjoin", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Stringjoin__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringjoin__Prototype{}
}
func (ma *_StructRepresentation_Stringjoin__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_join.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.fieldOrder.m {
		case schema.Maybe_Value:
			ma.w.fieldOrder.v = ma.ca_fieldOrder.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringjoin__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "join":
		if ma.s & fieldBit__StructRepresentation_Stringjoin_Join != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_Join}
		}
		ma.s += fieldBit__StructRepresentation_Stringjoin_Join
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_join.w = &ma.w.join
		ma.ca_join.m = &ma.cm
		return &ma.ca_join, nil
	case "fieldOrder":
		if ma.s & fieldBit__StructRepresentation_Stringjoin_FieldOrder != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_FieldOrder}
		}
		ma.s += fieldBit__StructRepresentation_Stringjoin_FieldOrder
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		return &ma.ca_fieldOrder, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringjoin", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Stringjoin__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Stringjoin__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Stringjoin__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_join.w = &ma.w.join
		ma.ca_join.m = &ma.cm
		return &ma.ca_join
	case 1:
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		return &ma.ca_fieldOrder
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringjoin__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Stringjoin__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Stringjoin__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Stringjoin__KeyAssembler _StructRepresentation_Stringjoin__Assembler
func (_StructRepresentation_Stringjoin__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Stringjoin__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Stringjoin__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Stringjoin__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Stringjoin__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Stringjoin__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Stringjoin__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "join":
		if ka.s & fieldBit__StructRepresentation_Stringjoin_Join != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_Join}
		}
		ka.s += fieldBit__StructRepresentation_Stringjoin_Join
		ka.state = maState_expectValue
		ka.f = 0
	case "fieldOrder":
		if ka.s & fieldBit__StructRepresentation_Stringjoin_FieldOrder != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_FieldOrder}
		}
		ka.s += fieldBit__StructRepresentation_Stringjoin_FieldOrder
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringjoin", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Stringjoin__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringjoin__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Stringjoin__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Stringjoin__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Stringjoin) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Stringjoin) Representation() ipld.Node {
	return (*_StructRepresentation_Stringjoin__Repr)(n)
}
type _StructRepresentation_Stringjoin__Repr _StructRepresentation_Stringjoin
var (
	fieldName__StructRepresentation_Stringjoin_Join_serial = _String{"join"}
	fieldName__StructRepresentation_Stringjoin_FieldOrder_serial = _String{"fieldOrder"}
)
var _ ipld.Node = &_StructRepresentation_Stringjoin__Repr{}
func (_StructRepresentation_Stringjoin__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Stringjoin__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "join":
		return n.join.Representation(), nil
	case "fieldOrder":
		if n.fieldOrder.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.fieldOrder.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Stringjoin__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Stringjoin__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Stringjoin__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Stringjoin__Repr) MapIterator() ipld.MapIterator {
	end := 2
	if n.fieldOrder.m == schema.Maybe_Absent {
		end = 1
	} else {
		goto done
	}
done:
	return &_StructRepresentation_Stringjoin__ReprMapItr{n, 0, end}
}

type _StructRepresentation_Stringjoin__ReprMapItr struct {
	n   *_StructRepresentation_Stringjoin__Repr
	idx int
	end int
}

func (itr *_StructRepresentation_Stringjoin__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Stringjoin_Join_serial
		v = itr.n.join.Representation()
	case 1:
		k = &fieldName__StructRepresentation_Stringjoin_FieldOrder_serial
		if itr.n.fieldOrder.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.fieldOrder.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Stringjoin__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StructRepresentation_Stringjoin__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Stringjoin__Repr) Length() int {
	l := 2
	if rn.fieldOrder.m == schema.Maybe_Absent {
		l--
	}
	return l
}
func (_StructRepresentation_Stringjoin__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Stringjoin__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Stringjoin__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsBool()
}
func (_StructRepresentation_Stringjoin__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsInt()
}
func (_StructRepresentation_Stringjoin__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsFloat()
}
func (_StructRepresentation_Stringjoin__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsString()
}
func (_StructRepresentation_Stringjoin__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsBytes()
}
func (_StructRepresentation_Stringjoin__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AsLink()
}
func (_StructRepresentation_Stringjoin__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringjoin__ReprPrototype{}
}
type _StructRepresentation_Stringjoin__ReprPrototype struct{}

func (_StructRepresentation_Stringjoin__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Stringjoin__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Stringjoin__ReprBuilder struct {
	_StructRepresentation_Stringjoin__ReprAssembler
}
func (nb *_StructRepresentation_Stringjoin__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Stringjoin__ReprBuilder) Reset() {
	var w _StructRepresentation_Stringjoin
	var m schema.Maybe
	*nb = _StructRepresentation_Stringjoin__ReprBuilder{_StructRepresentation_Stringjoin__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Stringjoin__ReprAssembler struct {
	w *_StructRepresentation_Stringjoin
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_join _String__ReprAssembler
	ca_fieldOrder _List__FieldName__ReprAssembler
	}

func (na *_StructRepresentation_Stringjoin__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_join.reset()
	na.ca_fieldOrder.reset()
}
func (na *_StructRepresentation_Stringjoin__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Stringjoin{}
	}
	return na, nil
}
func (_StructRepresentation_Stringjoin__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Stringjoin__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignString("")
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringjoin__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Stringjoin__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Stringjoin); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Stringjoin.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Stringjoin__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringjoin__ReprPrototype{}
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.fieldOrder.m {
		case schema.Maybe_Value:
			ma.w.fieldOrder.v = ma.ca_fieldOrder.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "join":
		if ma.s & fieldBit__StructRepresentation_Stringjoin_Join != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_Join_serial}
		}
		ma.s += fieldBit__StructRepresentation_Stringjoin_Join
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_join.w = &ma.w.join
		ma.ca_join.m = &ma.cm
		return &ma.ca_join, nil
	case "fieldOrder":
		if ma.s & fieldBit__StructRepresentation_Stringjoin_FieldOrder != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_FieldOrder_serial}
		}
		ma.s += fieldBit__StructRepresentation_Stringjoin_FieldOrder
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		
		return &ma.ca_fieldOrder, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringjoin.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Stringjoin__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_join.w = &ma.w.join
		ma.ca_join.m = &ma.cm
		return &ma.ca_join
	case 1:
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		
		return &ma.ca_fieldOrder
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Stringjoin__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Stringjoin__ReprKeyAssembler _StructRepresentation_Stringjoin__ReprAssembler
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "join":
		if ka.s & fieldBit__StructRepresentation_Stringjoin_Join != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_Join_serial}
		}
		ka.s += fieldBit__StructRepresentation_Stringjoin_Join
		ka.state = maState_expectValue
		ka.f = 0
	case "fieldOrder":
		if ka.s & fieldBit__StructRepresentation_Stringjoin_FieldOrder != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringjoin_FieldOrder_serial}
		}
		ka.s += fieldBit__StructRepresentation_Stringjoin_FieldOrder
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringjoin.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringjoin.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Stringjoin__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Stringjoin__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StructRepresentation_Stringpairs) FieldInnerDelim() String {
	return &n.innerDelim
}
func (n _StructRepresentation_Stringpairs) FieldEntryDelim() String {
	return &n.entryDelim
}
type _StructRepresentation_Stringpairs__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Stringpairs
}
type MaybeStructRepresentation_Stringpairs = *_StructRepresentation_Stringpairs__Maybe

func (m MaybeStructRepresentation_Stringpairs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Stringpairs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Stringpairs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Stringpairs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Stringpairs) Must() StructRepresentation_Stringpairs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructRepresentation_Stringpairs_InnerDelim = _String{"innerDelim"}
	fieldName__StructRepresentation_Stringpairs_EntryDelim = _String{"entryDelim"}
)
var _ ipld.Node = (StructRepresentation_Stringpairs)(&_StructRepresentation_Stringpairs{})
var _ schema.TypedNode = (StructRepresentation_Stringpairs)(&_StructRepresentation_Stringpairs{})
func (StructRepresentation_Stringpairs) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Stringpairs) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "innerDelim":
		return &n.innerDelim, nil
	case "entryDelim":
		return &n.entryDelim, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Stringpairs) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Stringpairs) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.LookupByIndex(0)
}
func (n StructRepresentation_Stringpairs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Stringpairs) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Stringpairs__MapItr{n, 0}
}

type _StructRepresentation_Stringpairs__MapItr struct {
	n StructRepresentation_Stringpairs
	idx  int
}

func (itr *_StructRepresentation_Stringpairs__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Stringpairs_InnerDelim
		v = &itr.n.innerDelim
	case 1:
		k = &fieldName__StructRepresentation_Stringpairs_EntryDelim
		v = &itr.n.entryDelim
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Stringpairs__MapItr) Done() bool {
	return itr.idx >= 2
}

func (StructRepresentation_Stringpairs) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Stringpairs) Length() int {
	return 2
}
func (StructRepresentation_Stringpairs) IsAbsent() bool {
	return false
}
func (StructRepresentation_Stringpairs) IsNull() bool {
	return false
}
func (StructRepresentation_Stringpairs) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsBool()
}
func (StructRepresentation_Stringpairs) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsInt()
}
func (StructRepresentation_Stringpairs) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsFloat()
}
func (StructRepresentation_Stringpairs) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsString()
}
func (StructRepresentation_Stringpairs) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsBytes()
}
func (StructRepresentation_Stringpairs) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs"}.AsLink()
}
func (StructRepresentation_Stringpairs) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringpairs__Prototype{}
}
type _StructRepresentation_Stringpairs__Prototype struct{}

func (_StructRepresentation_Stringpairs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Stringpairs__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Stringpairs__Builder struct {
	_StructRepresentation_Stringpairs__Assembler
}
func (nb *_StructRepresentation_Stringpairs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Stringpairs__Builder) Reset() {
	var w _StructRepresentation_Stringpairs
	var m schema.Maybe
	*nb = _StructRepresentation_Stringpairs__Builder{_StructRepresentation_Stringpairs__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Stringpairs__Assembler struct {
	w *_StructRepresentation_Stringpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_innerDelim _String__Assembler
	ca_entryDelim _String__Assembler
	}

func (na *_StructRepresentation_Stringpairs__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_innerDelim.reset()
	na.ca_entryDelim.reset()
}

var (
	fieldBit__StructRepresentation_Stringpairs_InnerDelim = 1 << 0
	fieldBit__StructRepresentation_Stringpairs_EntryDelim = 1 << 1
	fieldBits__StructRepresentation_Stringpairs_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_StructRepresentation_Stringpairs__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Stringpairs{}
	}
	return na, nil
}
func (_StructRepresentation_Stringpairs__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.BeginList(0)
}
func (na *_StructRepresentation_Stringpairs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Stringpairs__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignBool(false)
}
func (_StructRepresentation_Stringpairs__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignInt(0)
}
func (_StructRepresentation_Stringpairs__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignFloat(0)
}
func (_StructRepresentation_Stringpairs__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignString("")
}
func (_StructRepresentation_Stringpairs__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringpairs__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs"}.AssignLink(nil)
}
func (na *_StructRepresentation_Stringpairs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Stringpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Stringpairs", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Stringpairs__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringpairs__Prototype{}
}
func (ma *_StructRepresentation_Stringpairs__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_innerDelim.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_entryDelim.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringpairs__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "innerDelim":
		if ma.s & fieldBit__StructRepresentation_Stringpairs_InnerDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_InnerDelim}
		}
		ma.s += fieldBit__StructRepresentation_Stringpairs_InnerDelim
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim, nil
	case "entryDelim":
		if ma.s & fieldBit__StructRepresentation_Stringpairs_EntryDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_EntryDelim}
		}
		ma.s += fieldBit__StructRepresentation_Stringpairs_EntryDelim
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringpairs", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Stringpairs__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Stringpairs__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Stringpairs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim
	case 1:
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringpairs__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Stringpairs__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Stringpairs__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Stringpairs__KeyAssembler _StructRepresentation_Stringpairs__Assembler
func (_StructRepresentation_Stringpairs__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Stringpairs__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Stringpairs__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Stringpairs__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Stringpairs__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Stringpairs__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Stringpairs__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "innerDelim":
		if ka.s & fieldBit__StructRepresentation_Stringpairs_InnerDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_InnerDelim}
		}
		ka.s += fieldBit__StructRepresentation_Stringpairs_InnerDelim
		ka.state = maState_expectValue
		ka.f = 0
	case "entryDelim":
		if ka.s & fieldBit__StructRepresentation_Stringpairs_EntryDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_EntryDelim}
		}
		ka.s += fieldBit__StructRepresentation_Stringpairs_EntryDelim
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringpairs", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Stringpairs__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringpairs__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Stringpairs__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Stringpairs__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Stringpairs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Stringpairs) Representation() ipld.Node {
	return (*_StructRepresentation_Stringpairs__Repr)(n)
}
type _StructRepresentation_Stringpairs__Repr _StructRepresentation_Stringpairs
var (
	fieldName__StructRepresentation_Stringpairs_InnerDelim_serial = _String{"innerDelim"}
	fieldName__StructRepresentation_Stringpairs_EntryDelim_serial = _String{"entryDelim"}
)
var _ ipld.Node = &_StructRepresentation_Stringpairs__Repr{}
func (_StructRepresentation_Stringpairs__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Stringpairs__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "innerDelim":
		return n.innerDelim.Representation(), nil
	case "entryDelim":
		return n.entryDelim.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Stringpairs__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Stringpairs__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Stringpairs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Stringpairs__Repr) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Stringpairs__ReprMapItr{n, 0}
}

type _StructRepresentation_Stringpairs__ReprMapItr struct {
	n   *_StructRepresentation_Stringpairs__Repr
	idx int
	
}

func (itr *_StructRepresentation_Stringpairs__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Stringpairs_InnerDelim_serial
		v = itr.n.innerDelim.Representation()
	case 1:
		k = &fieldName__StructRepresentation_Stringpairs_EntryDelim_serial
		v = itr.n.entryDelim.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Stringpairs__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_StructRepresentation_Stringpairs__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Stringpairs__Repr) Length() int {
	l := 2
	return l
}
func (_StructRepresentation_Stringpairs__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Stringpairs__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Stringpairs__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsBool()
}
func (_StructRepresentation_Stringpairs__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsInt()
}
func (_StructRepresentation_Stringpairs__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsFloat()
}
func (_StructRepresentation_Stringpairs__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsString()
}
func (_StructRepresentation_Stringpairs__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsBytes()
}
func (_StructRepresentation_Stringpairs__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AsLink()
}
func (_StructRepresentation_Stringpairs__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringpairs__ReprPrototype{}
}
type _StructRepresentation_Stringpairs__ReprPrototype struct{}

func (_StructRepresentation_Stringpairs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Stringpairs__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Stringpairs__ReprBuilder struct {
	_StructRepresentation_Stringpairs__ReprAssembler
}
func (nb *_StructRepresentation_Stringpairs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Stringpairs__ReprBuilder) Reset() {
	var w _StructRepresentation_Stringpairs
	var m schema.Maybe
	*nb = _StructRepresentation_Stringpairs__ReprBuilder{_StructRepresentation_Stringpairs__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Stringpairs__ReprAssembler struct {
	w *_StructRepresentation_Stringpairs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_innerDelim _String__ReprAssembler
	ca_entryDelim _String__ReprAssembler
	}

func (na *_StructRepresentation_Stringpairs__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_innerDelim.reset()
	na.ca_entryDelim.reset()
}
func (na *_StructRepresentation_Stringpairs__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Stringpairs{}
	}
	return na, nil
}
func (_StructRepresentation_Stringpairs__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Stringpairs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignString("")
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringpairs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Stringpairs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Stringpairs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Stringpairs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Stringpairs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Stringpairs__ReprPrototype{}
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "innerDelim":
		if ma.s & fieldBit__StructRepresentation_Stringpairs_InnerDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_InnerDelim_serial}
		}
		ma.s += fieldBit__StructRepresentation_Stringpairs_InnerDelim
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim, nil
	case "entryDelim":
		if ma.s & fieldBit__StructRepresentation_Stringpairs_EntryDelim != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_EntryDelim_serial}
		}
		ma.s += fieldBit__StructRepresentation_Stringpairs_EntryDelim
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringpairs.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Stringpairs__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_innerDelim.w = &ma.w.innerDelim
		ma.ca_innerDelim.m = &ma.cm
		return &ma.ca_innerDelim
	case 1:
		ma.ca_entryDelim.w = &ma.w.entryDelim
		ma.ca_entryDelim.m = &ma.cm
		return &ma.ca_entryDelim
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Stringpairs__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Stringpairs__ReprKeyAssembler _StructRepresentation_Stringpairs__ReprAssembler
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "innerDelim":
		if ka.s & fieldBit__StructRepresentation_Stringpairs_InnerDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_InnerDelim_serial}
		}
		ka.s += fieldBit__StructRepresentation_Stringpairs_InnerDelim
		ka.state = maState_expectValue
		ka.f = 0
	case "entryDelim":
		if ka.s & fieldBit__StructRepresentation_Stringpairs_EntryDelim != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Stringpairs_EntryDelim_serial}
		}
		ka.s += fieldBit__StructRepresentation_Stringpairs_EntryDelim
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Stringpairs.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Stringpairs.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Stringpairs__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Stringpairs__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StructRepresentation_Tuple) FieldFieldOrder() MaybeList__FieldName {
	return &n.fieldOrder
}
type _StructRepresentation_Tuple__Maybe struct {
	m schema.Maybe
	v StructRepresentation_Tuple
}
type MaybeStructRepresentation_Tuple = *_StructRepresentation_Tuple__Maybe

func (m MaybeStructRepresentation_Tuple) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStructRepresentation_Tuple) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStructRepresentation_Tuple) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStructRepresentation_Tuple) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStructRepresentation_Tuple) Must() StructRepresentation_Tuple {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StructRepresentation_Tuple_FieldOrder = _String{"fieldOrder"}
)
var _ ipld.Node = (StructRepresentation_Tuple)(&_StructRepresentation_Tuple{})
var _ schema.TypedNode = (StructRepresentation_Tuple)(&_StructRepresentation_Tuple{})
func (StructRepresentation_Tuple) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n StructRepresentation_Tuple) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fieldOrder":
		if n.fieldOrder.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.fieldOrder.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StructRepresentation_Tuple) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StructRepresentation_Tuple) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.LookupByIndex(0)
}
func (n StructRepresentation_Tuple) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StructRepresentation_Tuple) MapIterator() ipld.MapIterator {
	return &_StructRepresentation_Tuple__MapItr{n, 0}
}

type _StructRepresentation_Tuple__MapItr struct {
	n StructRepresentation_Tuple
	idx  int
}

func (itr *_StructRepresentation_Tuple__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Tuple_FieldOrder
		if itr.n.fieldOrder.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.fieldOrder.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Tuple__MapItr) Done() bool {
	return itr.idx >= 1
}

func (StructRepresentation_Tuple) ListIterator() ipld.ListIterator {
	return nil
}
func (StructRepresentation_Tuple) Length() int {
	return 1
}
func (StructRepresentation_Tuple) IsAbsent() bool {
	return false
}
func (StructRepresentation_Tuple) IsNull() bool {
	return false
}
func (StructRepresentation_Tuple) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsBool()
}
func (StructRepresentation_Tuple) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsInt()
}
func (StructRepresentation_Tuple) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsFloat()
}
func (StructRepresentation_Tuple) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsString()
}
func (StructRepresentation_Tuple) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsBytes()
}
func (StructRepresentation_Tuple) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple"}.AsLink()
}
func (StructRepresentation_Tuple) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Tuple__Prototype{}
}
type _StructRepresentation_Tuple__Prototype struct{}

func (_StructRepresentation_Tuple__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Tuple__Builder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Tuple__Builder struct {
	_StructRepresentation_Tuple__Assembler
}
func (nb *_StructRepresentation_Tuple__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Tuple__Builder) Reset() {
	var w _StructRepresentation_Tuple
	var m schema.Maybe
	*nb = _StructRepresentation_Tuple__Builder{_StructRepresentation_Tuple__Assembler{w: &w, m: &m}}
}
type _StructRepresentation_Tuple__Assembler struct {
	w *_StructRepresentation_Tuple
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fieldOrder _List__FieldName__Assembler
	}

func (na *_StructRepresentation_Tuple__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fieldOrder.reset()
}

var (
	fieldBit__StructRepresentation_Tuple_FieldOrder = 1 << 0
	fieldBits__StructRepresentation_Tuple_sufficient = 0
)
func (na *_StructRepresentation_Tuple__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Tuple{}
	}
	return na, nil
}
func (_StructRepresentation_Tuple__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.BeginList(0)
}
func (na *_StructRepresentation_Tuple__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Tuple__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignBool(false)
}
func (_StructRepresentation_Tuple__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignInt(0)
}
func (_StructRepresentation_Tuple__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignFloat(0)
}
func (_StructRepresentation_Tuple__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignString("")
}
func (_StructRepresentation_Tuple__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignBytes(nil)
}
func (_StructRepresentation_Tuple__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple"}.AssignLink(nil)
}
func (na *_StructRepresentation_Tuple__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Tuple); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Tuple", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Tuple__Assembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Tuple__Prototype{}
}
func (ma *_StructRepresentation_Tuple__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.fieldOrder.m {
		case schema.Maybe_Value:
			ma.w.fieldOrder.v = ma.ca_fieldOrder.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Tuple__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fieldOrder":
		if ma.s & fieldBit__StructRepresentation_Tuple_FieldOrder != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Tuple_FieldOrder}
		}
		ma.s += fieldBit__StructRepresentation_Tuple_FieldOrder
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		return &ma.ca_fieldOrder, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Tuple", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Tuple__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Tuple__KeyAssembler)(ma)
}
func (ma *_StructRepresentation_Tuple__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		return &ma.ca_fieldOrder
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Tuple__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Tuple__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Tuple__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StructRepresentation_Tuple__KeyAssembler _StructRepresentation_Tuple__Assembler
func (_StructRepresentation_Tuple__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Tuple__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Tuple__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Tuple__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Tuple__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Tuple__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Tuple__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fieldOrder":
		if ka.s & fieldBit__StructRepresentation_Tuple_FieldOrder != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Tuple_FieldOrder}
		}
		ka.s += fieldBit__StructRepresentation_Tuple_FieldOrder
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Tuple", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Tuple__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Tuple__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Tuple__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Tuple__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StructRepresentation_Tuple) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StructRepresentation_Tuple) Representation() ipld.Node {
	return (*_StructRepresentation_Tuple__Repr)(n)
}
type _StructRepresentation_Tuple__Repr _StructRepresentation_Tuple
var (
	fieldName__StructRepresentation_Tuple_FieldOrder_serial = _String{"fieldOrder"}
)
var _ ipld.Node = &_StructRepresentation_Tuple__Repr{}
func (_StructRepresentation_Tuple__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_StructRepresentation_Tuple__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fieldOrder":
		if n.fieldOrder.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.fieldOrder.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StructRepresentation_Tuple__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StructRepresentation_Tuple__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.LookupByIndex(0)
}
func (n _StructRepresentation_Tuple__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StructRepresentation_Tuple__Repr) MapIterator() ipld.MapIterator {
	end := 1
	if n.fieldOrder.m == schema.Maybe_Absent {
		end = 0
	} else {
		goto done
	}
done:
	return &_StructRepresentation_Tuple__ReprMapItr{n, 0, end}
}

type _StructRepresentation_Tuple__ReprMapItr struct {
	n   *_StructRepresentation_Tuple__Repr
	idx int
	end int
}

func (itr *_StructRepresentation_Tuple__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StructRepresentation_Tuple_FieldOrder_serial
		if itr.n.fieldOrder.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.fieldOrder.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StructRepresentation_Tuple__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StructRepresentation_Tuple__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StructRepresentation_Tuple__Repr) Length() int {
	l := 1
	if rn.fieldOrder.m == schema.Maybe_Absent {
		l--
	}
	return l
}
func (_StructRepresentation_Tuple__Repr) IsAbsent() bool {
	return false
}
func (_StructRepresentation_Tuple__Repr) IsNull() bool {
	return false
}
func (_StructRepresentation_Tuple__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsBool()
}
func (_StructRepresentation_Tuple__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsInt()
}
func (_StructRepresentation_Tuple__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsFloat()
}
func (_StructRepresentation_Tuple__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsString()
}
func (_StructRepresentation_Tuple__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsBytes()
}
func (_StructRepresentation_Tuple__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.StructRepresentation_Tuple.Repr"}.AsLink()
}
func (_StructRepresentation_Tuple__Repr) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Tuple__ReprPrototype{}
}
type _StructRepresentation_Tuple__ReprPrototype struct{}

func (_StructRepresentation_Tuple__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StructRepresentation_Tuple__ReprBuilder
	nb.Reset()
	return &nb
}
type _StructRepresentation_Tuple__ReprBuilder struct {
	_StructRepresentation_Tuple__ReprAssembler
}
func (nb *_StructRepresentation_Tuple__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StructRepresentation_Tuple__ReprBuilder) Reset() {
	var w _StructRepresentation_Tuple
	var m schema.Maybe
	*nb = _StructRepresentation_Tuple__ReprBuilder{_StructRepresentation_Tuple__ReprAssembler{w: &w, m: &m}}
}
type _StructRepresentation_Tuple__ReprAssembler struct {
	w *_StructRepresentation_Tuple
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fieldOrder _List__FieldName__ReprAssembler
	}

func (na *_StructRepresentation_Tuple__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fieldOrder.reset()
}
func (na *_StructRepresentation_Tuple__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StructRepresentation_Tuple{}
	}
	return na, nil
}
func (_StructRepresentation_Tuple__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.BeginList(0)
}
func (na *_StructRepresentation_Tuple__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignBool(false)
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignInt(0)
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignFloat(0)
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignString("")
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignBytes(nil)
}
func (_StructRepresentation_Tuple__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.StructRepresentation_Tuple.Repr"}.AssignLink(nil)
}
func (na *_StructRepresentation_Tuple__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StructRepresentation_Tuple); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.StructRepresentation_Tuple.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StructRepresentation_Tuple__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StructRepresentation_Tuple__ReprPrototype{}
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.fieldOrder.m {
		case schema.Maybe_Value:
			ma.w.fieldOrder.v = ma.ca_fieldOrder.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fieldOrder":
		if ma.s & fieldBit__StructRepresentation_Tuple_FieldOrder != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Tuple_FieldOrder_serial}
		}
		ma.s += fieldBit__StructRepresentation_Tuple_FieldOrder
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		
		return &ma.ca_fieldOrder, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Tuple.Repr", Key:&_String{k}}
	}
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StructRepresentation_Tuple__ReprKeyAssembler)(ma)
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fieldOrder.w = ma.w.fieldOrder.v
		ma.ca_fieldOrder.m = &ma.w.fieldOrder.m
		
		return &ma.ca_fieldOrder
	default:
		panic("unreachable")
	}
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StructRepresentation_Tuple__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StructRepresentation_Tuple__ReprKeyAssembler _StructRepresentation_Tuple__ReprAssembler
func (_StructRepresentation_Tuple__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StructRepresentation_Tuple__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignNull()
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StructRepresentation_Tuple__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fieldOrder":
		if ka.s & fieldBit__StructRepresentation_Tuple_FieldOrder != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StructRepresentation_Tuple_FieldOrder_serial}
		}
		ka.s += fieldBit__StructRepresentation_Tuple_FieldOrder
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.StructRepresentation_Tuple.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.StructRepresentation_Tuple.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StructRepresentation_Tuple__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StructRepresentation_Tuple__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _TypeBool__Maybe struct {
	m schema.Maybe
	v TypeBool
}
type MaybeTypeBool = *_TypeBool__Maybe

func (m MaybeTypeBool) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeBool) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeBool) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeBool) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeBool) Must() TypeBool {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (TypeBool)(&_TypeBool{})
var _ schema.TypedNode = (TypeBool)(&_TypeBool{})
func (TypeBool) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeBool) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeBool) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeBool) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeBool"}.LookupByIndex(0)
}
func (n TypeBool) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeBool) MapIterator() ipld.MapIterator {
	return &_TypeBool__MapItr{n, 0}
}

type _TypeBool__MapItr struct {
	n TypeBool
	idx  int
}

func (itr *_TypeBool__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeBool__MapItr) Done() bool {
	return itr.idx >= 0
}

func (TypeBool) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeBool) Length() int {
	return 0
}
func (TypeBool) IsAbsent() bool {
	return false
}
func (TypeBool) IsNull() bool {
	return false
}
func (TypeBool) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsBool()
}
func (TypeBool) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsInt()
}
func (TypeBool) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsFloat()
}
func (TypeBool) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsString()
}
func (TypeBool) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsBytes()
}
func (TypeBool) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeBool"}.AsLink()
}
func (TypeBool) Prototype() ipld.NodePrototype {
	return _TypeBool__Prototype{}
}
type _TypeBool__Prototype struct{}

func (_TypeBool__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeBool__Builder
	nb.Reset()
	return &nb
}
type _TypeBool__Builder struct {
	_TypeBool__Assembler
}
func (nb *_TypeBool__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeBool__Builder) Reset() {
	var w _TypeBool
	var m schema.Maybe
	*nb = _TypeBool__Builder{_TypeBool__Assembler{w: &w, m: &m}}
}
type _TypeBool__Assembler struct {
	w *_TypeBool
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeBool__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__TypeBool_sufficient = 0
)
func (na *_TypeBool__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeBool{}
	}
	return na, nil
}
func (_TypeBool__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.BeginList(0)
}
func (na *_TypeBool__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeBool__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignBool(false)
}
func (_TypeBool__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignInt(0)
}
func (_TypeBool__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignFloat(0)
}
func (_TypeBool__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignString("")
}
func (_TypeBool__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignBytes(nil)
}
func (_TypeBool__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeBool"}.AssignLink(nil)
}
func (na *_TypeBool__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeBool); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeBool", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeBool__Assembler) Prototype() ipld.NodePrototype {
	return _TypeBool__Prototype{}
}
func (ma *_TypeBool__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBool__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBool", Key:&_String{k}}
	}
}
func (ma *_TypeBool__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeBool__KeyAssembler)(ma)
}
func (ma *_TypeBool__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBool__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeBool__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeBool__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeBool__KeyAssembler _TypeBool__Assembler
func (_TypeBool__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.BeginMap(0)
}
func (_TypeBool__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.BeginList(0)
}
func (na *_TypeBool__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignNull()
}
func (_TypeBool__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignBool(false)
}
func (_TypeBool__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignInt(0)
}
func (_TypeBool__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeBool__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBool", Key:&_String{k}}
	}
	return nil
}
func (_TypeBool__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeBool__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeBool__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeBool__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeBool) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeBool) Representation() ipld.Node {
	return (*_TypeBool__Repr)(n)
}
type _TypeBool__Repr _TypeBool
var (
)
var _ ipld.Node = &_TypeBool__Repr{}
func (_TypeBool__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeBool__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeBool__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeBool__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.LookupByIndex(0)
}
func (n _TypeBool__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeBool__Repr) MapIterator() ipld.MapIterator {
	return &_TypeBool__ReprMapItr{n, 0}
}

type _TypeBool__ReprMapItr struct {
	n   *_TypeBool__Repr
	idx int
	
}

func (itr *_TypeBool__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeBool__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_TypeBool__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeBool__Repr) Length() int {
	l := 0
	return l
}
func (_TypeBool__Repr) IsAbsent() bool {
	return false
}
func (_TypeBool__Repr) IsNull() bool {
	return false
}
func (_TypeBool__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsBool()
}
func (_TypeBool__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsInt()
}
func (_TypeBool__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsFloat()
}
func (_TypeBool__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsString()
}
func (_TypeBool__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsBytes()
}
func (_TypeBool__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeBool.Repr"}.AsLink()
}
func (_TypeBool__Repr) Prototype() ipld.NodePrototype {
	return _TypeBool__ReprPrototype{}
}
type _TypeBool__ReprPrototype struct{}

func (_TypeBool__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeBool__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeBool__ReprBuilder struct {
	_TypeBool__ReprAssembler
}
func (nb *_TypeBool__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeBool__ReprBuilder) Reset() {
	var w _TypeBool
	var m schema.Maybe
	*nb = _TypeBool__ReprBuilder{_TypeBool__ReprAssembler{w: &w, m: &m}}
}
type _TypeBool__ReprAssembler struct {
	w *_TypeBool
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeBool__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_TypeBool__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeBool{}
	}
	return na, nil
}
func (_TypeBool__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.BeginList(0)
}
func (na *_TypeBool__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeBool.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeBool__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignBool(false)
}
func (_TypeBool__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignInt(0)
}
func (_TypeBool__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignFloat(0)
}
func (_TypeBool__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignString("")
}
func (_TypeBool__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignBytes(nil)
}
func (_TypeBool__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeBool.Repr"}.AssignLink(nil)
}
func (na *_TypeBool__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeBool); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeBool.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeBool__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeBool__ReprPrototype{}
}
func (ma *_TypeBool__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBool__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBool.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeBool__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeBool__ReprKeyAssembler)(ma)
}
func (ma *_TypeBool__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBool__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeBool__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeBool__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeBool__ReprKeyAssembler _TypeBool__ReprAssembler
func (_TypeBool__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeBool__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeBool__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeBool__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeBool__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeBool__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeBool__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBool.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeBool__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeBool__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeBool.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeBool__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeBool__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _TypeBytes__Maybe struct {
	m schema.Maybe
	v TypeBytes
}
type MaybeTypeBytes = *_TypeBytes__Maybe

func (m MaybeTypeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeBytes) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeBytes) Must() TypeBytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (TypeBytes)(&_TypeBytes{})
var _ schema.TypedNode = (TypeBytes)(&_TypeBytes{})
func (TypeBytes) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeBytes) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeBytes) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeBytes) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.LookupByIndex(0)
}
func (n TypeBytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeBytes) MapIterator() ipld.MapIterator {
	return &_TypeBytes__MapItr{n, 0}
}

type _TypeBytes__MapItr struct {
	n TypeBytes
	idx  int
}

func (itr *_TypeBytes__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeBytes__MapItr) Done() bool {
	return itr.idx >= 0
}

func (TypeBytes) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeBytes) Length() int {
	return 0
}
func (TypeBytes) IsAbsent() bool {
	return false
}
func (TypeBytes) IsNull() bool {
	return false
}
func (TypeBytes) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsBool()
}
func (TypeBytes) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsInt()
}
func (TypeBytes) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsFloat()
}
func (TypeBytes) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsString()
}
func (TypeBytes) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsBytes()
}
func (TypeBytes) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeBytes"}.AsLink()
}
func (TypeBytes) Prototype() ipld.NodePrototype {
	return _TypeBytes__Prototype{}
}
type _TypeBytes__Prototype struct{}

func (_TypeBytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeBytes__Builder
	nb.Reset()
	return &nb
}
type _TypeBytes__Builder struct {
	_TypeBytes__Assembler
}
func (nb *_TypeBytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeBytes__Builder) Reset() {
	var w _TypeBytes
	var m schema.Maybe
	*nb = _TypeBytes__Builder{_TypeBytes__Assembler{w: &w, m: &m}}
}
type _TypeBytes__Assembler struct {
	w *_TypeBytes
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeBytes__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__TypeBytes_sufficient = 0
)
func (na *_TypeBytes__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeBytes{}
	}
	return na, nil
}
func (_TypeBytes__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.BeginList(0)
}
func (na *_TypeBytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeBytes__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignBool(false)
}
func (_TypeBytes__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignInt(0)
}
func (_TypeBytes__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignFloat(0)
}
func (_TypeBytes__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignString("")
}
func (_TypeBytes__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignBytes(nil)
}
func (_TypeBytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes"}.AssignLink(nil)
}
func (na *_TypeBytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeBytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeBytes", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeBytes__Assembler) Prototype() ipld.NodePrototype {
	return _TypeBytes__Prototype{}
}
func (ma *_TypeBytes__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBytes__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBytes", Key:&_String{k}}
	}
}
func (ma *_TypeBytes__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeBytes__KeyAssembler)(ma)
}
func (ma *_TypeBytes__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBytes__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeBytes__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeBytes__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeBytes__KeyAssembler _TypeBytes__Assembler
func (_TypeBytes__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.BeginMap(0)
}
func (_TypeBytes__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.BeginList(0)
}
func (na *_TypeBytes__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignNull()
}
func (_TypeBytes__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignBool(false)
}
func (_TypeBytes__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignInt(0)
}
func (_TypeBytes__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeBytes__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBytes", Key:&_String{k}}
	}
	return nil
}
func (_TypeBytes__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeBytes__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeBytes__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeBytes__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeBytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeBytes) Representation() ipld.Node {
	return (*_TypeBytes__Repr)(n)
}
type _TypeBytes__Repr _TypeBytes
var (
)
var _ ipld.Node = &_TypeBytes__Repr{}
func (_TypeBytes__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeBytes__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeBytes__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeBytes__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.LookupByIndex(0)
}
func (n _TypeBytes__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeBytes__Repr) MapIterator() ipld.MapIterator {
	return &_TypeBytes__ReprMapItr{n, 0}
}

type _TypeBytes__ReprMapItr struct {
	n   *_TypeBytes__Repr
	idx int
	
}

func (itr *_TypeBytes__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeBytes__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_TypeBytes__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeBytes__Repr) Length() int {
	l := 0
	return l
}
func (_TypeBytes__Repr) IsAbsent() bool {
	return false
}
func (_TypeBytes__Repr) IsNull() bool {
	return false
}
func (_TypeBytes__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsBool()
}
func (_TypeBytes__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsInt()
}
func (_TypeBytes__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsFloat()
}
func (_TypeBytes__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsString()
}
func (_TypeBytes__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsBytes()
}
func (_TypeBytes__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeBytes.Repr"}.AsLink()
}
func (_TypeBytes__Repr) Prototype() ipld.NodePrototype {
	return _TypeBytes__ReprPrototype{}
}
type _TypeBytes__ReprPrototype struct{}

func (_TypeBytes__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeBytes__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeBytes__ReprBuilder struct {
	_TypeBytes__ReprAssembler
}
func (nb *_TypeBytes__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeBytes__ReprBuilder) Reset() {
	var w _TypeBytes
	var m schema.Maybe
	*nb = _TypeBytes__ReprBuilder{_TypeBytes__ReprAssembler{w: &w, m: &m}}
}
type _TypeBytes__ReprAssembler struct {
	w *_TypeBytes
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeBytes__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_TypeBytes__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeBytes{}
	}
	return na, nil
}
func (_TypeBytes__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.BeginList(0)
}
func (na *_TypeBytes__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeBytes.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeBytes__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignBool(false)
}
func (_TypeBytes__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignInt(0)
}
func (_TypeBytes__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignFloat(0)
}
func (_TypeBytes__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignString("")
}
func (_TypeBytes__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignBytes(nil)
}
func (_TypeBytes__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeBytes.Repr"}.AssignLink(nil)
}
func (na *_TypeBytes__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeBytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeBytes.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeBytes__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeBytes__ReprPrototype{}
}
func (ma *_TypeBytes__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBytes__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBytes.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeBytes__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeBytes__ReprKeyAssembler)(ma)
}
func (ma *_TypeBytes__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeBytes__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeBytes__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeBytes__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeBytes__ReprKeyAssembler _TypeBytes__ReprAssembler
func (_TypeBytes__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeBytes__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeBytes__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeBytes__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeBytes__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeBytes__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeBytes__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeBytes.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeBytes__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeBytes__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeBytes.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeBytes__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeBytes__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeCopy) FieldFromType() TypeName {
	return &n.fromType
}
type _TypeCopy__Maybe struct {
	m schema.Maybe
	v TypeCopy
}
type MaybeTypeCopy = *_TypeCopy__Maybe

func (m MaybeTypeCopy) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeCopy) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeCopy) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeCopy) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeCopy) Must() TypeCopy {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeCopy_FromType = _String{"fromType"}
)
var _ ipld.Node = (TypeCopy)(&_TypeCopy{})
var _ schema.TypedNode = (TypeCopy)(&_TypeCopy{})
func (TypeCopy) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeCopy) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fromType":
		return &n.fromType, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeCopy) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeCopy) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.LookupByIndex(0)
}
func (n TypeCopy) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeCopy) MapIterator() ipld.MapIterator {
	return &_TypeCopy__MapItr{n, 0}
}

type _TypeCopy__MapItr struct {
	n TypeCopy
	idx  int
}

func (itr *_TypeCopy__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeCopy_FromType
		v = &itr.n.fromType
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeCopy__MapItr) Done() bool {
	return itr.idx >= 1
}

func (TypeCopy) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeCopy) Length() int {
	return 1
}
func (TypeCopy) IsAbsent() bool {
	return false
}
func (TypeCopy) IsNull() bool {
	return false
}
func (TypeCopy) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsBool()
}
func (TypeCopy) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsInt()
}
func (TypeCopy) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsFloat()
}
func (TypeCopy) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsString()
}
func (TypeCopy) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsBytes()
}
func (TypeCopy) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeCopy"}.AsLink()
}
func (TypeCopy) Prototype() ipld.NodePrototype {
	return _TypeCopy__Prototype{}
}
type _TypeCopy__Prototype struct{}

func (_TypeCopy__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeCopy__Builder
	nb.Reset()
	return &nb
}
type _TypeCopy__Builder struct {
	_TypeCopy__Assembler
}
func (nb *_TypeCopy__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeCopy__Builder) Reset() {
	var w _TypeCopy
	var m schema.Maybe
	*nb = _TypeCopy__Builder{_TypeCopy__Assembler{w: &w, m: &m}}
}
type _TypeCopy__Assembler struct {
	w *_TypeCopy
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fromType _TypeName__Assembler
	}

func (na *_TypeCopy__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fromType.reset()
}

var (
	fieldBit__TypeCopy_FromType = 1 << 0
	fieldBits__TypeCopy_sufficient = 0 + 1 << 0
)
func (na *_TypeCopy__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeCopy{}
	}
	return na, nil
}
func (_TypeCopy__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.BeginList(0)
}
func (na *_TypeCopy__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeCopy__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignBool(false)
}
func (_TypeCopy__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignInt(0)
}
func (_TypeCopy__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignFloat(0)
}
func (_TypeCopy__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignString("")
}
func (_TypeCopy__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignBytes(nil)
}
func (_TypeCopy__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy"}.AssignLink(nil)
}
func (na *_TypeCopy__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeCopy); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeCopy", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeCopy__Assembler) Prototype() ipld.NodePrototype {
	return _TypeCopy__Prototype{}
}
func (ma *_TypeCopy__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_fromType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeCopy__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fromType":
		if ma.s & fieldBit__TypeCopy_FromType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeCopy_FromType}
		}
		ma.s += fieldBit__TypeCopy_FromType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fromType.w = &ma.w.fromType
		ma.ca_fromType.m = &ma.cm
		return &ma.ca_fromType, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeCopy", Key:&_String{k}}
	}
}
func (ma *_TypeCopy__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeCopy__KeyAssembler)(ma)
}
func (ma *_TypeCopy__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fromType.w = &ma.w.fromType
		ma.ca_fromType.m = &ma.cm
		return &ma.ca_fromType
	default:
		panic("unreachable")
	}
}
func (ma *_TypeCopy__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeCopy__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeCopy__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeCopy__KeyAssembler _TypeCopy__Assembler
func (_TypeCopy__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.BeginMap(0)
}
func (_TypeCopy__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.BeginList(0)
}
func (na *_TypeCopy__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignNull()
}
func (_TypeCopy__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignBool(false)
}
func (_TypeCopy__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignInt(0)
}
func (_TypeCopy__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeCopy__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fromType":
		if ka.s & fieldBit__TypeCopy_FromType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeCopy_FromType}
		}
		ka.s += fieldBit__TypeCopy_FromType
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeCopy", Key:&_String{k}}
	}
	return nil
}
func (_TypeCopy__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeCopy__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeCopy__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeCopy__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeCopy) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeCopy) Representation() ipld.Node {
	return (*_TypeCopy__Repr)(n)
}
type _TypeCopy__Repr _TypeCopy
var (
	fieldName__TypeCopy_FromType_serial = _String{"fromType"}
)
var _ ipld.Node = &_TypeCopy__Repr{}
func (_TypeCopy__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeCopy__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fromType":
		return n.fromType.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeCopy__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeCopy__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.LookupByIndex(0)
}
func (n _TypeCopy__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeCopy__Repr) MapIterator() ipld.MapIterator {
	return &_TypeCopy__ReprMapItr{n, 0}
}

type _TypeCopy__ReprMapItr struct {
	n   *_TypeCopy__Repr
	idx int
	
}

func (itr *_TypeCopy__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeCopy_FromType_serial
		v = itr.n.fromType.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeCopy__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_TypeCopy__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeCopy__Repr) Length() int {
	l := 1
	return l
}
func (_TypeCopy__Repr) IsAbsent() bool {
	return false
}
func (_TypeCopy__Repr) IsNull() bool {
	return false
}
func (_TypeCopy__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsBool()
}
func (_TypeCopy__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsInt()
}
func (_TypeCopy__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsFloat()
}
func (_TypeCopy__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsString()
}
func (_TypeCopy__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsBytes()
}
func (_TypeCopy__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeCopy.Repr"}.AsLink()
}
func (_TypeCopy__Repr) Prototype() ipld.NodePrototype {
	return _TypeCopy__ReprPrototype{}
}
type _TypeCopy__ReprPrototype struct{}

func (_TypeCopy__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeCopy__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeCopy__ReprBuilder struct {
	_TypeCopy__ReprAssembler
}
func (nb *_TypeCopy__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeCopy__ReprBuilder) Reset() {
	var w _TypeCopy
	var m schema.Maybe
	*nb = _TypeCopy__ReprBuilder{_TypeCopy__ReprAssembler{w: &w, m: &m}}
}
type _TypeCopy__ReprAssembler struct {
	w *_TypeCopy
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fromType _TypeName__ReprAssembler
	}

func (na *_TypeCopy__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fromType.reset()
}
func (na *_TypeCopy__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeCopy{}
	}
	return na, nil
}
func (_TypeCopy__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.BeginList(0)
}
func (na *_TypeCopy__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeCopy.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeCopy__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignBool(false)
}
func (_TypeCopy__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignInt(0)
}
func (_TypeCopy__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignFloat(0)
}
func (_TypeCopy__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignString("")
}
func (_TypeCopy__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignBytes(nil)
}
func (_TypeCopy__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeCopy.Repr"}.AssignLink(nil)
}
func (na *_TypeCopy__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeCopy); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeCopy.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeCopy__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeCopy__ReprPrototype{}
}
func (ma *_TypeCopy__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeCopy__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fromType":
		if ma.s & fieldBit__TypeCopy_FromType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeCopy_FromType_serial}
		}
		ma.s += fieldBit__TypeCopy_FromType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fromType.w = &ma.w.fromType
		ma.ca_fromType.m = &ma.cm
		return &ma.ca_fromType, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeCopy.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeCopy__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeCopy__ReprKeyAssembler)(ma)
}
func (ma *_TypeCopy__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fromType.w = &ma.w.fromType
		ma.ca_fromType.m = &ma.cm
		return &ma.ca_fromType
	default:
		panic("unreachable")
	}
}
func (ma *_TypeCopy__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeCopy__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeCopy__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeCopy__ReprKeyAssembler _TypeCopy__ReprAssembler
func (_TypeCopy__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeCopy__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeCopy__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeCopy__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeCopy__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeCopy__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeCopy__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fromType":
		if ka.s & fieldBit__TypeCopy_FromType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeCopy_FromType_serial}
		}
		ka.s += fieldBit__TypeCopy_FromType
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeCopy.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeCopy__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeCopy__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeCopy.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeCopy__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeCopy__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TypeDefn) AsInterface() _TypeDefn__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	case 6:
		return &n.x6
	case 7:
		return &n.x7
	case 8:
		return &n.x8
	case 9:
		return &n.x9
	case 10:
		return &n.x10
	case 11:
		return &n.x11
	case 12:
		return &n.x12
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _TypeDefn__Maybe struct {
	m schema.Maybe
	v TypeDefn
}
type MaybeTypeDefn = *_TypeDefn__Maybe

func (m MaybeTypeDefn) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeDefn) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeDefn) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeDefn) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeDefn) Must() TypeDefn {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__TypeDefn_TypeBool = _String{"TypeBool"}
	memberName__TypeDefn_TypeString = _String{"TypeString"}
	memberName__TypeDefn_TypeBytes = _String{"TypeBytes"}
	memberName__TypeDefn_TypeInt = _String{"TypeInt"}
	memberName__TypeDefn_TypeFloat = _String{"TypeFloat"}
	memberName__TypeDefn_TypeMap = _String{"TypeMap"}
	memberName__TypeDefn_TypeList = _String{"TypeList"}
	memberName__TypeDefn_TypeLink = _String{"TypeLink"}
	memberName__TypeDefn_TypeUnion = _String{"TypeUnion"}
	memberName__TypeDefn_TypeStruct = _String{"TypeStruct"}
	memberName__TypeDefn_TypeEnum = _String{"TypeEnum"}
	memberName__TypeDefn_TypeCopy = _String{"TypeCopy"}
)
var _ ipld.Node = (TypeDefn)(&_TypeDefn{})
var _ schema.TypedNode = (TypeDefn)(&_TypeDefn{})
func (TypeDefn) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeDefn) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TypeBool":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "TypeString":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "TypeBytes":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "TypeInt":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "TypeFloat":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	case "TypeMap":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x6, nil
	case "TypeList":
		if n.tag != 7 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x7, nil
	case "TypeLink":
		if n.tag != 8 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x8, nil
	case "TypeUnion":
		if n.tag != 9 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x9, nil
	case "TypeStruct":
		if n.tag != 10 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x10, nil
	case "TypeEnum":
		if n.tag != 11 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x11, nil
	case "TypeCopy":
		if n.tag != 12 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x12, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeDefn) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeDefn) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.LookupByIndex(0)
}
func (n TypeDefn) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeDefn) MapIterator() ipld.MapIterator {
	return &_TypeDefn__MapItr{n, false}
}

type _TypeDefn__MapItr struct {
	n TypeDefn
	done bool
}

func (itr *_TypeDefn__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TypeDefn_TypeBool, &itr.n.x1
	case 2:
		k, v = &memberName__TypeDefn_TypeString, &itr.n.x2
	case 3:
		k, v = &memberName__TypeDefn_TypeBytes, &itr.n.x3
	case 4:
		k, v = &memberName__TypeDefn_TypeInt, &itr.n.x4
	case 5:
		k, v = &memberName__TypeDefn_TypeFloat, &itr.n.x5
	case 6:
		k, v = &memberName__TypeDefn_TypeMap, &itr.n.x6
	case 7:
		k, v = &memberName__TypeDefn_TypeList, &itr.n.x7
	case 8:
		k, v = &memberName__TypeDefn_TypeLink, &itr.n.x8
	case 9:
		k, v = &memberName__TypeDefn_TypeUnion, &itr.n.x9
	case 10:
		k, v = &memberName__TypeDefn_TypeStruct, &itr.n.x10
	case 11:
		k, v = &memberName__TypeDefn_TypeEnum, &itr.n.x11
	case 12:
		k, v = &memberName__TypeDefn_TypeCopy, &itr.n.x12
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TypeDefn__MapItr) Done() bool {
	return itr.done
}

func (TypeDefn) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeDefn) Length() int {
	return 1
}
func (TypeDefn) IsAbsent() bool {
	return false
}
func (TypeDefn) IsNull() bool {
	return false
}
func (TypeDefn) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsBool()
}
func (TypeDefn) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsInt()
}
func (TypeDefn) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsFloat()
}
func (TypeDefn) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsString()
}
func (TypeDefn) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsBytes()
}
func (TypeDefn) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeDefn"}.AsLink()
}
func (TypeDefn) Prototype() ipld.NodePrototype {
	return _TypeDefn__Prototype{}
}
type _TypeDefn__Prototype struct{}

func (_TypeDefn__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeDefn__Builder
	nb.Reset()
	return &nb
}
type _TypeDefn__Builder struct {
	_TypeDefn__Assembler
}
func (nb *_TypeDefn__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeDefn__Builder) Reset() {
	var w _TypeDefn
	var m schema.Maybe
	*nb = _TypeDefn__Builder{_TypeDefn__Assembler{w: &w, m: &m}}
}
type _TypeDefn__Assembler struct {
	w *_TypeDefn
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _TypeBool__Assembler
	
	ca2 _TypeString__Assembler
	
	ca3 _TypeBytes__Assembler
	
	ca4 _TypeInt__Assembler
	
	ca5 _TypeFloat__Assembler
	
	ca6 _TypeMap__Assembler
	
	ca7 _TypeList__Assembler
	
	ca8 _TypeLink__Assembler
	
	ca9 _TypeUnion__Assembler
	
	ca10 _TypeStruct__Assembler
	
	ca11 _TypeEnum__Assembler
	
	ca12 _TypeCopy__Assembler
	ca uint
}
func (na *_TypeDefn__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	
	case 7:
		na.ca7.reset()
	
	case 8:
		na.ca8.reset()
	
	case 9:
		na.ca9.reset()
	
	case 10:
		na.ca10.reset()
	
	case 11:
		na.ca11.reset()
	
	case 12:
		na.ca12.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TypeDefn__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeDefn{}
	}
	return na, nil
}
func (_TypeDefn__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.BeginList(0)
}
func (na *_TypeDefn__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeDefn__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignBool(false)
}
func (_TypeDefn__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignInt(0)
}
func (_TypeDefn__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignFloat(0)
}
func (_TypeDefn__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignString("")
}
func (_TypeDefn__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignBytes(nil)
}
func (_TypeDefn__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn"}.AssignLink(nil)
}
func (na *_TypeDefn__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeDefn); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeDefn", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeDefn__Assembler) Prototype() ipld.NodePrototype {
	return _TypeDefn__Prototype{}
}
func (ma *_TypeDefn__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TypeDefn__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeBool":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "TypeString":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "TypeBytes":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "TypeInt":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "TypeFloat":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "TypeMap":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	case "TypeList":
		ma.state = maState_midValue
		ma.ca = 7
		ma.w.tag = 7
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7, nil
	case "TypeLink":
		ma.state = maState_midValue
		ma.ca = 8
		ma.w.tag = 8
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8, nil
	case "TypeUnion":
		ma.state = maState_midValue
		ma.ca = 9
		ma.w.tag = 9
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9, nil
	case "TypeStruct":
		ma.state = maState_midValue
		ma.ca = 10
		ma.w.tag = 10
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10, nil
	case "TypeEnum":
		ma.state = maState_midValue
		ma.ca = 11
		ma.w.tag = 11
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11, nil
	case "TypeCopy":
		ma.state = maState_midValue
		ma.ca = 12
		ma.w.tag = 12
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefn", Key:&_String{k}}
	}
}
func (ma *_TypeDefn__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeDefn__KeyAssembler)(ma)
}
func (ma *_TypeDefn__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	case 6:
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7
	case 7:
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8
	case 8:
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9
	case 9:
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10
	case 10:
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11
	case 11:
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12
	default:
		panic("unreachable")
	}
}
func (ma *_TypeDefn__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeDefn__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeDefn__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TypeBool":
		return _TypeBool__Prototype{}
	case "TypeString":
		return _TypeString__Prototype{}
	case "TypeBytes":
		return _TypeBytes__Prototype{}
	case "TypeInt":
		return _TypeInt__Prototype{}
	case "TypeFloat":
		return _TypeFloat__Prototype{}
	case "TypeMap":
		return _TypeMap__Prototype{}
	case "TypeList":
		return _TypeList__Prototype{}
	case "TypeLink":
		return _TypeLink__Prototype{}
	case "TypeUnion":
		return _TypeUnion__Prototype{}
	case "TypeStruct":
		return _TypeStruct__Prototype{}
	case "TypeEnum":
		return _TypeEnum__Prototype{}
	case "TypeCopy":
		return _TypeCopy__Prototype{}
	default:
		return nil
	}
}
type _TypeDefn__KeyAssembler _TypeDefn__Assembler
func (_TypeDefn__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.BeginMap(0)
}
func (_TypeDefn__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.BeginList(0)
}
func (na *_TypeDefn__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignNull()
}
func (_TypeDefn__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignBool(false)
}
func (_TypeDefn__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignInt(0)
}
func (_TypeDefn__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeDefn__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeBool":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "TypeString":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "TypeBytes":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "TypeInt":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "TypeFloat":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "TypeMap":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	case "TypeList":
		ka.ca = 7
		ka.w.tag = 7
		ka.state = maState_expectValue
		return nil
	case "TypeLink":
		ka.ca = 8
		ka.w.tag = 8
		ka.state = maState_expectValue
		return nil
	case "TypeUnion":
		ka.ca = 9
		ka.w.tag = 9
		ka.state = maState_expectValue
		return nil
	case "TypeStruct":
		ka.ca = 10
		ka.w.tag = 10
		ka.state = maState_expectValue
		return nil
	case "TypeEnum":
		ka.ca = 11
		ka.w.tag = 11
		ka.state = maState_expectValue
		return nil
	case "TypeCopy":
		ka.ca = 12
		ka.w.tag = 12
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefn", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_TypeDefn__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeDefn__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeDefn__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeDefn__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeDefn) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeDefn) Representation() ipld.Node {
	return (*_TypeDefn__Repr)(n)
}
type _TypeDefn__Repr _TypeDefn
var (
	memberName__TypeDefn_TypeBool_serial = _String{"bool"}
	memberName__TypeDefn_TypeString_serial = _String{"string"}
	memberName__TypeDefn_TypeBytes_serial = _String{"bytes"}
	memberName__TypeDefn_TypeInt_serial = _String{"int"}
	memberName__TypeDefn_TypeFloat_serial = _String{"float"}
	memberName__TypeDefn_TypeMap_serial = _String{"map"}
	memberName__TypeDefn_TypeList_serial = _String{"list"}
	memberName__TypeDefn_TypeLink_serial = _String{"link"}
	memberName__TypeDefn_TypeUnion_serial = _String{"union"}
	memberName__TypeDefn_TypeStruct_serial = _String{"struct"}
	memberName__TypeDefn_TypeEnum_serial = _String{"enum"}
	memberName__TypeDefn_TypeCopy_serial = _String{"copy"}
)
var _ ipld.Node = &_TypeDefn__Repr{}
func (_TypeDefn__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeDefn__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "bool":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "string":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "bytes":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "int":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	case "float":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x5.Representation(), nil
	case "map":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x6.Representation(), nil
	case "list":
		if n.tag != 7 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x7.Representation(), nil
	case "link":
		if n.tag != 8 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x8.Representation(), nil
	case "union":
		if n.tag != 9 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x9.Representation(), nil
	case "struct":
		if n.tag != 10 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x10.Representation(), nil
	case "enum":
		if n.tag != 11 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x11.Representation(), nil
	case "copy":
		if n.tag != 12 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x12.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeDefn__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeDefn__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.LookupByIndex(0)
}
func (n _TypeDefn__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeDefn__Repr) MapIterator() ipld.MapIterator {
	return &_TypeDefn__ReprMapItr{n, false}
}

type _TypeDefn__ReprMapItr struct {
	n *_TypeDefn__Repr
	done bool
}

func (itr *_TypeDefn__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TypeDefn_TypeBool_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__TypeDefn_TypeString_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__TypeDefn_TypeBytes_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__TypeDefn_TypeInt_serial, itr.n.x4.Representation()
	case 5:
		k, v = &memberName__TypeDefn_TypeFloat_serial, itr.n.x5.Representation()
	case 6:
		k, v = &memberName__TypeDefn_TypeMap_serial, itr.n.x6.Representation()
	case 7:
		k, v = &memberName__TypeDefn_TypeList_serial, itr.n.x7.Representation()
	case 8:
		k, v = &memberName__TypeDefn_TypeLink_serial, itr.n.x8.Representation()
	case 9:
		k, v = &memberName__TypeDefn_TypeUnion_serial, itr.n.x9.Representation()
	case 10:
		k, v = &memberName__TypeDefn_TypeStruct_serial, itr.n.x10.Representation()
	case 11:
		k, v = &memberName__TypeDefn_TypeEnum_serial, itr.n.x11.Representation()
	case 12:
		k, v = &memberName__TypeDefn_TypeCopy_serial, itr.n.x12.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TypeDefn__ReprMapItr) Done() bool {
	return itr.done
}

func (_TypeDefn__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_TypeDefn__Repr) Length() int {
	return 1
}
func (_TypeDefn__Repr) IsAbsent() bool {
	return false
}
func (_TypeDefn__Repr) IsNull() bool {
	return false
}
func (_TypeDefn__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsBool()
}
func (_TypeDefn__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsInt()
}
func (_TypeDefn__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsFloat()
}
func (_TypeDefn__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsString()
}
func (_TypeDefn__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsBytes()
}
func (_TypeDefn__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeDefn.Repr"}.AsLink()
}
func (_TypeDefn__Repr) Prototype() ipld.NodePrototype {
	return _TypeDefn__ReprPrototype{}
}
type _TypeDefn__ReprPrototype struct{}

func (_TypeDefn__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeDefn__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeDefn__ReprBuilder struct {
	_TypeDefn__ReprAssembler
}
func (nb *_TypeDefn__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeDefn__ReprBuilder) Reset() {
	var w _TypeDefn
	var m schema.Maybe
	*nb = _TypeDefn__ReprBuilder{_TypeDefn__ReprAssembler{w: &w, m: &m}}
}
type _TypeDefn__ReprAssembler struct {
	w *_TypeDefn
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _TypeBool__ReprAssembler
	
	ca2 _TypeString__ReprAssembler
	
	ca3 _TypeBytes__ReprAssembler
	
	ca4 _TypeInt__ReprAssembler
	
	ca5 _TypeFloat__ReprAssembler
	
	ca6 _TypeMap__ReprAssembler
	
	ca7 _TypeList__ReprAssembler
	
	ca8 _TypeLink__ReprAssembler
	
	ca9 _TypeUnion__ReprAssembler
	
	ca10 _TypeStruct__ReprAssembler
	
	ca11 _TypeEnum__ReprAssembler
	
	ca12 _TypeCopy__ReprAssembler
	ca uint
}
func (na *_TypeDefn__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	
	case 7:
		na.ca7.reset()
	
	case 8:
		na.ca8.reset()
	
	case 9:
		na.ca9.reset()
	
	case 10:
		na.ca10.reset()
	
	case 11:
		na.ca11.reset()
	
	case 12:
		na.ca12.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TypeDefn__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeDefn{}
	}
	return na, nil
}
func (_TypeDefn__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.BeginList(0)
}
func (na *_TypeDefn__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeDefn.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeDefn__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignBool(false)
}
func (_TypeDefn__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignInt(0)
}
func (_TypeDefn__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignFloat(0)
}
func (_TypeDefn__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignString("")
}
func (_TypeDefn__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignBytes(nil)
}
func (_TypeDefn__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeDefn.Repr"}.AssignLink(nil)
}
func (na *_TypeDefn__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeDefn); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeDefn.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeDefn__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeDefn__ReprPrototype{}
}
func (ma *_TypeDefn__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TypeDefn__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "bool":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "string":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "bytes":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "int":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "float":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "map":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	case "list":
		ma.state = maState_midValue
		ma.ca = 7
		ma.w.tag = 7
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7, nil
	case "link":
		ma.state = maState_midValue
		ma.ca = 8
		ma.w.tag = 8
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8, nil
	case "union":
		ma.state = maState_midValue
		ma.ca = 9
		ma.w.tag = 9
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9, nil
	case "struct":
		ma.state = maState_midValue
		ma.ca = 10
		ma.w.tag = 10
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10, nil
	case "enum":
		ma.state = maState_midValue
		ma.ca = 11
		ma.w.tag = 11
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11, nil
	case "copy":
		ma.state = maState_midValue
		ma.ca = 12
		ma.w.tag = 12
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefn.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeDefn__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeDefn__ReprKeyAssembler)(ma)
}
func (ma *_TypeDefn__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	case 6:
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7
	case 7:
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8
	case 8:
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9
	case 9:
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10
	case 10:
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11
	case 11:
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12
	default:
		panic("unreachable")
	}
}
func (ma *_TypeDefn__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeDefn__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeDefn__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TypeBool":
		return _TypeBool__ReprPrototype{}
	case "TypeString":
		return _TypeString__ReprPrototype{}
	case "TypeBytes":
		return _TypeBytes__ReprPrototype{}
	case "TypeInt":
		return _TypeInt__ReprPrototype{}
	case "TypeFloat":
		return _TypeFloat__ReprPrototype{}
	case "TypeMap":
		return _TypeMap__ReprPrototype{}
	case "TypeList":
		return _TypeList__ReprPrototype{}
	case "TypeLink":
		return _TypeLink__ReprPrototype{}
	case "TypeUnion":
		return _TypeUnion__ReprPrototype{}
	case "TypeStruct":
		return _TypeStruct__ReprPrototype{}
	case "TypeEnum":
		return _TypeEnum__ReprPrototype{}
	case "TypeCopy":
		return _TypeCopy__ReprPrototype{}
	default:
		return nil
	}
}
type _TypeDefn__ReprKeyAssembler _TypeDefn__ReprAssembler
func (_TypeDefn__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeDefn__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeDefn__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeDefn__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeDefn__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeDefn__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeDefn__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefn.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "bool":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "string":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "bytes":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "int":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "float":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "map":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	case "list":
		ka.ca = 7
		ka.w.tag = 7
		ka.state = maState_expectValue
		return nil
	case "link":
		ka.ca = 8
		ka.w.tag = 8
		ka.state = maState_expectValue
		return nil
	case "union":
		ka.ca = 9
		ka.w.tag = 9
		ka.state = maState_expectValue
		return nil
	case "struct":
		ka.ca = 10
		ka.w.tag = 10
		ka.state = maState_expectValue
		return nil
	case "enum":
		ka.ca = 11
		ka.w.tag = 11
		ka.state = maState_expectValue
		return nil
	case "copy":
		ka.ca = 12
		ka.w.tag = 12
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefn.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_TypeDefn__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeDefn__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeDefn.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeDefn__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeDefn__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TypeDefnInline) AsInterface() _TypeDefnInline__iface {
	return n.x
}
type _TypeDefnInline__Maybe struct {
	m schema.Maybe
	v TypeDefnInline
}
type MaybeTypeDefnInline = *_TypeDefnInline__Maybe

func (m MaybeTypeDefnInline) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeDefnInline) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeDefnInline) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeDefnInline) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeDefnInline) Must() TypeDefnInline {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__TypeDefnInline_TypeMap = _String{"TypeMap"}
	memberName__TypeDefnInline_TypeList = _String{"TypeList"}
)
var _ ipld.Node = (TypeDefnInline)(&_TypeDefnInline{})
var _ schema.TypedNode = (TypeDefnInline)(&_TypeDefnInline{})
func (TypeDefnInline) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeDefnInline) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TypeMap":
		if n2, ok := n.x.(TypeMap); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "TypeList":
		if n2, ok := n.x.(TypeList); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeDefnInline) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeDefnInline) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.LookupByIndex(0)
}
func (n TypeDefnInline) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeDefnInline) MapIterator() ipld.MapIterator {
	return &_TypeDefnInline__MapItr{n, false}
}

type _TypeDefnInline__MapItr struct {
	n TypeDefnInline
	done bool
}

func (itr *_TypeDefnInline__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch n2 := itr.n.x.(type) {
	case TypeMap:
		k, v = &memberName__TypeDefnInline_TypeMap, n2
	case TypeList:
		k, v = &memberName__TypeDefnInline_TypeList, n2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TypeDefnInline__MapItr) Done() bool {
	return itr.done
}

func (TypeDefnInline) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeDefnInline) Length() int {
	return 1
}
func (TypeDefnInline) IsAbsent() bool {
	return false
}
func (TypeDefnInline) IsNull() bool {
	return false
}
func (TypeDefnInline) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsBool()
}
func (TypeDefnInline) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsInt()
}
func (TypeDefnInline) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsFloat()
}
func (TypeDefnInline) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsString()
}
func (TypeDefnInline) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsBytes()
}
func (TypeDefnInline) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeDefnInline"}.AsLink()
}
func (TypeDefnInline) Prototype() ipld.NodePrototype {
	return _TypeDefnInline__Prototype{}
}
type _TypeDefnInline__Prototype struct{}

func (_TypeDefnInline__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeDefnInline__Builder
	nb.Reset()
	return &nb
}
type _TypeDefnInline__Builder struct {
	_TypeDefnInline__Assembler
}
func (nb *_TypeDefnInline__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeDefnInline__Builder) Reset() {
	var w _TypeDefnInline
	var m schema.Maybe
	*nb = _TypeDefnInline__Builder{_TypeDefnInline__Assembler{w: &w, m: &m}}
}
type _TypeDefnInline__Assembler struct {
	w *_TypeDefnInline
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 *_TypeMap__Assembler
	
	ca2 *_TypeList__Assembler
	ca uint
}
func (na *_TypeDefnInline__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TypeDefnInline__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeDefnInline{}
	}
	return na, nil
}
func (_TypeDefnInline__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.BeginList(0)
}
func (na *_TypeDefnInline__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeDefnInline__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignBool(false)
}
func (_TypeDefnInline__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignInt(0)
}
func (_TypeDefnInline__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignFloat(0)
}
func (_TypeDefnInline__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignString("")
}
func (_TypeDefnInline__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignBytes(nil)
}
func (_TypeDefnInline__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline"}.AssignLink(nil)
}
func (na *_TypeDefnInline__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeDefnInline); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeDefnInline", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeDefnInline__Assembler) Prototype() ipld.NodePrototype {
	return _TypeDefnInline__Prototype{}
}
func (ma *_TypeDefnInline__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TypeDefnInline__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeMap":
		ma.state = maState_midValue
		ma.ca = 1
		x := &_TypeMap{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_TypeMap__Assembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1, nil
	case "TypeList":
		ma.state = maState_midValue
		ma.ca = 2
		x := &_TypeList{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_TypeList__Assembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefnInline", Key:&_String{k}}
	}
}
func (ma *_TypeDefnInline__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeDefnInline__KeyAssembler)(ma)
}
func (ma *_TypeDefnInline__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		x := &_TypeMap{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_TypeMap__Assembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1
	case 1:
		x := &_TypeList{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_TypeList__Assembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_TypeDefnInline__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeDefnInline__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeDefnInline__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TypeMap":
		return _TypeMap__Prototype{}
	case "TypeList":
		return _TypeList__Prototype{}
	default:
		return nil
	}
}
type _TypeDefnInline__KeyAssembler _TypeDefnInline__Assembler
func (_TypeDefnInline__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.BeginMap(0)
}
func (_TypeDefnInline__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.BeginList(0)
}
func (na *_TypeDefnInline__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignNull()
}
func (_TypeDefnInline__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignBool(false)
}
func (_TypeDefnInline__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignInt(0)
}
func (_TypeDefnInline__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeDefnInline__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeMap":
		ka.ca = 1
		ka.state = maState_expectValue
		return nil
	case "TypeList":
		ka.ca = 2
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefnInline", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_TypeDefnInline__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeDefnInline__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeDefnInline__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeDefnInline__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeDefnInline) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeDefnInline) Representation() ipld.Node {
	return (*_TypeDefnInline__Repr)(n)
}
type _TypeDefnInline__Repr _TypeDefnInline
var (
	memberName__TypeDefnInline_TypeMap_serial = _String{"map"}
	memberName__TypeDefnInline_TypeList_serial = _String{"list"}
)
var _ ipld.Node = &_TypeDefnInline__Repr{}
func (_TypeDefnInline__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeDefnInline__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "map":
		if n2, ok := n.x.(TypeMap); ok {
			return n2.Representation(), nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "list":
		if n2, ok := n.x.(TypeList); ok {
			return n2.Representation(), nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeDefnInline__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeDefnInline__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.LookupByIndex(0)
}
func (n _TypeDefnInline__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeDefnInline__Repr) MapIterator() ipld.MapIterator {
	return &_TypeDefnInline__ReprMapItr{n, false}
}

type _TypeDefnInline__ReprMapItr struct {
	n *_TypeDefnInline__Repr
	done bool
}

func (itr *_TypeDefnInline__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch n2 := itr.n.x.(type) {
	case TypeMap:
		k, v = &memberName__TypeDefnInline_TypeMap_serial, n2.Representation()
	case TypeList:
		k, v = &memberName__TypeDefnInline_TypeList_serial, n2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TypeDefnInline__ReprMapItr) Done() bool {
	return itr.done
}

func (_TypeDefnInline__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_TypeDefnInline__Repr) Length() int {
	return 1
}
func (_TypeDefnInline__Repr) IsAbsent() bool {
	return false
}
func (_TypeDefnInline__Repr) IsNull() bool {
	return false
}
func (_TypeDefnInline__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsBool()
}
func (_TypeDefnInline__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsInt()
}
func (_TypeDefnInline__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsFloat()
}
func (_TypeDefnInline__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsString()
}
func (_TypeDefnInline__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsBytes()
}
func (_TypeDefnInline__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeDefnInline.Repr"}.AsLink()
}
func (_TypeDefnInline__Repr) Prototype() ipld.NodePrototype {
	return _TypeDefnInline__ReprPrototype{}
}
type _TypeDefnInline__ReprPrototype struct{}

func (_TypeDefnInline__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeDefnInline__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeDefnInline__ReprBuilder struct {
	_TypeDefnInline__ReprAssembler
}
func (nb *_TypeDefnInline__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeDefnInline__ReprBuilder) Reset() {
	var w _TypeDefnInline
	var m schema.Maybe
	*nb = _TypeDefnInline__ReprBuilder{_TypeDefnInline__ReprAssembler{w: &w, m: &m}}
}
type _TypeDefnInline__ReprAssembler struct {
	w *_TypeDefnInline
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 *_TypeMap__ReprAssembler
	
	ca2 *_TypeList__ReprAssembler
	ca uint
}
func (na *_TypeDefnInline__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TypeDefnInline__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeDefnInline{}
	}
	return na, nil
}
func (_TypeDefnInline__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.BeginList(0)
}
func (na *_TypeDefnInline__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeDefnInline__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignBool(false)
}
func (_TypeDefnInline__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignInt(0)
}
func (_TypeDefnInline__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignFloat(0)
}
func (_TypeDefnInline__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignString("")
}
func (_TypeDefnInline__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignBytes(nil)
}
func (_TypeDefnInline__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeDefnInline.Repr"}.AssignLink(nil)
}
func (na *_TypeDefnInline__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeDefnInline); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeDefnInline.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeDefnInline__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeDefnInline__ReprPrototype{}
}
func (ma *_TypeDefnInline__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TypeDefnInline__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ma.state = maState_midValue
		ma.ca = 1
		x := &_TypeMap{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_TypeMap__ReprAssembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1, nil
	case "list":
		ma.state = maState_midValue
		ma.ca = 2
		x := &_TypeList{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_TypeList__ReprAssembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefnInline.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeDefnInline__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeDefnInline__ReprKeyAssembler)(ma)
}
func (ma *_TypeDefnInline__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		x := &_TypeMap{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_TypeMap__ReprAssembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1
	case 1:
		x := &_TypeList{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_TypeList__ReprAssembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_TypeDefnInline__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeDefnInline__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeDefnInline__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TypeMap":
		return _TypeMap__ReprPrototype{}
	case "TypeList":
		return _TypeList__ReprPrototype{}
	default:
		return nil
	}
}
type _TypeDefnInline__ReprKeyAssembler _TypeDefnInline__ReprAssembler
func (_TypeDefnInline__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeDefnInline__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeDefnInline__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeDefnInline__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeDefnInline__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeDefnInline__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeDefnInline__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeDefnInline.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "map":
		ka.ca = 1
		ka.state = maState_expectValue
		return nil
	case "list":
		ka.ca = 2
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeDefnInline.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_TypeDefnInline__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeDefnInline__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeDefnInline.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeDefnInline__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeDefnInline__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeEnum) FieldMembers() Map__EnumValue__Unit {
	return &n.members
}
func (n _TypeEnum) FieldRepresentation() EnumRepresentation {
	return &n.representation
}
type _TypeEnum__Maybe struct {
	m schema.Maybe
	v TypeEnum
}
type MaybeTypeEnum = *_TypeEnum__Maybe

func (m MaybeTypeEnum) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeEnum) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeEnum) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeEnum) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeEnum) Must() TypeEnum {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeEnum_Members = _String{"members"}
	fieldName__TypeEnum_Representation = _String{"representation"}
)
var _ ipld.Node = (TypeEnum)(&_TypeEnum{})
var _ schema.TypedNode = (TypeEnum)(&_TypeEnum{})
func (TypeEnum) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeEnum) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "members":
		return &n.members, nil
	case "representation":
		return &n.representation, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeEnum) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeEnum) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.LookupByIndex(0)
}
func (n TypeEnum) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeEnum) MapIterator() ipld.MapIterator {
	return &_TypeEnum__MapItr{n, 0}
}

type _TypeEnum__MapItr struct {
	n TypeEnum
	idx  int
}

func (itr *_TypeEnum__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeEnum_Members
		v = &itr.n.members
	case 1:
		k = &fieldName__TypeEnum_Representation
		v = &itr.n.representation
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeEnum__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TypeEnum) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeEnum) Length() int {
	return 2
}
func (TypeEnum) IsAbsent() bool {
	return false
}
func (TypeEnum) IsNull() bool {
	return false
}
func (TypeEnum) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsBool()
}
func (TypeEnum) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsInt()
}
func (TypeEnum) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsFloat()
}
func (TypeEnum) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsString()
}
func (TypeEnum) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsBytes()
}
func (TypeEnum) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeEnum"}.AsLink()
}
func (TypeEnum) Prototype() ipld.NodePrototype {
	return _TypeEnum__Prototype{}
}
type _TypeEnum__Prototype struct{}

func (_TypeEnum__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeEnum__Builder
	nb.Reset()
	return &nb
}
type _TypeEnum__Builder struct {
	_TypeEnum__Assembler
}
func (nb *_TypeEnum__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeEnum__Builder) Reset() {
	var w _TypeEnum
	var m schema.Maybe
	*nb = _TypeEnum__Builder{_TypeEnum__Assembler{w: &w, m: &m}}
}
type _TypeEnum__Assembler struct {
	w *_TypeEnum
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_members _Map__EnumValue__Unit__Assembler
	ca_representation _EnumRepresentation__Assembler
	}

func (na *_TypeEnum__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_members.reset()
	na.ca_representation.reset()
}

var (
	fieldBit__TypeEnum_Members = 1 << 0
	fieldBit__TypeEnum_Representation = 1 << 1
	fieldBits__TypeEnum_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_TypeEnum__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeEnum{}
	}
	return na, nil
}
func (_TypeEnum__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.BeginList(0)
}
func (na *_TypeEnum__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeEnum__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignBool(false)
}
func (_TypeEnum__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignInt(0)
}
func (_TypeEnum__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignFloat(0)
}
func (_TypeEnum__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignString("")
}
func (_TypeEnum__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignBytes(nil)
}
func (_TypeEnum__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum"}.AssignLink(nil)
}
func (na *_TypeEnum__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeEnum); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeEnum", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeEnum__Assembler) Prototype() ipld.NodePrototype {
	return _TypeEnum__Prototype{}
}
func (ma *_TypeEnum__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_members.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_representation.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeEnum__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "members":
		if ma.s & fieldBit__TypeEnum_Members != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Members}
		}
		ma.s += fieldBit__TypeEnum_Members
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members, nil
	case "representation":
		if ma.s & fieldBit__TypeEnum_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Representation}
		}
		ma.s += fieldBit__TypeEnum_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeEnum", Key:&_String{k}}
	}
}
func (ma *_TypeEnum__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeEnum__KeyAssembler)(ma)
}
func (ma *_TypeEnum__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeEnum__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeEnum__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeEnum__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeEnum__KeyAssembler _TypeEnum__Assembler
func (_TypeEnum__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.BeginMap(0)
}
func (_TypeEnum__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.BeginList(0)
}
func (na *_TypeEnum__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignNull()
}
func (_TypeEnum__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignBool(false)
}
func (_TypeEnum__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignInt(0)
}
func (_TypeEnum__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeEnum__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "members":
		if ka.s & fieldBit__TypeEnum_Members != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Members}
		}
		ka.s += fieldBit__TypeEnum_Members
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeEnum_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Representation}
		}
		ka.s += fieldBit__TypeEnum_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeEnum", Key:&_String{k}}
	}
	return nil
}
func (_TypeEnum__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeEnum__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeEnum__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeEnum__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeEnum) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeEnum) Representation() ipld.Node {
	return (*_TypeEnum__Repr)(n)
}
type _TypeEnum__Repr _TypeEnum
var (
	fieldName__TypeEnum_Members_serial = _String{"members"}
	fieldName__TypeEnum_Representation_serial = _String{"representation"}
)
var _ ipld.Node = &_TypeEnum__Repr{}
func (_TypeEnum__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeEnum__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "members":
		return n.members.Representation(), nil
	case "representation":
		return n.representation.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeEnum__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeEnum__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.LookupByIndex(0)
}
func (n _TypeEnum__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeEnum__Repr) MapIterator() ipld.MapIterator {
	return &_TypeEnum__ReprMapItr{n, 0}
}

type _TypeEnum__ReprMapItr struct {
	n   *_TypeEnum__Repr
	idx int
	
}

func (itr *_TypeEnum__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeEnum_Members_serial
		v = itr.n.members.Representation()
	case 1:
		k = &fieldName__TypeEnum_Representation_serial
		v = itr.n.representation.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeEnum__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TypeEnum__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeEnum__Repr) Length() int {
	l := 2
	return l
}
func (_TypeEnum__Repr) IsAbsent() bool {
	return false
}
func (_TypeEnum__Repr) IsNull() bool {
	return false
}
func (_TypeEnum__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsBool()
}
func (_TypeEnum__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsInt()
}
func (_TypeEnum__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsFloat()
}
func (_TypeEnum__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsString()
}
func (_TypeEnum__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsBytes()
}
func (_TypeEnum__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeEnum.Repr"}.AsLink()
}
func (_TypeEnum__Repr) Prototype() ipld.NodePrototype {
	return _TypeEnum__ReprPrototype{}
}
type _TypeEnum__ReprPrototype struct{}

func (_TypeEnum__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeEnum__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeEnum__ReprBuilder struct {
	_TypeEnum__ReprAssembler
}
func (nb *_TypeEnum__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeEnum__ReprBuilder) Reset() {
	var w _TypeEnum
	var m schema.Maybe
	*nb = _TypeEnum__ReprBuilder{_TypeEnum__ReprAssembler{w: &w, m: &m}}
}
type _TypeEnum__ReprAssembler struct {
	w *_TypeEnum
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_members _Map__EnumValue__Unit__ReprAssembler
	ca_representation _EnumRepresentation__ReprAssembler
	}

func (na *_TypeEnum__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_members.reset()
	na.ca_representation.reset()
}
func (na *_TypeEnum__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeEnum{}
	}
	return na, nil
}
func (_TypeEnum__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.BeginList(0)
}
func (na *_TypeEnum__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeEnum.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeEnum__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignBool(false)
}
func (_TypeEnum__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignInt(0)
}
func (_TypeEnum__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignFloat(0)
}
func (_TypeEnum__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignString("")
}
func (_TypeEnum__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignBytes(nil)
}
func (_TypeEnum__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeEnum.Repr"}.AssignLink(nil)
}
func (na *_TypeEnum__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeEnum); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeEnum.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeEnum__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeEnum__ReprPrototype{}
}
func (ma *_TypeEnum__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeEnum__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "members":
		if ma.s & fieldBit__TypeEnum_Members != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Members_serial}
		}
		ma.s += fieldBit__TypeEnum_Members
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members, nil
	case "representation":
		if ma.s & fieldBit__TypeEnum_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Representation_serial}
		}
		ma.s += fieldBit__TypeEnum_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeEnum.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeEnum__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeEnum__ReprKeyAssembler)(ma)
}
func (ma *_TypeEnum__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeEnum__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeEnum__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeEnum__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeEnum__ReprKeyAssembler _TypeEnum__ReprAssembler
func (_TypeEnum__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeEnum__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeEnum__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeEnum__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeEnum__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeEnum__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeEnum__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "members":
		if ka.s & fieldBit__TypeEnum_Members != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Members_serial}
		}
		ka.s += fieldBit__TypeEnum_Members
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeEnum_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeEnum_Representation_serial}
		}
		ka.s += fieldBit__TypeEnum_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeEnum.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeEnum__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeEnum__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeEnum.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeEnum__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeEnum__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _TypeFloat__Maybe struct {
	m schema.Maybe
	v TypeFloat
}
type MaybeTypeFloat = *_TypeFloat__Maybe

func (m MaybeTypeFloat) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeFloat) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeFloat) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeFloat) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeFloat) Must() TypeFloat {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (TypeFloat)(&_TypeFloat{})
var _ schema.TypedNode = (TypeFloat)(&_TypeFloat{})
func (TypeFloat) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeFloat) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeFloat) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeFloat) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.LookupByIndex(0)
}
func (n TypeFloat) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeFloat) MapIterator() ipld.MapIterator {
	return &_TypeFloat__MapItr{n, 0}
}

type _TypeFloat__MapItr struct {
	n TypeFloat
	idx  int
}

func (itr *_TypeFloat__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeFloat__MapItr) Done() bool {
	return itr.idx >= 0
}

func (TypeFloat) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeFloat) Length() int {
	return 0
}
func (TypeFloat) IsAbsent() bool {
	return false
}
func (TypeFloat) IsNull() bool {
	return false
}
func (TypeFloat) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsBool()
}
func (TypeFloat) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsInt()
}
func (TypeFloat) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsFloat()
}
func (TypeFloat) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsString()
}
func (TypeFloat) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsBytes()
}
func (TypeFloat) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeFloat"}.AsLink()
}
func (TypeFloat) Prototype() ipld.NodePrototype {
	return _TypeFloat__Prototype{}
}
type _TypeFloat__Prototype struct{}

func (_TypeFloat__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeFloat__Builder
	nb.Reset()
	return &nb
}
type _TypeFloat__Builder struct {
	_TypeFloat__Assembler
}
func (nb *_TypeFloat__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeFloat__Builder) Reset() {
	var w _TypeFloat
	var m schema.Maybe
	*nb = _TypeFloat__Builder{_TypeFloat__Assembler{w: &w, m: &m}}
}
type _TypeFloat__Assembler struct {
	w *_TypeFloat
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeFloat__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__TypeFloat_sufficient = 0
)
func (na *_TypeFloat__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeFloat{}
	}
	return na, nil
}
func (_TypeFloat__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.BeginList(0)
}
func (na *_TypeFloat__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeFloat__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignBool(false)
}
func (_TypeFloat__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignInt(0)
}
func (_TypeFloat__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignFloat(0)
}
func (_TypeFloat__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignString("")
}
func (_TypeFloat__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignBytes(nil)
}
func (_TypeFloat__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat"}.AssignLink(nil)
}
func (na *_TypeFloat__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeFloat); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeFloat", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeFloat__Assembler) Prototype() ipld.NodePrototype {
	return _TypeFloat__Prototype{}
}
func (ma *_TypeFloat__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeFloat__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeFloat", Key:&_String{k}}
	}
}
func (ma *_TypeFloat__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeFloat__KeyAssembler)(ma)
}
func (ma *_TypeFloat__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeFloat__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeFloat__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeFloat__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeFloat__KeyAssembler _TypeFloat__Assembler
func (_TypeFloat__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.BeginMap(0)
}
func (_TypeFloat__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.BeginList(0)
}
func (na *_TypeFloat__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignNull()
}
func (_TypeFloat__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignBool(false)
}
func (_TypeFloat__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignInt(0)
}
func (_TypeFloat__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeFloat__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeFloat", Key:&_String{k}}
	}
	return nil
}
func (_TypeFloat__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeFloat__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeFloat__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeFloat__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeFloat) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeFloat) Representation() ipld.Node {
	return (*_TypeFloat__Repr)(n)
}
type _TypeFloat__Repr _TypeFloat
var (
)
var _ ipld.Node = &_TypeFloat__Repr{}
func (_TypeFloat__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeFloat__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeFloat__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeFloat__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.LookupByIndex(0)
}
func (n _TypeFloat__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeFloat__Repr) MapIterator() ipld.MapIterator {
	return &_TypeFloat__ReprMapItr{n, 0}
}

type _TypeFloat__ReprMapItr struct {
	n   *_TypeFloat__Repr
	idx int
	
}

func (itr *_TypeFloat__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeFloat__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_TypeFloat__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeFloat__Repr) Length() int {
	l := 0
	return l
}
func (_TypeFloat__Repr) IsAbsent() bool {
	return false
}
func (_TypeFloat__Repr) IsNull() bool {
	return false
}
func (_TypeFloat__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsBool()
}
func (_TypeFloat__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsInt()
}
func (_TypeFloat__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsFloat()
}
func (_TypeFloat__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsString()
}
func (_TypeFloat__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsBytes()
}
func (_TypeFloat__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeFloat.Repr"}.AsLink()
}
func (_TypeFloat__Repr) Prototype() ipld.NodePrototype {
	return _TypeFloat__ReprPrototype{}
}
type _TypeFloat__ReprPrototype struct{}

func (_TypeFloat__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeFloat__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeFloat__ReprBuilder struct {
	_TypeFloat__ReprAssembler
}
func (nb *_TypeFloat__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeFloat__ReprBuilder) Reset() {
	var w _TypeFloat
	var m schema.Maybe
	*nb = _TypeFloat__ReprBuilder{_TypeFloat__ReprAssembler{w: &w, m: &m}}
}
type _TypeFloat__ReprAssembler struct {
	w *_TypeFloat
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeFloat__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_TypeFloat__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeFloat{}
	}
	return na, nil
}
func (_TypeFloat__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.BeginList(0)
}
func (na *_TypeFloat__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeFloat.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeFloat__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignBool(false)
}
func (_TypeFloat__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignInt(0)
}
func (_TypeFloat__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignFloat(0)
}
func (_TypeFloat__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignString("")
}
func (_TypeFloat__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignBytes(nil)
}
func (_TypeFloat__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeFloat.Repr"}.AssignLink(nil)
}
func (na *_TypeFloat__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeFloat); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeFloat.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeFloat__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeFloat__ReprPrototype{}
}
func (ma *_TypeFloat__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeFloat__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeFloat.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeFloat__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeFloat__ReprKeyAssembler)(ma)
}
func (ma *_TypeFloat__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeFloat__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeFloat__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeFloat__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeFloat__ReprKeyAssembler _TypeFloat__ReprAssembler
func (_TypeFloat__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeFloat__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeFloat__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeFloat__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeFloat__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeFloat__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeFloat__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeFloat.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeFloat__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeFloat__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeFloat.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeFloat__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeFloat__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _TypeInt__Maybe struct {
	m schema.Maybe
	v TypeInt
}
type MaybeTypeInt = *_TypeInt__Maybe

func (m MaybeTypeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeInt) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeInt) Must() TypeInt {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (TypeInt)(&_TypeInt{})
var _ schema.TypedNode = (TypeInt)(&_TypeInt{})
func (TypeInt) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeInt) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeInt) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeInt) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeInt"}.LookupByIndex(0)
}
func (n TypeInt) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeInt) MapIterator() ipld.MapIterator {
	return &_TypeInt__MapItr{n, 0}
}

type _TypeInt__MapItr struct {
	n TypeInt
	idx  int
}

func (itr *_TypeInt__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeInt__MapItr) Done() bool {
	return itr.idx >= 0
}

func (TypeInt) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeInt) Length() int {
	return 0
}
func (TypeInt) IsAbsent() bool {
	return false
}
func (TypeInt) IsNull() bool {
	return false
}
func (TypeInt) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsBool()
}
func (TypeInt) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsInt()
}
func (TypeInt) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsFloat()
}
func (TypeInt) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsString()
}
func (TypeInt) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsBytes()
}
func (TypeInt) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeInt"}.AsLink()
}
func (TypeInt) Prototype() ipld.NodePrototype {
	return _TypeInt__Prototype{}
}
type _TypeInt__Prototype struct{}

func (_TypeInt__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeInt__Builder
	nb.Reset()
	return &nb
}
type _TypeInt__Builder struct {
	_TypeInt__Assembler
}
func (nb *_TypeInt__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeInt__Builder) Reset() {
	var w _TypeInt
	var m schema.Maybe
	*nb = _TypeInt__Builder{_TypeInt__Assembler{w: &w, m: &m}}
}
type _TypeInt__Assembler struct {
	w *_TypeInt
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeInt__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__TypeInt_sufficient = 0
)
func (na *_TypeInt__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeInt{}
	}
	return na, nil
}
func (_TypeInt__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.BeginList(0)
}
func (na *_TypeInt__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeInt__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignBool(false)
}
func (_TypeInt__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignInt(0)
}
func (_TypeInt__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignFloat(0)
}
func (_TypeInt__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignString("")
}
func (_TypeInt__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignBytes(nil)
}
func (_TypeInt__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeInt"}.AssignLink(nil)
}
func (na *_TypeInt__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeInt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeInt", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeInt__Assembler) Prototype() ipld.NodePrototype {
	return _TypeInt__Prototype{}
}
func (ma *_TypeInt__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeInt__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeInt", Key:&_String{k}}
	}
}
func (ma *_TypeInt__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeInt__KeyAssembler)(ma)
}
func (ma *_TypeInt__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeInt__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeInt__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeInt__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeInt__KeyAssembler _TypeInt__Assembler
func (_TypeInt__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.BeginMap(0)
}
func (_TypeInt__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.BeginList(0)
}
func (na *_TypeInt__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignNull()
}
func (_TypeInt__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignBool(false)
}
func (_TypeInt__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignInt(0)
}
func (_TypeInt__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeInt__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeInt", Key:&_String{k}}
	}
	return nil
}
func (_TypeInt__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeInt__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeInt__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeInt__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeInt) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeInt) Representation() ipld.Node {
	return (*_TypeInt__Repr)(n)
}
type _TypeInt__Repr _TypeInt
var (
)
var _ ipld.Node = &_TypeInt__Repr{}
func (_TypeInt__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeInt__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeInt__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeInt__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.LookupByIndex(0)
}
func (n _TypeInt__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeInt__Repr) MapIterator() ipld.MapIterator {
	return &_TypeInt__ReprMapItr{n, 0}
}

type _TypeInt__ReprMapItr struct {
	n   *_TypeInt__Repr
	idx int
	
}

func (itr *_TypeInt__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeInt__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_TypeInt__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeInt__Repr) Length() int {
	l := 0
	return l
}
func (_TypeInt__Repr) IsAbsent() bool {
	return false
}
func (_TypeInt__Repr) IsNull() bool {
	return false
}
func (_TypeInt__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsBool()
}
func (_TypeInt__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsInt()
}
func (_TypeInt__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsFloat()
}
func (_TypeInt__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsString()
}
func (_TypeInt__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsBytes()
}
func (_TypeInt__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeInt.Repr"}.AsLink()
}
func (_TypeInt__Repr) Prototype() ipld.NodePrototype {
	return _TypeInt__ReprPrototype{}
}
type _TypeInt__ReprPrototype struct{}

func (_TypeInt__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeInt__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeInt__ReprBuilder struct {
	_TypeInt__ReprAssembler
}
func (nb *_TypeInt__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeInt__ReprBuilder) Reset() {
	var w _TypeInt
	var m schema.Maybe
	*nb = _TypeInt__ReprBuilder{_TypeInt__ReprAssembler{w: &w, m: &m}}
}
type _TypeInt__ReprAssembler struct {
	w *_TypeInt
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeInt__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_TypeInt__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeInt{}
	}
	return na, nil
}
func (_TypeInt__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.BeginList(0)
}
func (na *_TypeInt__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeInt.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeInt__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignBool(false)
}
func (_TypeInt__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignInt(0)
}
func (_TypeInt__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignFloat(0)
}
func (_TypeInt__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignString("")
}
func (_TypeInt__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignBytes(nil)
}
func (_TypeInt__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeInt.Repr"}.AssignLink(nil)
}
func (na *_TypeInt__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeInt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeInt.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeInt__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeInt__ReprPrototype{}
}
func (ma *_TypeInt__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeInt__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeInt.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeInt__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeInt__ReprKeyAssembler)(ma)
}
func (ma *_TypeInt__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeInt__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeInt__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeInt__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeInt__ReprKeyAssembler _TypeInt__ReprAssembler
func (_TypeInt__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeInt__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeInt__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeInt__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeInt__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeInt__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeInt__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeInt.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeInt__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeInt__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeInt.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeInt__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeInt__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeLink) FieldExpectedType() MaybeTypeName {
	return &n.expectedType
}
type _TypeLink__Maybe struct {
	m schema.Maybe
	v TypeLink
}
type MaybeTypeLink = *_TypeLink__Maybe

func (m MaybeTypeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeLink) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeLink) Must() TypeLink {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeLink_ExpectedType = _String{"expectedType"}
)
var _ ipld.Node = (TypeLink)(&_TypeLink{})
var _ schema.TypedNode = (TypeLink)(&_TypeLink{})
func (TypeLink) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeLink) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "expectedType":
		if n.expectedType.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.expectedType.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeLink) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeLink) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeLink"}.LookupByIndex(0)
}
func (n TypeLink) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeLink) MapIterator() ipld.MapIterator {
	return &_TypeLink__MapItr{n, 0}
}

type _TypeLink__MapItr struct {
	n TypeLink
	idx  int
}

func (itr *_TypeLink__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeLink_ExpectedType
		if itr.n.expectedType.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.expectedType.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeLink__MapItr) Done() bool {
	return itr.idx >= 1
}

func (TypeLink) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeLink) Length() int {
	return 1
}
func (TypeLink) IsAbsent() bool {
	return false
}
func (TypeLink) IsNull() bool {
	return false
}
func (TypeLink) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsBool()
}
func (TypeLink) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsInt()
}
func (TypeLink) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsFloat()
}
func (TypeLink) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsString()
}
func (TypeLink) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsBytes()
}
func (TypeLink) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeLink"}.AsLink()
}
func (TypeLink) Prototype() ipld.NodePrototype {
	return _TypeLink__Prototype{}
}
type _TypeLink__Prototype struct{}

func (_TypeLink__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeLink__Builder
	nb.Reset()
	return &nb
}
type _TypeLink__Builder struct {
	_TypeLink__Assembler
}
func (nb *_TypeLink__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeLink__Builder) Reset() {
	var w _TypeLink
	var m schema.Maybe
	*nb = _TypeLink__Builder{_TypeLink__Assembler{w: &w, m: &m}}
}
type _TypeLink__Assembler struct {
	w *_TypeLink
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_expectedType _TypeName__Assembler
	}

func (na *_TypeLink__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_expectedType.reset()
}

var (
	fieldBit__TypeLink_ExpectedType = 1 << 0
	fieldBits__TypeLink_sufficient = 0
)
func (na *_TypeLink__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeLink{}
	}
	return na, nil
}
func (_TypeLink__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.BeginList(0)
}
func (na *_TypeLink__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeLink__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignBool(false)
}
func (_TypeLink__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignInt(0)
}
func (_TypeLink__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignFloat(0)
}
func (_TypeLink__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignString("")
}
func (_TypeLink__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignBytes(nil)
}
func (_TypeLink__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeLink"}.AssignLink(nil)
}
func (na *_TypeLink__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeLink); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeLink", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeLink__Assembler) Prototype() ipld.NodePrototype {
	return _TypeLink__Prototype{}
}
func (ma *_TypeLink__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.expectedType.m {
		case schema.Maybe_Value:
			ma.w.expectedType.v = ma.ca_expectedType.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeLink__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "expectedType":
		if ma.s & fieldBit__TypeLink_ExpectedType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeLink_ExpectedType}
		}
		ma.s += fieldBit__TypeLink_ExpectedType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_expectedType.w = ma.w.expectedType.v
		ma.ca_expectedType.m = &ma.w.expectedType.m
		return &ma.ca_expectedType, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeLink", Key:&_String{k}}
	}
}
func (ma *_TypeLink__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeLink__KeyAssembler)(ma)
}
func (ma *_TypeLink__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_expectedType.w = ma.w.expectedType.v
		ma.ca_expectedType.m = &ma.w.expectedType.m
		return &ma.ca_expectedType
	default:
		panic("unreachable")
	}
}
func (ma *_TypeLink__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeLink__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeLink__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeLink__KeyAssembler _TypeLink__Assembler
func (_TypeLink__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.BeginMap(0)
}
func (_TypeLink__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.BeginList(0)
}
func (na *_TypeLink__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignNull()
}
func (_TypeLink__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignBool(false)
}
func (_TypeLink__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignInt(0)
}
func (_TypeLink__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeLink__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "expectedType":
		if ka.s & fieldBit__TypeLink_ExpectedType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeLink_ExpectedType}
		}
		ka.s += fieldBit__TypeLink_ExpectedType
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeLink", Key:&_String{k}}
	}
	return nil
}
func (_TypeLink__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeLink__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeLink__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeLink__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeLink) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeLink) Representation() ipld.Node {
	return (*_TypeLink__Repr)(n)
}
type _TypeLink__Repr _TypeLink
var (
	fieldName__TypeLink_ExpectedType_serial = _String{"expectedType"}
)
var _ ipld.Node = &_TypeLink__Repr{}
func (_TypeLink__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeLink__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "expectedType":
		if n.expectedType.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.expectedType.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeLink__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeLink__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.LookupByIndex(0)
}
func (n _TypeLink__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeLink__Repr) MapIterator() ipld.MapIterator {
	end := 1
	if n.expectedType.m == schema.Maybe_Absent {
		end = 0
	} else {
		goto done
	}
done:
	return &_TypeLink__ReprMapItr{n, 0, end}
}

type _TypeLink__ReprMapItr struct {
	n   *_TypeLink__Repr
	idx int
	end int
}

func (itr *_TypeLink__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeLink_ExpectedType_serial
		if itr.n.expectedType.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.expectedType.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeLink__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_TypeLink__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeLink__Repr) Length() int {
	l := 1
	if rn.expectedType.m == schema.Maybe_Absent {
		l--
	}
	return l
}
func (_TypeLink__Repr) IsAbsent() bool {
	return false
}
func (_TypeLink__Repr) IsNull() bool {
	return false
}
func (_TypeLink__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsBool()
}
func (_TypeLink__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsInt()
}
func (_TypeLink__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsFloat()
}
func (_TypeLink__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsString()
}
func (_TypeLink__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsBytes()
}
func (_TypeLink__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeLink.Repr"}.AsLink()
}
func (_TypeLink__Repr) Prototype() ipld.NodePrototype {
	return _TypeLink__ReprPrototype{}
}
type _TypeLink__ReprPrototype struct{}

func (_TypeLink__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeLink__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeLink__ReprBuilder struct {
	_TypeLink__ReprAssembler
}
func (nb *_TypeLink__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeLink__ReprBuilder) Reset() {
	var w _TypeLink
	var m schema.Maybe
	*nb = _TypeLink__ReprBuilder{_TypeLink__ReprAssembler{w: &w, m: &m}}
}
type _TypeLink__ReprAssembler struct {
	w *_TypeLink
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_expectedType _TypeName__ReprAssembler
	}

func (na *_TypeLink__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_expectedType.reset()
}
func (na *_TypeLink__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeLink{}
	}
	return na, nil
}
func (_TypeLink__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.BeginList(0)
}
func (na *_TypeLink__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeLink.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeLink__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignBool(false)
}
func (_TypeLink__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignInt(0)
}
func (_TypeLink__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignFloat(0)
}
func (_TypeLink__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignString("")
}
func (_TypeLink__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignBytes(nil)
}
func (_TypeLink__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeLink.Repr"}.AssignLink(nil)
}
func (na *_TypeLink__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeLink); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeLink.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeLink__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeLink__ReprPrototype{}
}
func (ma *_TypeLink__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.expectedType.m {
		case schema.Maybe_Value:
			ma.w.expectedType.v = ma.ca_expectedType.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeLink__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "expectedType":
		if ma.s & fieldBit__TypeLink_ExpectedType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeLink_ExpectedType_serial}
		}
		ma.s += fieldBit__TypeLink_ExpectedType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_expectedType.w = ma.w.expectedType.v
		ma.ca_expectedType.m = &ma.w.expectedType.m
		
		return &ma.ca_expectedType, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeLink.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeLink__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeLink__ReprKeyAssembler)(ma)
}
func (ma *_TypeLink__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_expectedType.w = ma.w.expectedType.v
		ma.ca_expectedType.m = &ma.w.expectedType.m
		
		return &ma.ca_expectedType
	default:
		panic("unreachable")
	}
}
func (ma *_TypeLink__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeLink__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeLink__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeLink__ReprKeyAssembler _TypeLink__ReprAssembler
func (_TypeLink__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeLink__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeLink__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeLink__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeLink__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeLink__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeLink__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "expectedType":
		if ka.s & fieldBit__TypeLink_ExpectedType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeLink_ExpectedType_serial}
		}
		ka.s += fieldBit__TypeLink_ExpectedType
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeLink.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeLink__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeLink__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeLink.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeLink__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeLink__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeList) FieldValueType() TypeNameOrInlineDefn {
	return &n.valueType
}
func (n _TypeList) FieldValueNullable() Bool {
	return &n.valueNullable
}
func (n _TypeList) FieldRepresentation() ListRepresentation {
	return &n.representation
}
type _TypeList__Maybe struct {
	m schema.Maybe
	v TypeList
}
type MaybeTypeList = *_TypeList__Maybe

func (m MaybeTypeList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeList) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeList) Must() TypeList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeList_ValueType = _String{"valueType"}
	fieldName__TypeList_ValueNullable = _String{"valueNullable"}
	fieldName__TypeList_Representation = _String{"representation"}
)
var _ ipld.Node = (TypeList)(&_TypeList{})
var _ schema.TypedNode = (TypeList)(&_TypeList{})
func (TypeList) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeList) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "valueType":
		return &n.valueType, nil
	case "valueNullable":
		return &n.valueNullable, nil
	case "representation":
		return &n.representation, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeList) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeList) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeList"}.LookupByIndex(0)
}
func (n TypeList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeList) MapIterator() ipld.MapIterator {
	return &_TypeList__MapItr{n, 0}
}

type _TypeList__MapItr struct {
	n TypeList
	idx  int
}

func (itr *_TypeList__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeList_ValueType
		v = &itr.n.valueType
	case 1:
		k = &fieldName__TypeList_ValueNullable
		v = &itr.n.valueNullable
	case 2:
		k = &fieldName__TypeList_Representation
		v = &itr.n.representation
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeList__MapItr) Done() bool {
	return itr.idx >= 3
}

func (TypeList) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeList) Length() int {
	return 3
}
func (TypeList) IsAbsent() bool {
	return false
}
func (TypeList) IsNull() bool {
	return false
}
func (TypeList) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsBool()
}
func (TypeList) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsInt()
}
func (TypeList) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsFloat()
}
func (TypeList) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsString()
}
func (TypeList) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsBytes()
}
func (TypeList) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeList"}.AsLink()
}
func (TypeList) Prototype() ipld.NodePrototype {
	return _TypeList__Prototype{}
}
type _TypeList__Prototype struct{}

func (_TypeList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeList__Builder
	nb.Reset()
	return &nb
}
type _TypeList__Builder struct {
	_TypeList__Assembler
}
func (nb *_TypeList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeList__Builder) Reset() {
	var w _TypeList
	var m schema.Maybe
	*nb = _TypeList__Builder{_TypeList__Assembler{w: &w, m: &m}}
}
type _TypeList__Assembler struct {
	w *_TypeList
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_valueType _TypeNameOrInlineDefn__Assembler
	ca_valueNullable _Bool__Assembler
	ca_representation _ListRepresentation__Assembler
	}

func (na *_TypeList__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_valueType.reset()
	na.ca_valueNullable.reset()
	na.ca_representation.reset()
}

var (
	fieldBit__TypeList_ValueType = 1 << 0
	fieldBit__TypeList_ValueNullable = 1 << 1
	fieldBit__TypeList_Representation = 1 << 2
	fieldBits__TypeList_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2
)
func (na *_TypeList__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeList{}
	}
	return na, nil
}
func (_TypeList__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeList"}.BeginList(0)
}
func (na *_TypeList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeList__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignBool(false)
}
func (_TypeList__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignInt(0)
}
func (_TypeList__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignFloat(0)
}
func (_TypeList__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignString("")
}
func (_TypeList__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignBytes(nil)
}
func (_TypeList__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeList"}.AssignLink(nil)
}
func (na *_TypeList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeList", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeList__Assembler) Prototype() ipld.NodePrototype {
	return _TypeList__Prototype{}
}
func (ma *_TypeList__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_valueType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_valueNullable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_representation.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeList__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "valueType":
		if ma.s & fieldBit__TypeList_ValueType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueType}
		}
		ma.s += fieldBit__TypeList_ValueType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType, nil
	case "valueNullable":
		if ma.s & fieldBit__TypeList_ValueNullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueNullable}
		}
		ma.s += fieldBit__TypeList_ValueNullable
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable, nil
	case "representation":
		if ma.s & fieldBit__TypeList_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_Representation}
		}
		ma.s += fieldBit__TypeList_Representation
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeList", Key:&_String{k}}
	}
}
func (ma *_TypeList__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeList__KeyAssembler)(ma)
}
func (ma *_TypeList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType
	case 1:
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable
	case 2:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeList__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeList__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeList__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeList__KeyAssembler _TypeList__Assembler
func (_TypeList__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.BeginMap(0)
}
func (_TypeList__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.BeginList(0)
}
func (na *_TypeList__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignNull()
}
func (_TypeList__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignBool(false)
}
func (_TypeList__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignInt(0)
}
func (_TypeList__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeList__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "valueType":
		if ka.s & fieldBit__TypeList_ValueType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueType}
		}
		ka.s += fieldBit__TypeList_ValueType
		ka.state = maState_expectValue
		ka.f = 0
	case "valueNullable":
		if ka.s & fieldBit__TypeList_ValueNullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueNullable}
		}
		ka.s += fieldBit__TypeList_ValueNullable
		ka.state = maState_expectValue
		ka.f = 1
	case "representation":
		if ka.s & fieldBit__TypeList_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_Representation}
		}
		ka.s += fieldBit__TypeList_Representation
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeList", Key:&_String{k}}
	}
	return nil
}
func (_TypeList__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeList__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeList.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeList__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeList__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeList) Representation() ipld.Node {
	return (*_TypeList__Repr)(n)
}
type _TypeList__Repr _TypeList
var (
	fieldName__TypeList_ValueType_serial = _String{"valueType"}
	fieldName__TypeList_ValueNullable_serial = _String{"valueNullable"}
	fieldName__TypeList_Representation_serial = _String{"representation"}
)
var _ ipld.Node = &_TypeList__Repr{}
func (_TypeList__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeList__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "valueType":
		return n.valueType.Representation(), nil
	case "valueNullable":
		return n.valueNullable.Representation(), nil
	case "representation":
		return n.representation.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeList__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeList__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.LookupByIndex(0)
}
func (n _TypeList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeList__Repr) MapIterator() ipld.MapIterator {
	return &_TypeList__ReprMapItr{n, 0}
}

type _TypeList__ReprMapItr struct {
	n   *_TypeList__Repr
	idx int
	
}

func (itr *_TypeList__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeList_ValueType_serial
		v = itr.n.valueType.Representation()
	case 1:
		k = &fieldName__TypeList_ValueNullable_serial
		v = itr.n.valueNullable.Representation()
	case 2:
		k = &fieldName__TypeList_Representation_serial
		v = itr.n.representation.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeList__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_TypeList__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeList__Repr) Length() int {
	l := 3
	return l
}
func (_TypeList__Repr) IsAbsent() bool {
	return false
}
func (_TypeList__Repr) IsNull() bool {
	return false
}
func (_TypeList__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsBool()
}
func (_TypeList__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsInt()
}
func (_TypeList__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsFloat()
}
func (_TypeList__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsString()
}
func (_TypeList__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsBytes()
}
func (_TypeList__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeList.Repr"}.AsLink()
}
func (_TypeList__Repr) Prototype() ipld.NodePrototype {
	return _TypeList__ReprPrototype{}
}
type _TypeList__ReprPrototype struct{}

func (_TypeList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeList__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeList__ReprBuilder struct {
	_TypeList__ReprAssembler
}
func (nb *_TypeList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeList__ReprBuilder) Reset() {
	var w _TypeList
	var m schema.Maybe
	*nb = _TypeList__ReprBuilder{_TypeList__ReprAssembler{w: &w, m: &m}}
}
type _TypeList__ReprAssembler struct {
	w *_TypeList
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_valueType _TypeNameOrInlineDefn__ReprAssembler
	ca_valueNullable _Bool__ReprAssembler
	ca_representation _ListRepresentation__ReprAssembler
	}

func (na *_TypeList__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_valueType.reset()
	na.ca_valueNullable.reset()
	na.ca_representation.reset()
}
func (na *_TypeList__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeList{}
	}
	return na, nil
}
func (_TypeList__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.BeginList(0)
}
func (na *_TypeList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeList__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignBool(false)
}
func (_TypeList__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignInt(0)
}
func (_TypeList__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignFloat(0)
}
func (_TypeList__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignString("")
}
func (_TypeList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignBytes(nil)
}
func (_TypeList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeList.Repr"}.AssignLink(nil)
}
func (na *_TypeList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeList__ReprPrototype{}
}
func (ma *_TypeList__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeList__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "valueType":
		if ma.s & fieldBit__TypeList_ValueType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueType_serial}
		}
		ma.s += fieldBit__TypeList_ValueType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType, nil
	case "valueNullable":
		if ma.s & fieldBit__TypeList_ValueNullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueNullable_serial}
		}
		ma.s += fieldBit__TypeList_ValueNullable
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable, nil
	case "representation":
		if ma.s & fieldBit__TypeList_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeList_Representation_serial}
		}
		ma.s += fieldBit__TypeList_Representation
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeList.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeList__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeList__ReprKeyAssembler)(ma)
}
func (ma *_TypeList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType
	case 1:
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable
	case 2:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeList__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeList__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeList__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeList__ReprKeyAssembler _TypeList__ReprAssembler
func (_TypeList__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeList__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeList__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeList__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeList__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeList__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeList__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "valueType":
		if ka.s & fieldBit__TypeList_ValueType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueType_serial}
		}
		ka.s += fieldBit__TypeList_ValueType
		ka.state = maState_expectValue
		ka.f = 0
	case "valueNullable":
		if ka.s & fieldBit__TypeList_ValueNullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_ValueNullable_serial}
		}
		ka.s += fieldBit__TypeList_ValueNullable
		ka.state = maState_expectValue
		ka.f = 1
	case "representation":
		if ka.s & fieldBit__TypeList_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeList_Representation_serial}
		}
		ka.s += fieldBit__TypeList_Representation
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeList.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeList__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeList__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeList.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeList__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeList__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeMap) FieldKeyType() TypeName {
	return &n.keyType
}
func (n _TypeMap) FieldValueType() TypeNameOrInlineDefn {
	return &n.valueType
}
func (n _TypeMap) FieldValueNullable() Bool {
	return &n.valueNullable
}
func (n _TypeMap) FieldRepresentation() MapRepresentation {
	return &n.representation
}
type _TypeMap__Maybe struct {
	m schema.Maybe
	v TypeMap
}
type MaybeTypeMap = *_TypeMap__Maybe

func (m MaybeTypeMap) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeMap) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeMap) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeMap) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeMap) Must() TypeMap {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeMap_KeyType = _String{"keyType"}
	fieldName__TypeMap_ValueType = _String{"valueType"}
	fieldName__TypeMap_ValueNullable = _String{"valueNullable"}
	fieldName__TypeMap_Representation = _String{"representation"}
)
var _ ipld.Node = (TypeMap)(&_TypeMap{})
var _ schema.TypedNode = (TypeMap)(&_TypeMap{})
func (TypeMap) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeMap) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "keyType":
		return &n.keyType, nil
	case "valueType":
		return &n.valueType, nil
	case "valueNullable":
		return &n.valueNullable, nil
	case "representation":
		return &n.representation, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeMap) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeMap) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeMap"}.LookupByIndex(0)
}
func (n TypeMap) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeMap) MapIterator() ipld.MapIterator {
	return &_TypeMap__MapItr{n, 0}
}

type _TypeMap__MapItr struct {
	n TypeMap
	idx  int
}

func (itr *_TypeMap__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeMap_KeyType
		v = &itr.n.keyType
	case 1:
		k = &fieldName__TypeMap_ValueType
		v = &itr.n.valueType
	case 2:
		k = &fieldName__TypeMap_ValueNullable
		v = &itr.n.valueNullable
	case 3:
		k = &fieldName__TypeMap_Representation
		v = &itr.n.representation
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeMap__MapItr) Done() bool {
	return itr.idx >= 4
}

func (TypeMap) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeMap) Length() int {
	return 4
}
func (TypeMap) IsAbsent() bool {
	return false
}
func (TypeMap) IsNull() bool {
	return false
}
func (TypeMap) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsBool()
}
func (TypeMap) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsInt()
}
func (TypeMap) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsFloat()
}
func (TypeMap) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsString()
}
func (TypeMap) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsBytes()
}
func (TypeMap) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeMap"}.AsLink()
}
func (TypeMap) Prototype() ipld.NodePrototype {
	return _TypeMap__Prototype{}
}
type _TypeMap__Prototype struct{}

func (_TypeMap__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeMap__Builder
	nb.Reset()
	return &nb
}
type _TypeMap__Builder struct {
	_TypeMap__Assembler
}
func (nb *_TypeMap__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeMap__Builder) Reset() {
	var w _TypeMap
	var m schema.Maybe
	*nb = _TypeMap__Builder{_TypeMap__Assembler{w: &w, m: &m}}
}
type _TypeMap__Assembler struct {
	w *_TypeMap
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_keyType _TypeName__Assembler
	ca_valueType _TypeNameOrInlineDefn__Assembler
	ca_valueNullable _Bool__Assembler
	ca_representation _MapRepresentation__Assembler
	}

func (na *_TypeMap__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_keyType.reset()
	na.ca_valueType.reset()
	na.ca_valueNullable.reset()
	na.ca_representation.reset()
}

var (
	fieldBit__TypeMap_KeyType = 1 << 0
	fieldBit__TypeMap_ValueType = 1 << 1
	fieldBit__TypeMap_ValueNullable = 1 << 2
	fieldBit__TypeMap_Representation = 1 << 3
	fieldBits__TypeMap_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2 + 1 << 3
)
func (na *_TypeMap__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeMap{}
	}
	return na, nil
}
func (_TypeMap__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.BeginList(0)
}
func (na *_TypeMap__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeMap__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignBool(false)
}
func (_TypeMap__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignInt(0)
}
func (_TypeMap__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignFloat(0)
}
func (_TypeMap__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignString("")
}
func (_TypeMap__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignBytes(nil)
}
func (_TypeMap__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeMap"}.AssignLink(nil)
}
func (na *_TypeMap__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeMap); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeMap", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeMap__Assembler) Prototype() ipld.NodePrototype {
	return _TypeMap__Prototype{}
}
func (ma *_TypeMap__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_keyType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_valueType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_valueNullable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_representation.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeMap__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "keyType":
		if ma.s & fieldBit__TypeMap_KeyType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_KeyType}
		}
		ma.s += fieldBit__TypeMap_KeyType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_keyType.w = &ma.w.keyType
		ma.ca_keyType.m = &ma.cm
		return &ma.ca_keyType, nil
	case "valueType":
		if ma.s & fieldBit__TypeMap_ValueType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueType}
		}
		ma.s += fieldBit__TypeMap_ValueType
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType, nil
	case "valueNullable":
		if ma.s & fieldBit__TypeMap_ValueNullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueNullable}
		}
		ma.s += fieldBit__TypeMap_ValueNullable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable, nil
	case "representation":
		if ma.s & fieldBit__TypeMap_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_Representation}
		}
		ma.s += fieldBit__TypeMap_Representation
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeMap", Key:&_String{k}}
	}
}
func (ma *_TypeMap__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeMap__KeyAssembler)(ma)
}
func (ma *_TypeMap__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_keyType.w = &ma.w.keyType
		ma.ca_keyType.m = &ma.cm
		return &ma.ca_keyType
	case 1:
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType
	case 2:
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable
	case 3:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeMap__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeMap__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeMap__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeMap__KeyAssembler _TypeMap__Assembler
func (_TypeMap__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.BeginMap(0)
}
func (_TypeMap__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.BeginList(0)
}
func (na *_TypeMap__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignNull()
}
func (_TypeMap__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignBool(false)
}
func (_TypeMap__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignInt(0)
}
func (_TypeMap__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeMap__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "keyType":
		if ka.s & fieldBit__TypeMap_KeyType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_KeyType}
		}
		ka.s += fieldBit__TypeMap_KeyType
		ka.state = maState_expectValue
		ka.f = 0
	case "valueType":
		if ka.s & fieldBit__TypeMap_ValueType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueType}
		}
		ka.s += fieldBit__TypeMap_ValueType
		ka.state = maState_expectValue
		ka.f = 1
	case "valueNullable":
		if ka.s & fieldBit__TypeMap_ValueNullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueNullable}
		}
		ka.s += fieldBit__TypeMap_ValueNullable
		ka.state = maState_expectValue
		ka.f = 2
	case "representation":
		if ka.s & fieldBit__TypeMap_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_Representation}
		}
		ka.s += fieldBit__TypeMap_Representation
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeMap", Key:&_String{k}}
	}
	return nil
}
func (_TypeMap__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeMap__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeMap__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeMap__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeMap) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeMap) Representation() ipld.Node {
	return (*_TypeMap__Repr)(n)
}
type _TypeMap__Repr _TypeMap
var (
	fieldName__TypeMap_KeyType_serial = _String{"keyType"}
	fieldName__TypeMap_ValueType_serial = _String{"valueType"}
	fieldName__TypeMap_ValueNullable_serial = _String{"valueNullable"}
	fieldName__TypeMap_Representation_serial = _String{"representation"}
)
var _ ipld.Node = &_TypeMap__Repr{}
func (_TypeMap__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeMap__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "keyType":
		return n.keyType.Representation(), nil
	case "valueType":
		return n.valueType.Representation(), nil
	case "valueNullable":
		return n.valueNullable.Representation(), nil
	case "representation":
		return n.representation.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeMap__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeMap__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.LookupByIndex(0)
}
func (n _TypeMap__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeMap__Repr) MapIterator() ipld.MapIterator {
	return &_TypeMap__ReprMapItr{n, 0}
}

type _TypeMap__ReprMapItr struct {
	n   *_TypeMap__Repr
	idx int
	
}

func (itr *_TypeMap__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeMap_KeyType_serial
		v = itr.n.keyType.Representation()
	case 1:
		k = &fieldName__TypeMap_ValueType_serial
		v = itr.n.valueType.Representation()
	case 2:
		k = &fieldName__TypeMap_ValueNullable_serial
		v = itr.n.valueNullable.Representation()
	case 3:
		k = &fieldName__TypeMap_Representation_serial
		v = itr.n.representation.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeMap__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_TypeMap__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeMap__Repr) Length() int {
	l := 4
	return l
}
func (_TypeMap__Repr) IsAbsent() bool {
	return false
}
func (_TypeMap__Repr) IsNull() bool {
	return false
}
func (_TypeMap__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsBool()
}
func (_TypeMap__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsInt()
}
func (_TypeMap__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsFloat()
}
func (_TypeMap__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsString()
}
func (_TypeMap__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsBytes()
}
func (_TypeMap__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeMap.Repr"}.AsLink()
}
func (_TypeMap__Repr) Prototype() ipld.NodePrototype {
	return _TypeMap__ReprPrototype{}
}
type _TypeMap__ReprPrototype struct{}

func (_TypeMap__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeMap__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeMap__ReprBuilder struct {
	_TypeMap__ReprAssembler
}
func (nb *_TypeMap__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeMap__ReprBuilder) Reset() {
	var w _TypeMap
	var m schema.Maybe
	*nb = _TypeMap__ReprBuilder{_TypeMap__ReprAssembler{w: &w, m: &m}}
}
type _TypeMap__ReprAssembler struct {
	w *_TypeMap
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_keyType _TypeName__ReprAssembler
	ca_valueType _TypeNameOrInlineDefn__ReprAssembler
	ca_valueNullable _Bool__ReprAssembler
	ca_representation _MapRepresentation__ReprAssembler
	}

func (na *_TypeMap__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_keyType.reset()
	na.ca_valueType.reset()
	na.ca_valueNullable.reset()
	na.ca_representation.reset()
}
func (na *_TypeMap__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeMap{}
	}
	return na, nil
}
func (_TypeMap__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.BeginList(0)
}
func (na *_TypeMap__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeMap.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeMap__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignBool(false)
}
func (_TypeMap__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignInt(0)
}
func (_TypeMap__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignFloat(0)
}
func (_TypeMap__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignString("")
}
func (_TypeMap__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignBytes(nil)
}
func (_TypeMap__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeMap.Repr"}.AssignLink(nil)
}
func (na *_TypeMap__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeMap); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeMap.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeMap__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeMap__ReprPrototype{}
}
func (ma *_TypeMap__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeMap__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "keyType":
		if ma.s & fieldBit__TypeMap_KeyType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_KeyType_serial}
		}
		ma.s += fieldBit__TypeMap_KeyType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_keyType.w = &ma.w.keyType
		ma.ca_keyType.m = &ma.cm
		return &ma.ca_keyType, nil
	case "valueType":
		if ma.s & fieldBit__TypeMap_ValueType != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueType_serial}
		}
		ma.s += fieldBit__TypeMap_ValueType
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType, nil
	case "valueNullable":
		if ma.s & fieldBit__TypeMap_ValueNullable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueNullable_serial}
		}
		ma.s += fieldBit__TypeMap_ValueNullable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable, nil
	case "representation":
		if ma.s & fieldBit__TypeMap_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeMap_Representation_serial}
		}
		ma.s += fieldBit__TypeMap_Representation
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeMap.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeMap__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeMap__ReprKeyAssembler)(ma)
}
func (ma *_TypeMap__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_keyType.w = &ma.w.keyType
		ma.ca_keyType.m = &ma.cm
		return &ma.ca_keyType
	case 1:
		ma.ca_valueType.w = &ma.w.valueType
		ma.ca_valueType.m = &ma.cm
		return &ma.ca_valueType
	case 2:
		ma.ca_valueNullable.w = &ma.w.valueNullable
		ma.ca_valueNullable.m = &ma.cm
		return &ma.ca_valueNullable
	case 3:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeMap__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeMap__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeMap__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeMap__ReprKeyAssembler _TypeMap__ReprAssembler
func (_TypeMap__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeMap__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeMap__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeMap__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeMap__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeMap__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeMap__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "keyType":
		if ka.s & fieldBit__TypeMap_KeyType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_KeyType_serial}
		}
		ka.s += fieldBit__TypeMap_KeyType
		ka.state = maState_expectValue
		ka.f = 0
	case "valueType":
		if ka.s & fieldBit__TypeMap_ValueType != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueType_serial}
		}
		ka.s += fieldBit__TypeMap_ValueType
		ka.state = maState_expectValue
		ka.f = 1
	case "valueNullable":
		if ka.s & fieldBit__TypeMap_ValueNullable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_ValueNullable_serial}
		}
		ka.s += fieldBit__TypeMap_ValueNullable
		ka.state = maState_expectValue
		ka.f = 2
	case "representation":
		if ka.s & fieldBit__TypeMap_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeMap_Representation_serial}
		}
		ka.s += fieldBit__TypeMap_Representation
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeMap.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeMap__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeMap__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeMap.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeMap__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeMap__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n TypeName) String() string {
	return n.x
}
func (_TypeName__Prototype) fromString(w *_TypeName, v string) error {
	*w = _TypeName{v}
	return nil
}
func (_TypeName__Prototype) FromString(v string) (TypeName, error) {
	n := _TypeName{v}
	return &n, nil
}
type _TypeName__Maybe struct {
	m schema.Maybe
	v TypeName
}
type MaybeTypeName = *_TypeName__Maybe

func (m MaybeTypeName) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeName) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeName) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeName) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeName) Must() TypeName {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (TypeName)(&_TypeName{})
var _ schema.TypedNode = (TypeName)(&_TypeName{})
func (TypeName) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_String
}
func (TypeName) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"schemadmt.TypeName"}.LookupByString("")
}
func (TypeName) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"schemadmt.TypeName"}.LookupByNode(nil)
}
func (TypeName) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.String{"schemadmt.TypeName"}.LookupByIndex(0)
}
func (TypeName) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"schemadmt.TypeName"}.LookupBySegment(seg)
}
func (TypeName) MapIterator() ipld.MapIterator {
	return nil
}
func (TypeName) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeName) Length() int {
	return -1
}
func (TypeName) IsAbsent() bool {
	return false
}
func (TypeName) IsNull() bool {
	return false
}
func (TypeName) AsBool() (bool, error) {
	return mixins.String{"schemadmt.TypeName"}.AsBool()
}
func (TypeName) AsInt() (int, error) {
	return mixins.String{"schemadmt.TypeName"}.AsInt()
}
func (TypeName) AsFloat() (float64, error) {
	return mixins.String{"schemadmt.TypeName"}.AsFloat()
}
func (n TypeName) AsString() (string, error) {
	return n.x, nil
}
func (TypeName) AsBytes() ([]byte, error) {
	return mixins.String{"schemadmt.TypeName"}.AsBytes()
}
func (TypeName) AsLink() (ipld.Link, error) {
	return mixins.String{"schemadmt.TypeName"}.AsLink()
}
func (TypeName) Prototype() ipld.NodePrototype {
	return _TypeName__Prototype{}
}
type _TypeName__Prototype struct{}

func (_TypeName__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeName__Builder
	nb.Reset()
	return &nb
}
type _TypeName__Builder struct {
	_TypeName__Assembler
}
func (nb *_TypeName__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeName__Builder) Reset() {
	var w _TypeName
	var m schema.Maybe
	*nb = _TypeName__Builder{_TypeName__Assembler{w: &w, m: &m}}
}
type _TypeName__Assembler struct {
	w *_TypeName
	m *schema.Maybe
}

func (na *_TypeName__Assembler) reset() {}
func (_TypeName__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeName"}.BeginMap(0)
}
func (_TypeName__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeName"}.BeginList(0)
}
func (na *_TypeName__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"schemadmt.TypeName"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_TypeName__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeName"}.AssignBool(false)
}
func (_TypeName__Assembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeName"}.AssignInt(0)
}
func (_TypeName__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeName"}.AssignFloat(0)
}
func (na *_TypeName__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_TypeName{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_TypeName__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeName"}.AssignBytes(nil)
}
func (_TypeName__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeName"}.AssignLink(nil)
}
func (na *_TypeName__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeName); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_TypeName__Assembler) Prototype() ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (TypeName) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeName) Representation() ipld.Node {
	return (*_TypeName__Repr)(n)
}
type _TypeName__Repr = _TypeName
var _ ipld.Node = &_TypeName__Repr{}
type _TypeName__ReprPrototype = _TypeName__Prototype
type _TypeName__ReprAssembler = _TypeName__Assembler

func (n _TypeNameOrInlineDefn) AsInterface() _TypeNameOrInlineDefn__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _TypeNameOrInlineDefn__Maybe struct {
	m schema.Maybe
	v TypeNameOrInlineDefn
}
type MaybeTypeNameOrInlineDefn = *_TypeNameOrInlineDefn__Maybe

func (m MaybeTypeNameOrInlineDefn) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeNameOrInlineDefn) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeNameOrInlineDefn) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeNameOrInlineDefn) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeNameOrInlineDefn) Must() TypeNameOrInlineDefn {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__TypeNameOrInlineDefn_TypeName = _String{"TypeName"}
	memberName__TypeNameOrInlineDefn_TypeDefnInline = _String{"TypeDefnInline"}
)
var _ ipld.Node = (TypeNameOrInlineDefn)(&_TypeNameOrInlineDefn{})
var _ schema.TypedNode = (TypeNameOrInlineDefn)(&_TypeNameOrInlineDefn{})
func (TypeNameOrInlineDefn) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeNameOrInlineDefn) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TypeName":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "TypeDefnInline":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeNameOrInlineDefn) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeNameOrInlineDefn) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.LookupByIndex(0)
}
func (n TypeNameOrInlineDefn) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeNameOrInlineDefn) MapIterator() ipld.MapIterator {
	return &_TypeNameOrInlineDefn__MapItr{n, false}
}

type _TypeNameOrInlineDefn__MapItr struct {
	n TypeNameOrInlineDefn
	done bool
}

func (itr *_TypeNameOrInlineDefn__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TypeNameOrInlineDefn_TypeName, &itr.n.x1
	case 2:
		k, v = &memberName__TypeNameOrInlineDefn_TypeDefnInline, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TypeNameOrInlineDefn__MapItr) Done() bool {
	return itr.done
}

func (TypeNameOrInlineDefn) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeNameOrInlineDefn) Length() int {
	return 1
}
func (TypeNameOrInlineDefn) IsAbsent() bool {
	return false
}
func (TypeNameOrInlineDefn) IsNull() bool {
	return false
}
func (TypeNameOrInlineDefn) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsBool()
}
func (TypeNameOrInlineDefn) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsInt()
}
func (TypeNameOrInlineDefn) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsFloat()
}
func (TypeNameOrInlineDefn) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsString()
}
func (TypeNameOrInlineDefn) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsBytes()
}
func (TypeNameOrInlineDefn) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeNameOrInlineDefn"}.AsLink()
}
func (TypeNameOrInlineDefn) Prototype() ipld.NodePrototype {
	return _TypeNameOrInlineDefn__Prototype{}
}
type _TypeNameOrInlineDefn__Prototype struct{}

func (_TypeNameOrInlineDefn__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeNameOrInlineDefn__Builder
	nb.Reset()
	return &nb
}
type _TypeNameOrInlineDefn__Builder struct {
	_TypeNameOrInlineDefn__Assembler
}
func (nb *_TypeNameOrInlineDefn__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeNameOrInlineDefn__Builder) Reset() {
	var w _TypeNameOrInlineDefn
	var m schema.Maybe
	*nb = _TypeNameOrInlineDefn__Builder{_TypeNameOrInlineDefn__Assembler{w: &w, m: &m}}
}
type _TypeNameOrInlineDefn__Assembler struct {
	w *_TypeNameOrInlineDefn
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _TypeName__Assembler
	
	ca2 _TypeDefnInline__Assembler
	ca uint
}
func (na *_TypeNameOrInlineDefn__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TypeNameOrInlineDefn__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeNameOrInlineDefn{}
	}
	return na, nil
}
func (_TypeNameOrInlineDefn__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.BeginList(0)
}
func (na *_TypeNameOrInlineDefn__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeNameOrInlineDefn__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignBool(false)
}
func (_TypeNameOrInlineDefn__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignInt(0)
}
func (_TypeNameOrInlineDefn__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignFloat(0)
}
func (_TypeNameOrInlineDefn__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignString("")
}
func (_TypeNameOrInlineDefn__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignBytes(nil)
}
func (_TypeNameOrInlineDefn__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeNameOrInlineDefn"}.AssignLink(nil)
}
func (na *_TypeNameOrInlineDefn__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeNameOrInlineDefn); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeNameOrInlineDefn__Assembler) Prototype() ipld.NodePrototype {
	return _TypeNameOrInlineDefn__Prototype{}
}
func (ma *_TypeNameOrInlineDefn__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TypeNameOrInlineDefn__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeNameOrInlineDefn", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeName":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "TypeDefnInline":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeNameOrInlineDefn", Key:&_String{k}}
	}
}
func (ma *_TypeNameOrInlineDefn__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeNameOrInlineDefn__KeyAssembler)(ma)
}
func (ma *_TypeNameOrInlineDefn__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_TypeNameOrInlineDefn__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeNameOrInlineDefn", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeNameOrInlineDefn__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeNameOrInlineDefn__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TypeName":
		return _TypeName__Prototype{}
	case "TypeDefnInline":
		return _TypeDefnInline__Prototype{}
	default:
		return nil
	}
}
type _TypeNameOrInlineDefn__KeyAssembler _TypeNameOrInlineDefn__Assembler
func (_TypeNameOrInlineDefn__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.BeginMap(0)
}
func (_TypeNameOrInlineDefn__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.BeginList(0)
}
func (na *_TypeNameOrInlineDefn__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignNull()
}
func (_TypeNameOrInlineDefn__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignBool(false)
}
func (_TypeNameOrInlineDefn__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignInt(0)
}
func (_TypeNameOrInlineDefn__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeNameOrInlineDefn__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.TypeNameOrInlineDefn", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TypeName":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "TypeDefnInline":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeNameOrInlineDefn", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_TypeNameOrInlineDefn__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeNameOrInlineDefn__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeNameOrInlineDefn.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeNameOrInlineDefn__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeNameOrInlineDefn__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeNameOrInlineDefn) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeNameOrInlineDefn) Representation() ipld.Node {
	return (*_TypeNameOrInlineDefn__Repr)(n)
}
type _TypeNameOrInlineDefn__Repr _TypeNameOrInlineDefn
var _ ipld.Node = &_TypeNameOrInlineDefn__Repr{}
func (n *_TypeNameOrInlineDefn__Repr) ReprKind() ipld.ReprKind {
	switch n.tag {
	case 1:
		return ipld.ReprKind_String
	case 2:
		return ipld.ReprKind_Map
	default:
		panic("unreachable")
	}
}
func (n *_TypeNameOrInlineDefn__Repr) LookupByString(key string) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupByString(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "LookupByString", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: n.ReprKind()}
	}
}
func (n *_TypeNameOrInlineDefn__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupByNode(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "LookupByNode", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
	}
}
func (n *_TypeNameOrInlineDefn__Repr) LookupByIndex(idx int) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "LookupByIndex", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: n.ReprKind()}
}
func (n *_TypeNameOrInlineDefn__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupBySegment(seg)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "LookupBySegment", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
	}
}
func (n *_TypeNameOrInlineDefn__Repr) MapIterator() ipld.MapIterator {
	switch n.tag {
	case 2:
		return n.x2.Representation().MapIterator()
	default:
		return nil
	}
}
func (n *_TypeNameOrInlineDefn__Repr) ListIterator() ipld.ListIterator {
		return nil
}
func (n *_TypeNameOrInlineDefn__Repr) Length() int {
	switch n.tag {
	case 2:
		return n.x2.Representation().Length()
	default:
		return -1
	}
}
func (n *_TypeNameOrInlineDefn__Repr) IsAbsent() bool {
	return false
}
func (n *_TypeNameOrInlineDefn__Repr) IsNull() bool {
	return false
}
func (n *_TypeNameOrInlineDefn__Repr) AsBool() (bool, error) {
		return false, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsBool", AppropriateKind: ipld.ReprKindSet_JustBool, ActualKind: n.ReprKind()}
}
func (n *_TypeNameOrInlineDefn__Repr) AsInt() (int, error) {
		return 0, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsInt", AppropriateKind: ipld.ReprKindSet_JustInt, ActualKind: n.ReprKind()}
}
func (n *_TypeNameOrInlineDefn__Repr) AsFloat() (float64, error) {
		return 0, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsFloat", AppropriateKind: ipld.ReprKindSet_JustFloat, ActualKind: n.ReprKind()}
}
func (n *_TypeNameOrInlineDefn__Repr) AsString() (string, error) {
	switch n.tag {
	case 1:
		return n.x1.Representation().AsString()
	default:
		return "", ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsString", AppropriateKind: ipld.ReprKindSet_JustString, ActualKind: n.ReprKind()}
	}
}
func (n *_TypeNameOrInlineDefn__Repr) AsBytes() ([]byte, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsBytes", AppropriateKind: ipld.ReprKindSet_JustBytes, ActualKind: n.ReprKind()}
}
func (n *_TypeNameOrInlineDefn__Repr) AsLink() (ipld.Link, error) {
		return nil, ipld.ErrWrongKind{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", MethodName: "AsLink", AppropriateKind: ipld.ReprKindSet_JustLink, ActualKind: n.ReprKind()}
}
func (_TypeNameOrInlineDefn__Repr) Prototype() ipld.NodePrototype {
	return _TypeNameOrInlineDefn__ReprPrototype{}
}
type _TypeNameOrInlineDefn__ReprPrototype struct{}

func (_TypeNameOrInlineDefn__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeNameOrInlineDefn__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeNameOrInlineDefn__ReprBuilder struct {
	_TypeNameOrInlineDefn__ReprAssembler
}
func (nb *_TypeNameOrInlineDefn__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeNameOrInlineDefn__ReprBuilder) Reset() {
	var w _TypeNameOrInlineDefn
	var m schema.Maybe
	*nb = _TypeNameOrInlineDefn__ReprBuilder{_TypeNameOrInlineDefn__ReprAssembler{w: &w, m: &m}}
}
type _TypeNameOrInlineDefn__ReprAssembler struct {
	w *_TypeNameOrInlineDefn
	m *schema.Maybe
	ca1 _TypeName__ReprAssembler
	ca2 _TypeDefnInline__ReprAssembler
	ca uint
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) reset() {
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_TypeNameOrInlineDefn{}
	}
	na.ca = 2
	na.w.tag = 2
	na.ca2.w = &na.w.x2
	na.ca2.m = na.m
	return na.ca2.BeginMap(sizeHint)
	return nil, schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "BeginMap called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return nil, schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "BeginList called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignNull() error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignNull called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignBool(v bool) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignBool called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignInt(v int) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignInt called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignFloat(v float64) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignFloat called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignString(v string) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_TypeNameOrInlineDefn{}
	}
	na.ca = 1
	na.w.tag = 1
	na.ca1.w = &na.w.x1
	na.ca1.m = na.m
	return na.ca1.AssignString(v)
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignString called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignBytes(v []byte) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignBytes called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignLink(v ipld.Link) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "schemadmt.TypeNameOrInlineDefn.Repr", Detail: "AssignLink called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeNameOrInlineDefn); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	switch v.ReprKind() {
	case ipld.ReprKind_Bool:
		v2, _ := v.AsBool()
		return na.AssignBool(v2)
	case ipld.ReprKind_Int:
		v2, _ := v.AsInt()
		return na.AssignInt(v2)
	case ipld.ReprKind_Float:
		v2, _ := v.AsFloat()
		return na.AssignFloat(v2)
	case ipld.ReprKind_String:
		v2, _ := v.AsString()
		return na.AssignString(v2)
	case ipld.ReprKind_Bytes:
		v2, _ := v.AsBytes()
		return na.AssignBytes(v2)
	case ipld.ReprKind_Map:
		na, err := na.BeginMap(v.Length())
		if err != nil {
			return err
		}
		itr := v.MapIterator()
		for !itr.Done() {
			k, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleKey().AssignNode(k); err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_List:
		na, err := na.BeginList(v.Length())
		if err != nil {
			return err
		}
		itr := v.ListIterator()
		for !itr.Done() {
			_, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_Link:
		v2, _ := v.AsLink()
		return na.AssignLink(v2)
	default:
		panic("unreachable")
	}
}
func (na *_TypeNameOrInlineDefn__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeNameOrInlineDefn__ReprPrototype{}
}


type _TypeString__Maybe struct {
	m schema.Maybe
	v TypeString
}
type MaybeTypeString = *_TypeString__Maybe

func (m MaybeTypeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeString) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeString) Must() TypeString {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (TypeString)(&_TypeString{})
var _ schema.TypedNode = (TypeString)(&_TypeString{})
func (TypeString) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeString) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeString) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeString) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeString"}.LookupByIndex(0)
}
func (n TypeString) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeString) MapIterator() ipld.MapIterator {
	return &_TypeString__MapItr{n, 0}
}

type _TypeString__MapItr struct {
	n TypeString
	idx  int
}

func (itr *_TypeString__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeString__MapItr) Done() bool {
	return itr.idx >= 0
}

func (TypeString) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeString) Length() int {
	return 0
}
func (TypeString) IsAbsent() bool {
	return false
}
func (TypeString) IsNull() bool {
	return false
}
func (TypeString) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsBool()
}
func (TypeString) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsInt()
}
func (TypeString) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsFloat()
}
func (TypeString) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsString()
}
func (TypeString) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsBytes()
}
func (TypeString) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeString"}.AsLink()
}
func (TypeString) Prototype() ipld.NodePrototype {
	return _TypeString__Prototype{}
}
type _TypeString__Prototype struct{}

func (_TypeString__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeString__Builder
	nb.Reset()
	return &nb
}
type _TypeString__Builder struct {
	_TypeString__Assembler
}
func (nb *_TypeString__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeString__Builder) Reset() {
	var w _TypeString
	var m schema.Maybe
	*nb = _TypeString__Builder{_TypeString__Assembler{w: &w, m: &m}}
}
type _TypeString__Assembler struct {
	w *_TypeString
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeString__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__TypeString_sufficient = 0
)
func (na *_TypeString__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeString{}
	}
	return na, nil
}
func (_TypeString__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeString"}.BeginList(0)
}
func (na *_TypeString__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeString"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeString__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignBool(false)
}
func (_TypeString__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignInt(0)
}
func (_TypeString__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignFloat(0)
}
func (_TypeString__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignString("")
}
func (_TypeString__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignBytes(nil)
}
func (_TypeString__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeString"}.AssignLink(nil)
}
func (na *_TypeString__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeString); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeString", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeString__Assembler) Prototype() ipld.NodePrototype {
	return _TypeString__Prototype{}
}
func (ma *_TypeString__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeString__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeString", Key:&_String{k}}
	}
}
func (ma *_TypeString__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeString__KeyAssembler)(ma)
}
func (ma *_TypeString__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeString__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeString__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeString__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeString__KeyAssembler _TypeString__Assembler
func (_TypeString__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.BeginMap(0)
}
func (_TypeString__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.BeginList(0)
}
func (na *_TypeString__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignNull()
}
func (_TypeString__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignBool(false)
}
func (_TypeString__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignInt(0)
}
func (_TypeString__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeString__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeString", Key:&_String{k}}
	}
	return nil
}
func (_TypeString__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeString__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeString.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeString__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeString__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeString) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeString) Representation() ipld.Node {
	return (*_TypeString__Repr)(n)
}
type _TypeString__Repr _TypeString
var (
)
var _ ipld.Node = &_TypeString__Repr{}
func (_TypeString__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeString__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeString__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeString__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.LookupByIndex(0)
}
func (n _TypeString__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeString__Repr) MapIterator() ipld.MapIterator {
	return &_TypeString__ReprMapItr{n, 0}
}

type _TypeString__ReprMapItr struct {
	n   *_TypeString__Repr
	idx int
	
}

func (itr *_TypeString__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeString__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_TypeString__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeString__Repr) Length() int {
	l := 0
	return l
}
func (_TypeString__Repr) IsAbsent() bool {
	return false
}
func (_TypeString__Repr) IsNull() bool {
	return false
}
func (_TypeString__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsBool()
}
func (_TypeString__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsInt()
}
func (_TypeString__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsFloat()
}
func (_TypeString__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsString()
}
func (_TypeString__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsBytes()
}
func (_TypeString__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeString.Repr"}.AsLink()
}
func (_TypeString__Repr) Prototype() ipld.NodePrototype {
	return _TypeString__ReprPrototype{}
}
type _TypeString__ReprPrototype struct{}

func (_TypeString__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeString__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeString__ReprBuilder struct {
	_TypeString__ReprAssembler
}
func (nb *_TypeString__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeString__ReprBuilder) Reset() {
	var w _TypeString
	var m schema.Maybe
	*nb = _TypeString__ReprBuilder{_TypeString__ReprAssembler{w: &w, m: &m}}
}
type _TypeString__ReprAssembler struct {
	w *_TypeString
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_TypeString__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_TypeString__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeString{}
	}
	return na, nil
}
func (_TypeString__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.BeginList(0)
}
func (na *_TypeString__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeString.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeString__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignBool(false)
}
func (_TypeString__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignInt(0)
}
func (_TypeString__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignFloat(0)
}
func (_TypeString__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignString("")
}
func (_TypeString__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignBytes(nil)
}
func (_TypeString__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeString.Repr"}.AssignLink(nil)
}
func (na *_TypeString__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeString); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeString.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeString__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeString__ReprPrototype{}
}
func (ma *_TypeString__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeString__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeString.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeString__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeString__ReprKeyAssembler)(ma)
}
func (ma *_TypeString__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_TypeString__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeString__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeString__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeString__ReprKeyAssembler _TypeString__ReprAssembler
func (_TypeString__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeString__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeString__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeString__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeString__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeString__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeString__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeString.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeString__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeString__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeString.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeString__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeString__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeStruct) FieldFields() Map__FieldName__StructField {
	return &n.fields
}
func (n _TypeStruct) FieldRepresentation() StructRepresentation {
	return &n.representation
}
type _TypeStruct__Maybe struct {
	m schema.Maybe
	v TypeStruct
}
type MaybeTypeStruct = *_TypeStruct__Maybe

func (m MaybeTypeStruct) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeStruct) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeStruct) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeStruct) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeStruct) Must() TypeStruct {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeStruct_Fields = _String{"fields"}
	fieldName__TypeStruct_Representation = _String{"representation"}
)
var _ ipld.Node = (TypeStruct)(&_TypeStruct{})
var _ schema.TypedNode = (TypeStruct)(&_TypeStruct{})
func (TypeStruct) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeStruct) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fields":
		return &n.fields, nil
	case "representation":
		return &n.representation, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeStruct) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeStruct) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.LookupByIndex(0)
}
func (n TypeStruct) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeStruct) MapIterator() ipld.MapIterator {
	return &_TypeStruct__MapItr{n, 0}
}

type _TypeStruct__MapItr struct {
	n TypeStruct
	idx  int
}

func (itr *_TypeStruct__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeStruct_Fields
		v = &itr.n.fields
	case 1:
		k = &fieldName__TypeStruct_Representation
		v = &itr.n.representation
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeStruct__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TypeStruct) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeStruct) Length() int {
	return 2
}
func (TypeStruct) IsAbsent() bool {
	return false
}
func (TypeStruct) IsNull() bool {
	return false
}
func (TypeStruct) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsBool()
}
func (TypeStruct) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsInt()
}
func (TypeStruct) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsFloat()
}
func (TypeStruct) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsString()
}
func (TypeStruct) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsBytes()
}
func (TypeStruct) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeStruct"}.AsLink()
}
func (TypeStruct) Prototype() ipld.NodePrototype {
	return _TypeStruct__Prototype{}
}
type _TypeStruct__Prototype struct{}

func (_TypeStruct__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeStruct__Builder
	nb.Reset()
	return &nb
}
type _TypeStruct__Builder struct {
	_TypeStruct__Assembler
}
func (nb *_TypeStruct__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeStruct__Builder) Reset() {
	var w _TypeStruct
	var m schema.Maybe
	*nb = _TypeStruct__Builder{_TypeStruct__Assembler{w: &w, m: &m}}
}
type _TypeStruct__Assembler struct {
	w *_TypeStruct
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fields _Map__FieldName__StructField__Assembler
	ca_representation _StructRepresentation__Assembler
	}

func (na *_TypeStruct__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fields.reset()
	na.ca_representation.reset()
}

var (
	fieldBit__TypeStruct_Fields = 1 << 0
	fieldBit__TypeStruct_Representation = 1 << 1
	fieldBits__TypeStruct_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_TypeStruct__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeStruct{}
	}
	return na, nil
}
func (_TypeStruct__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.BeginList(0)
}
func (na *_TypeStruct__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeStruct__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignBool(false)
}
func (_TypeStruct__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignInt(0)
}
func (_TypeStruct__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignFloat(0)
}
func (_TypeStruct__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignString("")
}
func (_TypeStruct__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignBytes(nil)
}
func (_TypeStruct__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct"}.AssignLink(nil)
}
func (na *_TypeStruct__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeStruct); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeStruct", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeStruct__Assembler) Prototype() ipld.NodePrototype {
	return _TypeStruct__Prototype{}
}
func (ma *_TypeStruct__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_fields.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_representation.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeStruct__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fields":
		if ma.s & fieldBit__TypeStruct_Fields != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Fields}
		}
		ma.s += fieldBit__TypeStruct_Fields
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fields.w = &ma.w.fields
		ma.ca_fields.m = &ma.cm
		return &ma.ca_fields, nil
	case "representation":
		if ma.s & fieldBit__TypeStruct_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Representation}
		}
		ma.s += fieldBit__TypeStruct_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeStruct", Key:&_String{k}}
	}
}
func (ma *_TypeStruct__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeStruct__KeyAssembler)(ma)
}
func (ma *_TypeStruct__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fields.w = &ma.w.fields
		ma.ca_fields.m = &ma.cm
		return &ma.ca_fields
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeStruct__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeStruct__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeStruct__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeStruct__KeyAssembler _TypeStruct__Assembler
func (_TypeStruct__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.BeginMap(0)
}
func (_TypeStruct__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.BeginList(0)
}
func (na *_TypeStruct__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignNull()
}
func (_TypeStruct__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignBool(false)
}
func (_TypeStruct__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignInt(0)
}
func (_TypeStruct__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeStruct__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fields":
		if ka.s & fieldBit__TypeStruct_Fields != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Fields}
		}
		ka.s += fieldBit__TypeStruct_Fields
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeStruct_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Representation}
		}
		ka.s += fieldBit__TypeStruct_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeStruct", Key:&_String{k}}
	}
	return nil
}
func (_TypeStruct__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeStruct__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeStruct__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeStruct__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeStruct) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeStruct) Representation() ipld.Node {
	return (*_TypeStruct__Repr)(n)
}
type _TypeStruct__Repr _TypeStruct
var (
	fieldName__TypeStruct_Fields_serial = _String{"fields"}
	fieldName__TypeStruct_Representation_serial = _String{"representation"}
)
var _ ipld.Node = &_TypeStruct__Repr{}
func (_TypeStruct__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeStruct__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "fields":
		return n.fields.Representation(), nil
	case "representation":
		return n.representation.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeStruct__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeStruct__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.LookupByIndex(0)
}
func (n _TypeStruct__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeStruct__Repr) MapIterator() ipld.MapIterator {
	return &_TypeStruct__ReprMapItr{n, 0}
}

type _TypeStruct__ReprMapItr struct {
	n   *_TypeStruct__Repr
	idx int
	
}

func (itr *_TypeStruct__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeStruct_Fields_serial
		v = itr.n.fields.Representation()
	case 1:
		k = &fieldName__TypeStruct_Representation_serial
		v = itr.n.representation.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeStruct__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TypeStruct__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeStruct__Repr) Length() int {
	l := 2
	return l
}
func (_TypeStruct__Repr) IsAbsent() bool {
	return false
}
func (_TypeStruct__Repr) IsNull() bool {
	return false
}
func (_TypeStruct__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsBool()
}
func (_TypeStruct__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsInt()
}
func (_TypeStruct__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsFloat()
}
func (_TypeStruct__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsString()
}
func (_TypeStruct__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsBytes()
}
func (_TypeStruct__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeStruct.Repr"}.AsLink()
}
func (_TypeStruct__Repr) Prototype() ipld.NodePrototype {
	return _TypeStruct__ReprPrototype{}
}
type _TypeStruct__ReprPrototype struct{}

func (_TypeStruct__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeStruct__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeStruct__ReprBuilder struct {
	_TypeStruct__ReprAssembler
}
func (nb *_TypeStruct__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeStruct__ReprBuilder) Reset() {
	var w _TypeStruct
	var m schema.Maybe
	*nb = _TypeStruct__ReprBuilder{_TypeStruct__ReprAssembler{w: &w, m: &m}}
}
type _TypeStruct__ReprAssembler struct {
	w *_TypeStruct
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_fields _Map__FieldName__StructField__ReprAssembler
	ca_representation _StructRepresentation__ReprAssembler
	}

func (na *_TypeStruct__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_fields.reset()
	na.ca_representation.reset()
}
func (na *_TypeStruct__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeStruct{}
	}
	return na, nil
}
func (_TypeStruct__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.BeginList(0)
}
func (na *_TypeStruct__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeStruct.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeStruct__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignBool(false)
}
func (_TypeStruct__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignInt(0)
}
func (_TypeStruct__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignFloat(0)
}
func (_TypeStruct__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignString("")
}
func (_TypeStruct__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignBytes(nil)
}
func (_TypeStruct__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeStruct.Repr"}.AssignLink(nil)
}
func (na *_TypeStruct__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeStruct); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeStruct.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeStruct__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeStruct__ReprPrototype{}
}
func (ma *_TypeStruct__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeStruct__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "fields":
		if ma.s & fieldBit__TypeStruct_Fields != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Fields_serial}
		}
		ma.s += fieldBit__TypeStruct_Fields
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_fields.w = &ma.w.fields
		ma.ca_fields.m = &ma.cm
		return &ma.ca_fields, nil
	case "representation":
		if ma.s & fieldBit__TypeStruct_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Representation_serial}
		}
		ma.s += fieldBit__TypeStruct_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeStruct.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeStruct__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeStruct__ReprKeyAssembler)(ma)
}
func (ma *_TypeStruct__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_fields.w = &ma.w.fields
		ma.ca_fields.m = &ma.cm
		return &ma.ca_fields
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeStruct__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeStruct__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeStruct__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeStruct__ReprKeyAssembler _TypeStruct__ReprAssembler
func (_TypeStruct__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeStruct__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeStruct__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeStruct__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeStruct__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeStruct__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeStruct__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "fields":
		if ka.s & fieldBit__TypeStruct_Fields != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Fields_serial}
		}
		ka.s += fieldBit__TypeStruct_Fields
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeStruct_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeStruct_Representation_serial}
		}
		ka.s += fieldBit__TypeStruct_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeStruct.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeStruct__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeStruct__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeStruct.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeStruct__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeStruct__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _TypeUnion) FieldMembers() List__TypeName {
	return &n.members
}
func (n _TypeUnion) FieldRepresentation() UnionRepresentation {
	return &n.representation
}
type _TypeUnion__Maybe struct {
	m schema.Maybe
	v TypeUnion
}
type MaybeTypeUnion = *_TypeUnion__Maybe

func (m MaybeTypeUnion) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTypeUnion) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTypeUnion) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTypeUnion) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTypeUnion) Must() TypeUnion {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__TypeUnion_Members = _String{"members"}
	fieldName__TypeUnion_Representation = _String{"representation"}
)
var _ ipld.Node = (TypeUnion)(&_TypeUnion{})
var _ schema.TypedNode = (TypeUnion)(&_TypeUnion{})
func (TypeUnion) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n TypeUnion) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "members":
		return &n.members, nil
	case "representation":
		return &n.representation, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TypeUnion) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TypeUnion) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.LookupByIndex(0)
}
func (n TypeUnion) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TypeUnion) MapIterator() ipld.MapIterator {
	return &_TypeUnion__MapItr{n, 0}
}

type _TypeUnion__MapItr struct {
	n TypeUnion
	idx  int
}

func (itr *_TypeUnion__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeUnion_Members
		v = &itr.n.members
	case 1:
		k = &fieldName__TypeUnion_Representation
		v = &itr.n.representation
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeUnion__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TypeUnion) ListIterator() ipld.ListIterator {
	return nil
}
func (TypeUnion) Length() int {
	return 2
}
func (TypeUnion) IsAbsent() bool {
	return false
}
func (TypeUnion) IsNull() bool {
	return false
}
func (TypeUnion) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsBool()
}
func (TypeUnion) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsInt()
}
func (TypeUnion) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsFloat()
}
func (TypeUnion) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsString()
}
func (TypeUnion) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsBytes()
}
func (TypeUnion) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeUnion"}.AsLink()
}
func (TypeUnion) Prototype() ipld.NodePrototype {
	return _TypeUnion__Prototype{}
}
type _TypeUnion__Prototype struct{}

func (_TypeUnion__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeUnion__Builder
	nb.Reset()
	return &nb
}
type _TypeUnion__Builder struct {
	_TypeUnion__Assembler
}
func (nb *_TypeUnion__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeUnion__Builder) Reset() {
	var w _TypeUnion
	var m schema.Maybe
	*nb = _TypeUnion__Builder{_TypeUnion__Assembler{w: &w, m: &m}}
}
type _TypeUnion__Assembler struct {
	w *_TypeUnion
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_members _List__TypeName__Assembler
	ca_representation _UnionRepresentation__Assembler
	}

func (na *_TypeUnion__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_members.reset()
	na.ca_representation.reset()
}

var (
	fieldBit__TypeUnion_Members = 1 << 0
	fieldBit__TypeUnion_Representation = 1 << 1
	fieldBits__TypeUnion_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_TypeUnion__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeUnion{}
	}
	return na, nil
}
func (_TypeUnion__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.BeginList(0)
}
func (na *_TypeUnion__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeUnion__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignBool(false)
}
func (_TypeUnion__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignInt(0)
}
func (_TypeUnion__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignFloat(0)
}
func (_TypeUnion__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignString("")
}
func (_TypeUnion__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignBytes(nil)
}
func (_TypeUnion__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion"}.AssignLink(nil)
}
func (na *_TypeUnion__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeUnion); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeUnion", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeUnion__Assembler) Prototype() ipld.NodePrototype {
	return _TypeUnion__Prototype{}
}
func (ma *_TypeUnion__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_members.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_representation.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeUnion__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "members":
		if ma.s & fieldBit__TypeUnion_Members != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Members}
		}
		ma.s += fieldBit__TypeUnion_Members
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members, nil
	case "representation":
		if ma.s & fieldBit__TypeUnion_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Representation}
		}
		ma.s += fieldBit__TypeUnion_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeUnion", Key:&_String{k}}
	}
}
func (ma *_TypeUnion__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeUnion__KeyAssembler)(ma)
}
func (ma *_TypeUnion__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeUnion__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeUnion__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeUnion__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _TypeUnion__KeyAssembler _TypeUnion__Assembler
func (_TypeUnion__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.BeginMap(0)
}
func (_TypeUnion__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.BeginList(0)
}
func (na *_TypeUnion__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignNull()
}
func (_TypeUnion__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignBool(false)
}
func (_TypeUnion__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignInt(0)
}
func (_TypeUnion__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeUnion__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "members":
		if ka.s & fieldBit__TypeUnion_Members != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Members}
		}
		ka.s += fieldBit__TypeUnion_Members
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeUnion_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Representation}
		}
		ka.s += fieldBit__TypeUnion_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeUnion", Key:&_String{k}}
	}
	return nil
}
func (_TypeUnion__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeUnion__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeUnion__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeUnion__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TypeUnion) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TypeUnion) Representation() ipld.Node {
	return (*_TypeUnion__Repr)(n)
}
type _TypeUnion__Repr _TypeUnion
var (
	fieldName__TypeUnion_Members_serial = _String{"members"}
	fieldName__TypeUnion_Representation_serial = _String{"representation"}
)
var _ ipld.Node = &_TypeUnion__Repr{}
func (_TypeUnion__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_TypeUnion__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "members":
		return n.members.Representation(), nil
	case "representation":
		return n.representation.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TypeUnion__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TypeUnion__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.LookupByIndex(0)
}
func (n _TypeUnion__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TypeUnion__Repr) MapIterator() ipld.MapIterator {
	return &_TypeUnion__ReprMapItr{n, 0}
}

type _TypeUnion__ReprMapItr struct {
	n   *_TypeUnion__Repr
	idx int
	
}

func (itr *_TypeUnion__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TypeUnion_Members_serial
		v = itr.n.members.Representation()
	case 1:
		k = &fieldName__TypeUnion_Representation_serial
		v = itr.n.representation.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TypeUnion__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TypeUnion__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TypeUnion__Repr) Length() int {
	l := 2
	return l
}
func (_TypeUnion__Repr) IsAbsent() bool {
	return false
}
func (_TypeUnion__Repr) IsNull() bool {
	return false
}
func (_TypeUnion__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsBool()
}
func (_TypeUnion__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsInt()
}
func (_TypeUnion__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsFloat()
}
func (_TypeUnion__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsString()
}
func (_TypeUnion__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsBytes()
}
func (_TypeUnion__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.TypeUnion.Repr"}.AsLink()
}
func (_TypeUnion__Repr) Prototype() ipld.NodePrototype {
	return _TypeUnion__ReprPrototype{}
}
type _TypeUnion__ReprPrototype struct{}

func (_TypeUnion__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TypeUnion__ReprBuilder
	nb.Reset()
	return &nb
}
type _TypeUnion__ReprBuilder struct {
	_TypeUnion__ReprAssembler
}
func (nb *_TypeUnion__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TypeUnion__ReprBuilder) Reset() {
	var w _TypeUnion
	var m schema.Maybe
	*nb = _TypeUnion__ReprBuilder{_TypeUnion__ReprAssembler{w: &w, m: &m}}
}
type _TypeUnion__ReprAssembler struct {
	w *_TypeUnion
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_members _List__TypeName__ReprAssembler
	ca_representation _UnionRepresentation__ReprAssembler
	}

func (na *_TypeUnion__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_members.reset()
	na.ca_representation.reset()
}
func (na *_TypeUnion__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TypeUnion{}
	}
	return na, nil
}
func (_TypeUnion__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.BeginList(0)
}
func (na *_TypeUnion__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.TypeUnion.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TypeUnion__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignBool(false)
}
func (_TypeUnion__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignInt(0)
}
func (_TypeUnion__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignFloat(0)
}
func (_TypeUnion__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignString("")
}
func (_TypeUnion__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignBytes(nil)
}
func (_TypeUnion__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.TypeUnion.Repr"}.AssignLink(nil)
}
func (na *_TypeUnion__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TypeUnion); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.TypeUnion.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TypeUnion__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TypeUnion__ReprPrototype{}
}
func (ma *_TypeUnion__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TypeUnion__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "members":
		if ma.s & fieldBit__TypeUnion_Members != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Members_serial}
		}
		ma.s += fieldBit__TypeUnion_Members
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members, nil
	case "representation":
		if ma.s & fieldBit__TypeUnion_Representation != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Representation_serial}
		}
		ma.s += fieldBit__TypeUnion_Representation
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.TypeUnion.Repr", Key:&_String{k}}
	}
}
func (ma *_TypeUnion__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TypeUnion__ReprKeyAssembler)(ma)
}
func (ma *_TypeUnion__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_members.w = &ma.w.members
		ma.ca_members.m = &ma.cm
		return &ma.ca_members
	case 1:
		ma.ca_representation.w = &ma.w.representation
		ma.ca_representation.m = &ma.cm
		return &ma.ca_representation
	default:
		panic("unreachable")
	}
}
func (ma *_TypeUnion__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TypeUnion__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TypeUnion__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _TypeUnion__ReprKeyAssembler _TypeUnion__ReprAssembler
func (_TypeUnion__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TypeUnion__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TypeUnion__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignNull()
}
func (_TypeUnion__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TypeUnion__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TypeUnion__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TypeUnion__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "members":
		if ka.s & fieldBit__TypeUnion_Members != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Members_serial}
		}
		ka.s += fieldBit__TypeUnion_Members
		ka.state = maState_expectValue
		ka.f = 0
	case "representation":
		if ka.s & fieldBit__TypeUnion_Representation != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__TypeUnion_Representation_serial}
		}
		ka.s += fieldBit__TypeUnion_Representation
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.TypeUnion.Repr", Key:&_String{k}}
	}
	return nil
}
func (_TypeUnion__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TypeUnion__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.TypeUnion.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TypeUnion__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TypeUnion__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _UnionRepresentation) AsInterface() _UnionRepresentation__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	case 6:
		return &n.x6
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _UnionRepresentation__Maybe struct {
	m schema.Maybe
	v UnionRepresentation
}
type MaybeUnionRepresentation = *_UnionRepresentation__Maybe

func (m MaybeUnionRepresentation) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation) Must() UnionRepresentation {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__UnionRepresentation_UnionRepresentation_Kinded = _String{"UnionRepresentation_Kinded"}
	memberName__UnionRepresentation_UnionRepresentation_Keyed = _String{"UnionRepresentation_Keyed"}
	memberName__UnionRepresentation_UnionRepresentation_Envelope = _String{"UnionRepresentation_Envelope"}
	memberName__UnionRepresentation_UnionRepresentation_Inline = _String{"UnionRepresentation_Inline"}
	memberName__UnionRepresentation_UnionRepresentation_StringPrefix = _String{"UnionRepresentation_StringPrefix"}
	memberName__UnionRepresentation_UnionRepresentation_BytePrefix = _String{"UnionRepresentation_BytePrefix"}
)
var _ ipld.Node = (UnionRepresentation)(&_UnionRepresentation{})
var _ schema.TypedNode = (UnionRepresentation)(&_UnionRepresentation{})
func (UnionRepresentation) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "UnionRepresentation_Kinded":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "UnionRepresentation_Keyed":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "UnionRepresentation_Envelope":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "UnionRepresentation_Inline":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "UnionRepresentation_StringPrefix":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	case "UnionRepresentation_BytePrefix":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x6, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UnionRepresentation) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UnionRepresentation) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.LookupByIndex(0)
}
func (n UnionRepresentation) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation__MapItr{n, false}
}

type _UnionRepresentation__MapItr struct {
	n UnionRepresentation
	done bool
}

func (itr *_UnionRepresentation__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Kinded, &itr.n.x1
	case 2:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Keyed, &itr.n.x2
	case 3:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Envelope, &itr.n.x3
	case 4:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Inline, &itr.n.x4
	case 5:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_StringPrefix, &itr.n.x5
	case 6:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_BytePrefix, &itr.n.x6
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_UnionRepresentation__MapItr) Done() bool {
	return itr.done
}

func (UnionRepresentation) ListIterator() ipld.ListIterator {
	return nil
}
func (UnionRepresentation) Length() int {
	return 1
}
func (UnionRepresentation) IsAbsent() bool {
	return false
}
func (UnionRepresentation) IsNull() bool {
	return false
}
func (UnionRepresentation) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsBool()
}
func (UnionRepresentation) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsInt()
}
func (UnionRepresentation) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsFloat()
}
func (UnionRepresentation) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsString()
}
func (UnionRepresentation) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsBytes()
}
func (UnionRepresentation) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation"}.AsLink()
}
func (UnionRepresentation) Prototype() ipld.NodePrototype {
	return _UnionRepresentation__Prototype{}
}
type _UnionRepresentation__Prototype struct{}

func (_UnionRepresentation__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation__Builder struct {
	_UnionRepresentation__Assembler
}
func (nb *_UnionRepresentation__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation__Builder) Reset() {
	var w _UnionRepresentation
	var m schema.Maybe
	*nb = _UnionRepresentation__Builder{_UnionRepresentation__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation__Assembler struct {
	w *_UnionRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _UnionRepresentation_Kinded__Assembler
	
	ca2 _UnionRepresentation_Keyed__Assembler
	
	ca3 _UnionRepresentation_Envelope__Assembler
	
	ca4 _UnionRepresentation_Inline__Assembler
	
	ca5 _UnionRepresentation_StringPrefix__Assembler
	
	ca6 _UnionRepresentation_BytePrefix__Assembler
	ca uint
}
func (na *_UnionRepresentation__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_UnionRepresentation__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation{}
	}
	return na, nil
}
func (_UnionRepresentation__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.BeginList(0)
}
func (na *_UnionRepresentation__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignBool(false)
}
func (_UnionRepresentation__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignInt(0)
}
func (_UnionRepresentation__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignFloat(0)
}
func (_UnionRepresentation__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignString("")
}
func (_UnionRepresentation__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignBytes(nil)
}
func (_UnionRepresentation__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation"}.AssignLink(nil)
}
func (na *_UnionRepresentation__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation__Prototype{}
}
func (ma *_UnionRepresentation__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "UnionRepresentation_Kinded":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "UnionRepresentation_Keyed":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "UnionRepresentation_Envelope":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "UnionRepresentation_Inline":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "UnionRepresentation_StringPrefix":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "UnionRepresentation_BytePrefix":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation__KeyAssembler)(ma)
}
func (ma *_UnionRepresentation__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "UnionRepresentation_Kinded":
		return _UnionRepresentation_Kinded__Prototype{}
	case "UnionRepresentation_Keyed":
		return _UnionRepresentation_Keyed__Prototype{}
	case "UnionRepresentation_Envelope":
		return _UnionRepresentation_Envelope__Prototype{}
	case "UnionRepresentation_Inline":
		return _UnionRepresentation_Inline__Prototype{}
	case "UnionRepresentation_StringPrefix":
		return _UnionRepresentation_StringPrefix__Prototype{}
	case "UnionRepresentation_BytePrefix":
		return _UnionRepresentation_BytePrefix__Prototype{}
	default:
		return nil
	}
}
type _UnionRepresentation__KeyAssembler _UnionRepresentation__Assembler
func (_UnionRepresentation__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "UnionRepresentation_Kinded":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "UnionRepresentation_Keyed":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "UnionRepresentation_Envelope":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "UnionRepresentation_Inline":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "UnionRepresentation_StringPrefix":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "UnionRepresentation_BytePrefix":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_UnionRepresentation__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UnionRepresentation) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation) Representation() ipld.Node {
	return (*_UnionRepresentation__Repr)(n)
}
type _UnionRepresentation__Repr _UnionRepresentation
var (
	memberName__UnionRepresentation_UnionRepresentation_Kinded_serial = _String{"kinded"}
	memberName__UnionRepresentation_UnionRepresentation_Keyed_serial = _String{"keyed"}
	memberName__UnionRepresentation_UnionRepresentation_Envelope_serial = _String{"envelope"}
	memberName__UnionRepresentation_UnionRepresentation_Inline_serial = _String{"inline"}
	memberName__UnionRepresentation_UnionRepresentation_StringPrefix_serial = _String{"stringprefix"}
	memberName__UnionRepresentation_UnionRepresentation_BytePrefix_serial = _String{"byteprefix"}
)
var _ ipld.Node = &_UnionRepresentation__Repr{}
func (_UnionRepresentation__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_UnionRepresentation__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "kinded":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "keyed":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "envelope":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "inline":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	case "stringprefix":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x5.Representation(), nil
	case "byteprefix":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.x6.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UnionRepresentation__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UnionRepresentation__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UnionRepresentation__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation__ReprMapItr{n, false}
}

type _UnionRepresentation__ReprMapItr struct {
	n *_UnionRepresentation__Repr
	done bool
}

func (itr *_UnionRepresentation__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Kinded_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Keyed_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Envelope_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_Inline_serial, itr.n.x4.Representation()
	case 5:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_StringPrefix_serial, itr.n.x5.Representation()
	case 6:
		k, v = &memberName__UnionRepresentation_UnionRepresentation_BytePrefix_serial, itr.n.x6.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_UnionRepresentation__ReprMapItr) Done() bool {
	return itr.done
}

func (_UnionRepresentation__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_UnionRepresentation__Repr) Length() int {
	return 1
}
func (_UnionRepresentation__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsBool()
}
func (_UnionRepresentation__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsInt()
}
func (_UnionRepresentation__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsFloat()
}
func (_UnionRepresentation__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsString()
}
func (_UnionRepresentation__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsBytes()
}
func (_UnionRepresentation__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation.Repr"}.AsLink()
}
func (_UnionRepresentation__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation__ReprPrototype{}
}
type _UnionRepresentation__ReprPrototype struct{}

func (_UnionRepresentation__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation__ReprBuilder struct {
	_UnionRepresentation__ReprAssembler
}
func (nb *_UnionRepresentation__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation__ReprBuilder) Reset() {
	var w _UnionRepresentation
	var m schema.Maybe
	*nb = _UnionRepresentation__ReprBuilder{_UnionRepresentation__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation__ReprAssembler struct {
	w *_UnionRepresentation
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _UnionRepresentation_Kinded__ReprAssembler
	
	ca2 _UnionRepresentation_Keyed__ReprAssembler
	
	ca3 _UnionRepresentation_Envelope__ReprAssembler
	
	ca4 _UnionRepresentation_Inline__ReprAssembler
	
	ca5 _UnionRepresentation_StringPrefix__ReprAssembler
	
	ca6 _UnionRepresentation_BytePrefix__ReprAssembler
	ca uint
}
func (na *_UnionRepresentation__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_UnionRepresentation__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation{}
	}
	return na, nil
}
func (_UnionRepresentation__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignBool(false)
}
func (_UnionRepresentation__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignInt(0)
}
func (_UnionRepresentation__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignString("")
}
func (_UnionRepresentation__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation__ReprPrototype{}
}
func (ma *_UnionRepresentation__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "kinded":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "keyed":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "envelope":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "inline":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "stringprefix":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "byteprefix":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation.Repr", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation__ReprKeyAssembler)(ma)
}
func (ma *_UnionRepresentation__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "UnionRepresentation_Kinded":
		return _UnionRepresentation_Kinded__ReprPrototype{}
	case "UnionRepresentation_Keyed":
		return _UnionRepresentation_Keyed__ReprPrototype{}
	case "UnionRepresentation_Envelope":
		return _UnionRepresentation_Envelope__ReprPrototype{}
	case "UnionRepresentation_Inline":
		return _UnionRepresentation_Inline__ReprPrototype{}
	case "UnionRepresentation_StringPrefix":
		return _UnionRepresentation_StringPrefix__ReprPrototype{}
	case "UnionRepresentation_BytePrefix":
		return _UnionRepresentation_BytePrefix__ReprPrototype{}
	default:
		return nil
	}
}
type _UnionRepresentation__ReprKeyAssembler _UnionRepresentation__ReprAssembler
func (_UnionRepresentation__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"schemadmt.UnionRepresentation.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "kinded":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "keyed":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "envelope":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "inline":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "stringprefix":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "byteprefix":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation.Repr", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_UnionRepresentation__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _UnionRepresentation_BytePrefix) FieldDiscriminantTable() Map__TypeName__Int {
	return &n.discriminantTable
}
type _UnionRepresentation_BytePrefix__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_BytePrefix
}
type MaybeUnionRepresentation_BytePrefix = *_UnionRepresentation_BytePrefix__Maybe

func (m MaybeUnionRepresentation_BytePrefix) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_BytePrefix) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_BytePrefix) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_BytePrefix) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_BytePrefix) Must() UnionRepresentation_BytePrefix {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__UnionRepresentation_BytePrefix_DiscriminantTable = _String{"discriminantTable"}
)
var _ ipld.Node = (UnionRepresentation_BytePrefix)(&_UnionRepresentation_BytePrefix{})
var _ schema.TypedNode = (UnionRepresentation_BytePrefix)(&_UnionRepresentation_BytePrefix{})
func (UnionRepresentation_BytePrefix) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_BytePrefix) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantTable":
		return &n.discriminantTable, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UnionRepresentation_BytePrefix) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UnionRepresentation_BytePrefix) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.LookupByIndex(0)
}
func (n UnionRepresentation_BytePrefix) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_BytePrefix) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_BytePrefix__MapItr{n, 0}
}

type _UnionRepresentation_BytePrefix__MapItr struct {
	n UnionRepresentation_BytePrefix
	idx  int
}

func (itr *_UnionRepresentation_BytePrefix__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_BytePrefix_DiscriminantTable
		v = &itr.n.discriminantTable
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_BytePrefix__MapItr) Done() bool {
	return itr.idx >= 1
}

func (UnionRepresentation_BytePrefix) ListIterator() ipld.ListIterator {
	return nil
}
func (UnionRepresentation_BytePrefix) Length() int {
	return 1
}
func (UnionRepresentation_BytePrefix) IsAbsent() bool {
	return false
}
func (UnionRepresentation_BytePrefix) IsNull() bool {
	return false
}
func (UnionRepresentation_BytePrefix) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsBool()
}
func (UnionRepresentation_BytePrefix) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsInt()
}
func (UnionRepresentation_BytePrefix) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsFloat()
}
func (UnionRepresentation_BytePrefix) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsString()
}
func (UnionRepresentation_BytePrefix) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsBytes()
}
func (UnionRepresentation_BytePrefix) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix"}.AsLink()
}
func (UnionRepresentation_BytePrefix) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_BytePrefix__Prototype{}
}
type _UnionRepresentation_BytePrefix__Prototype struct{}

func (_UnionRepresentation_BytePrefix__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_BytePrefix__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_BytePrefix__Builder struct {
	_UnionRepresentation_BytePrefix__Assembler
}
func (nb *_UnionRepresentation_BytePrefix__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_BytePrefix__Builder) Reset() {
	var w _UnionRepresentation_BytePrefix
	var m schema.Maybe
	*nb = _UnionRepresentation_BytePrefix__Builder{_UnionRepresentation_BytePrefix__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_BytePrefix__Assembler struct {
	w *_UnionRepresentation_BytePrefix
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantTable _Map__TypeName__Int__Assembler
	}

func (na *_UnionRepresentation_BytePrefix__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantTable.reset()
}

var (
	fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable = 1 << 0
	fieldBits__UnionRepresentation_BytePrefix_sufficient = 0 + 1 << 0
)
func (na *_UnionRepresentation_BytePrefix__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_BytePrefix{}
	}
	return na, nil
}
func (_UnionRepresentation_BytePrefix__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.BeginList(0)
}
func (na *_UnionRepresentation_BytePrefix__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignBool(false)
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignInt(0)
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignFloat(0)
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignString("")
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignBytes(nil)
}
func (_UnionRepresentation_BytePrefix__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix"}.AssignLink(nil)
}
func (na *_UnionRepresentation_BytePrefix__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_BytePrefix); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_BytePrefix", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_BytePrefix__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_BytePrefix__Prototype{}
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantTable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_BytePrefix_DiscriminantTable}
		}
		ma.s += fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_BytePrefix", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_BytePrefix__KeyAssembler)(ma)
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_BytePrefix__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _UnionRepresentation_BytePrefix__KeyAssembler _UnionRepresentation_BytePrefix__Assembler
func (_UnionRepresentation_BytePrefix__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_BytePrefix__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_BytePrefix__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_BytePrefix_DiscriminantTable}
		}
		ka.s += fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_BytePrefix", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_BytePrefix__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_BytePrefix__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UnionRepresentation_BytePrefix) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_BytePrefix) Representation() ipld.Node {
	return (*_UnionRepresentation_BytePrefix__Repr)(n)
}
type _UnionRepresentation_BytePrefix__Repr _UnionRepresentation_BytePrefix
var (
	fieldName__UnionRepresentation_BytePrefix_DiscriminantTable_serial = _String{"discriminantTable"}
)
var _ ipld.Node = &_UnionRepresentation_BytePrefix__Repr{}
func (_UnionRepresentation_BytePrefix__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_UnionRepresentation_BytePrefix__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantTable":
		return n.discriminantTable.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UnionRepresentation_BytePrefix__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UnionRepresentation_BytePrefix__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_BytePrefix__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UnionRepresentation_BytePrefix__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_BytePrefix__ReprMapItr{n, 0}
}

type _UnionRepresentation_BytePrefix__ReprMapItr struct {
	n   *_UnionRepresentation_BytePrefix__Repr
	idx int
	
}

func (itr *_UnionRepresentation_BytePrefix__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_BytePrefix_DiscriminantTable_serial
		v = itr.n.discriminantTable.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_BytePrefix__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_UnionRepresentation_BytePrefix__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_BytePrefix__Repr) Length() int {
	l := 1
	return l
}
func (_UnionRepresentation_BytePrefix__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_BytePrefix__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_BytePrefix__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsBool()
}
func (_UnionRepresentation_BytePrefix__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsInt()
}
func (_UnionRepresentation_BytePrefix__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsFloat()
}
func (_UnionRepresentation_BytePrefix__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsString()
}
func (_UnionRepresentation_BytePrefix__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsBytes()
}
func (_UnionRepresentation_BytePrefix__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AsLink()
}
func (_UnionRepresentation_BytePrefix__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_BytePrefix__ReprPrototype{}
}
type _UnionRepresentation_BytePrefix__ReprPrototype struct{}

func (_UnionRepresentation_BytePrefix__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_BytePrefix__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_BytePrefix__ReprBuilder struct {
	_UnionRepresentation_BytePrefix__ReprAssembler
}
func (nb *_UnionRepresentation_BytePrefix__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_BytePrefix__ReprBuilder) Reset() {
	var w _UnionRepresentation_BytePrefix
	var m schema.Maybe
	*nb = _UnionRepresentation_BytePrefix__ReprBuilder{_UnionRepresentation_BytePrefix__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_BytePrefix__ReprAssembler struct {
	w *_UnionRepresentation_BytePrefix
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantTable _Map__TypeName__Int__ReprAssembler
	}

func (na *_UnionRepresentation_BytePrefix__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantTable.reset()
}
func (na *_UnionRepresentation_BytePrefix__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_BytePrefix{}
	}
	return na, nil
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_BytePrefix__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignString("")
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_BytePrefix__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_BytePrefix); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_BytePrefix.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_BytePrefix__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_BytePrefix__ReprPrototype{}
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_BytePrefix_DiscriminantTable_serial}
		}
		ma.s += fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_BytePrefix.Repr", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_BytePrefix__ReprKeyAssembler)(ma)
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_BytePrefix__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _UnionRepresentation_BytePrefix__ReprKeyAssembler _UnionRepresentation_BytePrefix__ReprAssembler
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_BytePrefix_DiscriminantTable_serial}
		}
		ka.s += fieldBit__UnionRepresentation_BytePrefix_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_BytePrefix.Repr", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_BytePrefix.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_BytePrefix__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_BytePrefix__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _UnionRepresentation_Envelope) FieldDiscriminantKey() String {
	return &n.discriminantKey
}
func (n _UnionRepresentation_Envelope) FieldContentKey() String {
	return &n.contentKey
}
func (n _UnionRepresentation_Envelope) FieldDiscriminantTable() Map__String__TypeName {
	return &n.discriminantTable
}
type _UnionRepresentation_Envelope__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_Envelope
}
type MaybeUnionRepresentation_Envelope = *_UnionRepresentation_Envelope__Maybe

func (m MaybeUnionRepresentation_Envelope) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_Envelope) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_Envelope) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_Envelope) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_Envelope) Must() UnionRepresentation_Envelope {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__UnionRepresentation_Envelope_DiscriminantKey = _String{"discriminantKey"}
	fieldName__UnionRepresentation_Envelope_ContentKey = _String{"contentKey"}
	fieldName__UnionRepresentation_Envelope_DiscriminantTable = _String{"discriminantTable"}
)
var _ ipld.Node = (UnionRepresentation_Envelope)(&_UnionRepresentation_Envelope{})
var _ schema.TypedNode = (UnionRepresentation_Envelope)(&_UnionRepresentation_Envelope{})
func (UnionRepresentation_Envelope) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_Envelope) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantKey":
		return &n.discriminantKey, nil
	case "contentKey":
		return &n.contentKey, nil
	case "discriminantTable":
		return &n.discriminantTable, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UnionRepresentation_Envelope) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UnionRepresentation_Envelope) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.LookupByIndex(0)
}
func (n UnionRepresentation_Envelope) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_Envelope) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Envelope__MapItr{n, 0}
}

type _UnionRepresentation_Envelope__MapItr struct {
	n UnionRepresentation_Envelope
	idx  int
}

func (itr *_UnionRepresentation_Envelope__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_Envelope_DiscriminantKey
		v = &itr.n.discriminantKey
	case 1:
		k = &fieldName__UnionRepresentation_Envelope_ContentKey
		v = &itr.n.contentKey
	case 2:
		k = &fieldName__UnionRepresentation_Envelope_DiscriminantTable
		v = &itr.n.discriminantTable
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Envelope__MapItr) Done() bool {
	return itr.idx >= 3
}

func (UnionRepresentation_Envelope) ListIterator() ipld.ListIterator {
	return nil
}
func (UnionRepresentation_Envelope) Length() int {
	return 3
}
func (UnionRepresentation_Envelope) IsAbsent() bool {
	return false
}
func (UnionRepresentation_Envelope) IsNull() bool {
	return false
}
func (UnionRepresentation_Envelope) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsBool()
}
func (UnionRepresentation_Envelope) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsInt()
}
func (UnionRepresentation_Envelope) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsFloat()
}
func (UnionRepresentation_Envelope) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsString()
}
func (UnionRepresentation_Envelope) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsBytes()
}
func (UnionRepresentation_Envelope) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope"}.AsLink()
}
func (UnionRepresentation_Envelope) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Envelope__Prototype{}
}
type _UnionRepresentation_Envelope__Prototype struct{}

func (_UnionRepresentation_Envelope__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Envelope__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Envelope__Builder struct {
	_UnionRepresentation_Envelope__Assembler
}
func (nb *_UnionRepresentation_Envelope__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Envelope__Builder) Reset() {
	var w _UnionRepresentation_Envelope
	var m schema.Maybe
	*nb = _UnionRepresentation_Envelope__Builder{_UnionRepresentation_Envelope__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_Envelope__Assembler struct {
	w *_UnionRepresentation_Envelope
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantKey _String__Assembler
	ca_contentKey _String__Assembler
	ca_discriminantTable _Map__String__TypeName__Assembler
	}

func (na *_UnionRepresentation_Envelope__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantKey.reset()
	na.ca_contentKey.reset()
	na.ca_discriminantTable.reset()
}

var (
	fieldBit__UnionRepresentation_Envelope_DiscriminantKey = 1 << 0
	fieldBit__UnionRepresentation_Envelope_ContentKey = 1 << 1
	fieldBit__UnionRepresentation_Envelope_DiscriminantTable = 1 << 2
	fieldBits__UnionRepresentation_Envelope_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2
)
func (na *_UnionRepresentation_Envelope__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_Envelope{}
	}
	return na, nil
}
func (_UnionRepresentation_Envelope__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.BeginList(0)
}
func (na *_UnionRepresentation_Envelope__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Envelope__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignBool(false)
}
func (_UnionRepresentation_Envelope__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignInt(0)
}
func (_UnionRepresentation_Envelope__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignFloat(0)
}
func (_UnionRepresentation_Envelope__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignString("")
}
func (_UnionRepresentation_Envelope__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignBytes(nil)
}
func (_UnionRepresentation_Envelope__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Envelope__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Envelope); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Envelope", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Envelope__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Envelope__Prototype{}
}
func (ma *_UnionRepresentation_Envelope__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_contentKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantTable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Envelope__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantKey":
		if ma.s & fieldBit__UnionRepresentation_Envelope_DiscriminantKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantKey}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_DiscriminantKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey, nil
	case "contentKey":
		if ma.s & fieldBit__UnionRepresentation_Envelope_ContentKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_ContentKey}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_ContentKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_contentKey.w = &ma.w.contentKey
		ma.ca_contentKey.m = &ma.cm
		return &ma.ca_contentKey, nil
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_Envelope_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantTable}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Envelope", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_Envelope__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_Envelope__KeyAssembler)(ma)
}
func (ma *_UnionRepresentation_Envelope__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey
	case 1:
		ma.ca_contentKey.w = &ma.w.contentKey
		ma.ca_contentKey.m = &ma.cm
		return &ma.ca_contentKey
	case 2:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Envelope__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Envelope__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_Envelope__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _UnionRepresentation_Envelope__KeyAssembler _UnionRepresentation_Envelope__Assembler
func (_UnionRepresentation_Envelope__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_Envelope__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_Envelope__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_Envelope__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_Envelope__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_Envelope__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_Envelope__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantKey":
		if ka.s & fieldBit__UnionRepresentation_Envelope_DiscriminantKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantKey}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_DiscriminantKey
		ka.state = maState_expectValue
		ka.f = 0
	case "contentKey":
		if ka.s & fieldBit__UnionRepresentation_Envelope_ContentKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_ContentKey}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_ContentKey
		ka.state = maState_expectValue
		ka.f = 1
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_Envelope_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantTable}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Envelope", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_Envelope__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_Envelope__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_Envelope__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_Envelope__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UnionRepresentation_Envelope) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_Envelope) Representation() ipld.Node {
	return (*_UnionRepresentation_Envelope__Repr)(n)
}
type _UnionRepresentation_Envelope__Repr _UnionRepresentation_Envelope
var (
	fieldName__UnionRepresentation_Envelope_DiscriminantKey_serial = _String{"discriminantKey"}
	fieldName__UnionRepresentation_Envelope_ContentKey_serial = _String{"contentKey"}
	fieldName__UnionRepresentation_Envelope_DiscriminantTable_serial = _String{"discriminantTable"}
)
var _ ipld.Node = &_UnionRepresentation_Envelope__Repr{}
func (_UnionRepresentation_Envelope__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_UnionRepresentation_Envelope__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantKey":
		return n.discriminantKey.Representation(), nil
	case "contentKey":
		return n.contentKey.Representation(), nil
	case "discriminantTable":
		return n.discriminantTable.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UnionRepresentation_Envelope__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UnionRepresentation_Envelope__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_Envelope__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UnionRepresentation_Envelope__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Envelope__ReprMapItr{n, 0}
}

type _UnionRepresentation_Envelope__ReprMapItr struct {
	n   *_UnionRepresentation_Envelope__Repr
	idx int
	
}

func (itr *_UnionRepresentation_Envelope__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_Envelope_DiscriminantKey_serial
		v = itr.n.discriminantKey.Representation()
	case 1:
		k = &fieldName__UnionRepresentation_Envelope_ContentKey_serial
		v = itr.n.contentKey.Representation()
	case 2:
		k = &fieldName__UnionRepresentation_Envelope_DiscriminantTable_serial
		v = itr.n.discriminantTable.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Envelope__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_UnionRepresentation_Envelope__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_Envelope__Repr) Length() int {
	l := 3
	return l
}
func (_UnionRepresentation_Envelope__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_Envelope__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_Envelope__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsBool()
}
func (_UnionRepresentation_Envelope__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsInt()
}
func (_UnionRepresentation_Envelope__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsFloat()
}
func (_UnionRepresentation_Envelope__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsString()
}
func (_UnionRepresentation_Envelope__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsBytes()
}
func (_UnionRepresentation_Envelope__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Envelope.Repr"}.AsLink()
}
func (_UnionRepresentation_Envelope__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Envelope__ReprPrototype{}
}
type _UnionRepresentation_Envelope__ReprPrototype struct{}

func (_UnionRepresentation_Envelope__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Envelope__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Envelope__ReprBuilder struct {
	_UnionRepresentation_Envelope__ReprAssembler
}
func (nb *_UnionRepresentation_Envelope__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Envelope__ReprBuilder) Reset() {
	var w _UnionRepresentation_Envelope
	var m schema.Maybe
	*nb = _UnionRepresentation_Envelope__ReprBuilder{_UnionRepresentation_Envelope__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_Envelope__ReprAssembler struct {
	w *_UnionRepresentation_Envelope
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantKey _String__ReprAssembler
	ca_contentKey _String__ReprAssembler
	ca_discriminantTable _Map__String__TypeName__ReprAssembler
	}

func (na *_UnionRepresentation_Envelope__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantKey.reset()
	na.ca_contentKey.reset()
	na.ca_discriminantTable.reset()
}
func (na *_UnionRepresentation_Envelope__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_Envelope{}
	}
	return na, nil
}
func (_UnionRepresentation_Envelope__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_Envelope__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignString("")
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_Envelope__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Envelope.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Envelope__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Envelope); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Envelope.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Envelope__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Envelope__ReprPrototype{}
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantKey":
		if ma.s & fieldBit__UnionRepresentation_Envelope_DiscriminantKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantKey_serial}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_DiscriminantKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey, nil
	case "contentKey":
		if ma.s & fieldBit__UnionRepresentation_Envelope_ContentKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_ContentKey_serial}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_ContentKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_contentKey.w = &ma.w.contentKey
		ma.ca_contentKey.m = &ma.cm
		return &ma.ca_contentKey, nil
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_Envelope_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantTable_serial}
		}
		ma.s += fieldBit__UnionRepresentation_Envelope_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Envelope.Repr", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_Envelope__ReprKeyAssembler)(ma)
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey
	case 1:
		ma.ca_contentKey.w = &ma.w.contentKey
		ma.ca_contentKey.m = &ma.cm
		return &ma.ca_contentKey
	case 2:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_Envelope__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _UnionRepresentation_Envelope__ReprKeyAssembler _UnionRepresentation_Envelope__ReprAssembler
func (_UnionRepresentation_Envelope__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_Envelope__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_Envelope__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantKey":
		if ka.s & fieldBit__UnionRepresentation_Envelope_DiscriminantKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantKey_serial}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_DiscriminantKey
		ka.state = maState_expectValue
		ka.f = 0
	case "contentKey":
		if ka.s & fieldBit__UnionRepresentation_Envelope_ContentKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_ContentKey_serial}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_ContentKey
		ka.state = maState_expectValue
		ka.f = 1
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_Envelope_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Envelope_DiscriminantTable_serial}
		}
		ka.s += fieldBit__UnionRepresentation_Envelope_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Envelope.Repr", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Envelope.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_Envelope__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_Envelope__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _UnionRepresentation_Inline) FieldDiscriminantKey() String {
	return &n.discriminantKey
}
func (n _UnionRepresentation_Inline) FieldDiscriminantTable() Map__String__TypeName {
	return &n.discriminantTable
}
type _UnionRepresentation_Inline__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_Inline
}
type MaybeUnionRepresentation_Inline = *_UnionRepresentation_Inline__Maybe

func (m MaybeUnionRepresentation_Inline) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_Inline) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_Inline) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_Inline) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_Inline) Must() UnionRepresentation_Inline {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__UnionRepresentation_Inline_DiscriminantKey = _String{"discriminantKey"}
	fieldName__UnionRepresentation_Inline_DiscriminantTable = _String{"discriminantTable"}
)
var _ ipld.Node = (UnionRepresentation_Inline)(&_UnionRepresentation_Inline{})
var _ schema.TypedNode = (UnionRepresentation_Inline)(&_UnionRepresentation_Inline{})
func (UnionRepresentation_Inline) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_Inline) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantKey":
		return &n.discriminantKey, nil
	case "discriminantTable":
		return &n.discriminantTable, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UnionRepresentation_Inline) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UnionRepresentation_Inline) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.LookupByIndex(0)
}
func (n UnionRepresentation_Inline) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_Inline) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Inline__MapItr{n, 0}
}

type _UnionRepresentation_Inline__MapItr struct {
	n UnionRepresentation_Inline
	idx  int
}

func (itr *_UnionRepresentation_Inline__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_Inline_DiscriminantKey
		v = &itr.n.discriminantKey
	case 1:
		k = &fieldName__UnionRepresentation_Inline_DiscriminantTable
		v = &itr.n.discriminantTable
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Inline__MapItr) Done() bool {
	return itr.idx >= 2
}

func (UnionRepresentation_Inline) ListIterator() ipld.ListIterator {
	return nil
}
func (UnionRepresentation_Inline) Length() int {
	return 2
}
func (UnionRepresentation_Inline) IsAbsent() bool {
	return false
}
func (UnionRepresentation_Inline) IsNull() bool {
	return false
}
func (UnionRepresentation_Inline) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsBool()
}
func (UnionRepresentation_Inline) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsInt()
}
func (UnionRepresentation_Inline) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsFloat()
}
func (UnionRepresentation_Inline) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsString()
}
func (UnionRepresentation_Inline) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsBytes()
}
func (UnionRepresentation_Inline) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline"}.AsLink()
}
func (UnionRepresentation_Inline) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Inline__Prototype{}
}
type _UnionRepresentation_Inline__Prototype struct{}

func (_UnionRepresentation_Inline__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Inline__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Inline__Builder struct {
	_UnionRepresentation_Inline__Assembler
}
func (nb *_UnionRepresentation_Inline__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Inline__Builder) Reset() {
	var w _UnionRepresentation_Inline
	var m schema.Maybe
	*nb = _UnionRepresentation_Inline__Builder{_UnionRepresentation_Inline__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_Inline__Assembler struct {
	w *_UnionRepresentation_Inline
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantKey _String__Assembler
	ca_discriminantTable _Map__String__TypeName__Assembler
	}

func (na *_UnionRepresentation_Inline__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantKey.reset()
	na.ca_discriminantTable.reset()
}

var (
	fieldBit__UnionRepresentation_Inline_DiscriminantKey = 1 << 0
	fieldBit__UnionRepresentation_Inline_DiscriminantTable = 1 << 1
	fieldBits__UnionRepresentation_Inline_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_UnionRepresentation_Inline__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_Inline{}
	}
	return na, nil
}
func (_UnionRepresentation_Inline__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.BeginList(0)
}
func (na *_UnionRepresentation_Inline__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Inline__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignBool(false)
}
func (_UnionRepresentation_Inline__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignInt(0)
}
func (_UnionRepresentation_Inline__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignFloat(0)
}
func (_UnionRepresentation_Inline__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignString("")
}
func (_UnionRepresentation_Inline__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignBytes(nil)
}
func (_UnionRepresentation_Inline__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Inline__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Inline); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Inline", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Inline__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Inline__Prototype{}
}
func (ma *_UnionRepresentation_Inline__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantTable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Inline__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantKey":
		if ma.s & fieldBit__UnionRepresentation_Inline_DiscriminantKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantKey}
		}
		ma.s += fieldBit__UnionRepresentation_Inline_DiscriminantKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey, nil
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_Inline_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantTable}
		}
		ma.s += fieldBit__UnionRepresentation_Inline_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Inline", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_Inline__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_Inline__KeyAssembler)(ma)
}
func (ma *_UnionRepresentation_Inline__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey
	case 1:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Inline__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Inline__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_Inline__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _UnionRepresentation_Inline__KeyAssembler _UnionRepresentation_Inline__Assembler
func (_UnionRepresentation_Inline__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_Inline__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_Inline__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_Inline__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_Inline__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_Inline__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_Inline__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantKey":
		if ka.s & fieldBit__UnionRepresentation_Inline_DiscriminantKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantKey}
		}
		ka.s += fieldBit__UnionRepresentation_Inline_DiscriminantKey
		ka.state = maState_expectValue
		ka.f = 0
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_Inline_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantTable}
		}
		ka.s += fieldBit__UnionRepresentation_Inline_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Inline", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_Inline__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_Inline__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_Inline__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_Inline__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UnionRepresentation_Inline) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_Inline) Representation() ipld.Node {
	return (*_UnionRepresentation_Inline__Repr)(n)
}
type _UnionRepresentation_Inline__Repr _UnionRepresentation_Inline
var (
	fieldName__UnionRepresentation_Inline_DiscriminantKey_serial = _String{"discriminantKey"}
	fieldName__UnionRepresentation_Inline_DiscriminantTable_serial = _String{"discriminantTable"}
)
var _ ipld.Node = &_UnionRepresentation_Inline__Repr{}
func (_UnionRepresentation_Inline__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_UnionRepresentation_Inline__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantKey":
		return n.discriminantKey.Representation(), nil
	case "discriminantTable":
		return n.discriminantTable.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UnionRepresentation_Inline__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UnionRepresentation_Inline__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_Inline__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UnionRepresentation_Inline__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Inline__ReprMapItr{n, 0}
}

type _UnionRepresentation_Inline__ReprMapItr struct {
	n   *_UnionRepresentation_Inline__Repr
	idx int
	
}

func (itr *_UnionRepresentation_Inline__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_Inline_DiscriminantKey_serial
		v = itr.n.discriminantKey.Representation()
	case 1:
		k = &fieldName__UnionRepresentation_Inline_DiscriminantTable_serial
		v = itr.n.discriminantTable.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Inline__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_UnionRepresentation_Inline__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_Inline__Repr) Length() int {
	l := 2
	return l
}
func (_UnionRepresentation_Inline__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_Inline__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_Inline__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsBool()
}
func (_UnionRepresentation_Inline__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsInt()
}
func (_UnionRepresentation_Inline__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsFloat()
}
func (_UnionRepresentation_Inline__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsString()
}
func (_UnionRepresentation_Inline__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsBytes()
}
func (_UnionRepresentation_Inline__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Inline.Repr"}.AsLink()
}
func (_UnionRepresentation_Inline__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Inline__ReprPrototype{}
}
type _UnionRepresentation_Inline__ReprPrototype struct{}

func (_UnionRepresentation_Inline__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Inline__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Inline__ReprBuilder struct {
	_UnionRepresentation_Inline__ReprAssembler
}
func (nb *_UnionRepresentation_Inline__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Inline__ReprBuilder) Reset() {
	var w _UnionRepresentation_Inline
	var m schema.Maybe
	*nb = _UnionRepresentation_Inline__ReprBuilder{_UnionRepresentation_Inline__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_Inline__ReprAssembler struct {
	w *_UnionRepresentation_Inline
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantKey _String__ReprAssembler
	ca_discriminantTable _Map__String__TypeName__ReprAssembler
	}

func (na *_UnionRepresentation_Inline__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantKey.reset()
	na.ca_discriminantTable.reset()
}
func (na *_UnionRepresentation_Inline__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_Inline{}
	}
	return na, nil
}
func (_UnionRepresentation_Inline__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_Inline__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignString("")
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_Inline__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Inline.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Inline__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Inline); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Inline.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Inline__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Inline__ReprPrototype{}
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantKey":
		if ma.s & fieldBit__UnionRepresentation_Inline_DiscriminantKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantKey_serial}
		}
		ma.s += fieldBit__UnionRepresentation_Inline_DiscriminantKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey, nil
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_Inline_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantTable_serial}
		}
		ma.s += fieldBit__UnionRepresentation_Inline_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Inline.Repr", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_Inline__ReprKeyAssembler)(ma)
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantKey.w = &ma.w.discriminantKey
		ma.ca_discriminantKey.m = &ma.cm
		return &ma.ca_discriminantKey
	case 1:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_Inline__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _UnionRepresentation_Inline__ReprKeyAssembler _UnionRepresentation_Inline__ReprAssembler
func (_UnionRepresentation_Inline__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_Inline__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_Inline__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantKey":
		if ka.s & fieldBit__UnionRepresentation_Inline_DiscriminantKey != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantKey_serial}
		}
		ka.s += fieldBit__UnionRepresentation_Inline_DiscriminantKey
		ka.state = maState_expectValue
		ka.f = 0
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_Inline_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_Inline_DiscriminantTable_serial}
		}
		ka.s += fieldBit__UnionRepresentation_Inline_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Inline.Repr", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_Inline.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_Inline__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_Inline__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_UnionRepresentation_Keyed) Lookup(k String) TypeName {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_UnionRepresentation_Keyed) LookupMaybe(k String) MaybeTypeName {
	v, exists := n.m[*k]
	if !exists {
		return &_UnionRepresentation_Keyed__valueAbsent
	}
	return &_TypeName__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _UnionRepresentation_Keyed__valueAbsent = _TypeName__Maybe{m:schema.Maybe_Absent}
func (n UnionRepresentation_Keyed) Iterator() *UnionRepresentation_Keyed__Itr {
	return &UnionRepresentation_Keyed__Itr{n, 0}
}

type UnionRepresentation_Keyed__Itr struct {
	n UnionRepresentation_Keyed
	idx  int
}

func (itr *UnionRepresentation_Keyed__Itr) Next() (k String, v TypeName) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *UnionRepresentation_Keyed__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _UnionRepresentation_Keyed__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_Keyed
}
type MaybeUnionRepresentation_Keyed = *_UnionRepresentation_Keyed__Maybe

func (m MaybeUnionRepresentation_Keyed) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_Keyed) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_Keyed) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_Keyed) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_Keyed) Must() UnionRepresentation_Keyed {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (UnionRepresentation_Keyed)(&_UnionRepresentation_Keyed{})
var _ schema.TypedNode = (UnionRepresentation_Keyed)(&_UnionRepresentation_Keyed{})
func (UnionRepresentation_Keyed) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_Keyed) LookupByString(k string) (ipld.Node, error) {
	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n UnionRepresentation_Keyed) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(String)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Keyed", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (UnionRepresentation_Keyed) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.LookupByIndex(0)
}
func (n UnionRepresentation_Keyed) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_Keyed) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Keyed__MapItr{n, 0}
}

type _UnionRepresentation_Keyed__MapItr struct {
	n UnionRepresentation_Keyed
	idx  int
}

func (itr *_UnionRepresentation_Keyed__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Keyed__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (UnionRepresentation_Keyed) ListIterator() ipld.ListIterator {
	return nil
}
func (n UnionRepresentation_Keyed) Length() int {
	return len(n.t)
}
func (UnionRepresentation_Keyed) IsAbsent() bool {
	return false
}
func (UnionRepresentation_Keyed) IsNull() bool {
	return false
}
func (UnionRepresentation_Keyed) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsBool()
}
func (UnionRepresentation_Keyed) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsInt()
}
func (UnionRepresentation_Keyed) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsFloat()
}
func (UnionRepresentation_Keyed) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsString()
}
func (UnionRepresentation_Keyed) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsBytes()
}
func (UnionRepresentation_Keyed) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed"}.AsLink()
}
func (UnionRepresentation_Keyed) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Keyed__Prototype{}
}
type _UnionRepresentation_Keyed__Prototype struct{}

func (_UnionRepresentation_Keyed__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Keyed__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Keyed__Builder struct {
	_UnionRepresentation_Keyed__Assembler
}
func (nb *_UnionRepresentation_Keyed__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Keyed__Builder) Reset() {
	var w _UnionRepresentation_Keyed
	var m schema.Maybe
	*nb = _UnionRepresentation_Keyed__Builder{_UnionRepresentation_Keyed__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_Keyed__Assembler struct {
	w *_UnionRepresentation_Keyed
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__Assembler
	va _TypeName__Assembler
}

func (na *_UnionRepresentation_Keyed__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_UnionRepresentation_Keyed__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_UnionRepresentation_Keyed{}
	}
	na.w.m = make(map[_String]*_TypeName, sizeHint)
	na.w.t = make([]_UnionRepresentation_Keyed__entry, 0, sizeHint)
	return na, nil
}
func (_UnionRepresentation_Keyed__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.BeginList(0)
}
func (na *_UnionRepresentation_Keyed__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Keyed__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignBool(false)
}
func (_UnionRepresentation_Keyed__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignInt(0)
}
func (_UnionRepresentation_Keyed__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignFloat(0)
}
func (_UnionRepresentation_Keyed__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignString("")
}
func (_UnionRepresentation_Keyed__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignBytes(nil)
}
func (_UnionRepresentation_Keyed__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Keyed__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Keyed); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Keyed", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Keyed__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Keyed__Prototype{}
}
func (ma *_UnionRepresentation_Keyed__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Keyed__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Keyed__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Keyed__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_UnionRepresentation_Keyed__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Keyed__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_UnionRepresentation_Keyed__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_UnionRepresentation_Keyed__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Keyed__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_Keyed__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (UnionRepresentation_Keyed) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_Keyed) Representation() ipld.Node {
	return (*_UnionRepresentation_Keyed__Repr)(n)
}
type _UnionRepresentation_Keyed__Repr _UnionRepresentation_Keyed
var _ ipld.Node = &_UnionRepresentation_Keyed__Repr{}
func (_UnionRepresentation_Keyed__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_UnionRepresentation_Keyed__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (UnionRepresentation_Keyed)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (nr *_UnionRepresentation_Keyed__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (UnionRepresentation_Keyed)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (_UnionRepresentation_Keyed__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_Keyed__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_UnionRepresentation_Keyed__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Keyed__ReprMapItr{(UnionRepresentation_Keyed)(nr), 0}
}

type _UnionRepresentation_Keyed__ReprMapItr _UnionRepresentation_Keyed__MapItr

func (itr *_UnionRepresentation_Keyed__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_UnionRepresentation_Keyed__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(TypeName).Representation(), nil
}
func (itr *_UnionRepresentation_Keyed__ReprMapItr) Done() bool {
	return (*_UnionRepresentation_Keyed__MapItr)(itr).Done()
}

func (_UnionRepresentation_Keyed__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_Keyed__Repr) Length() int {
	return len(rn.t)
}
func (_UnionRepresentation_Keyed__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_Keyed__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_Keyed__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsBool()
}
func (_UnionRepresentation_Keyed__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsInt()
}
func (_UnionRepresentation_Keyed__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsFloat()
}
func (_UnionRepresentation_Keyed__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsString()
}
func (_UnionRepresentation_Keyed__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsBytes()
}
func (_UnionRepresentation_Keyed__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Keyed.Repr"}.AsLink()
}
func (_UnionRepresentation_Keyed__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Keyed__ReprPrototype{}
}
type _UnionRepresentation_Keyed__ReprPrototype struct{}

func (_UnionRepresentation_Keyed__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Keyed__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Keyed__ReprBuilder struct {
	_UnionRepresentation_Keyed__ReprAssembler
}
func (nb *_UnionRepresentation_Keyed__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Keyed__ReprBuilder) Reset() {
	var w _UnionRepresentation_Keyed
	var m schema.Maybe
	*nb = _UnionRepresentation_Keyed__ReprBuilder{_UnionRepresentation_Keyed__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_Keyed__ReprAssembler struct {
	w *_UnionRepresentation_Keyed
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__ReprAssembler
	va _TypeName__ReprAssembler
}

func (na *_UnionRepresentation_Keyed__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_UnionRepresentation_Keyed__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_UnionRepresentation_Keyed{}
	}
	na.w.m = make(map[_String]*_TypeName, sizeHint)
	na.w.t = make([]_UnionRepresentation_Keyed__entry, 0, sizeHint)
	return na, nil
}
func (_UnionRepresentation_Keyed__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_Keyed__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignString("")
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_Keyed__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Keyed.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Keyed__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Keyed); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Keyed.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Keyed__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Keyed__ReprPrototype{}
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Keyed__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Keyed__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__ReprPrototype{}
}
func (ma *_UnionRepresentation_Keyed__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__ReprPrototype{}
}

func (n *_UnionRepresentation_Kinded) Lookup(k RepresentationKind) TypeName {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	return v
}
func (n *_UnionRepresentation_Kinded) LookupMaybe(k RepresentationKind) MaybeTypeName {
	v, exists := n.m[*k]
	if !exists {
		return &_UnionRepresentation_Kinded__valueAbsent
	}
	return &_TypeName__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _UnionRepresentation_Kinded__valueAbsent = _TypeName__Maybe{m:schema.Maybe_Absent}
func (n UnionRepresentation_Kinded) Iterator() *UnionRepresentation_Kinded__Itr {
	return &UnionRepresentation_Kinded__Itr{n, 0}
}

type UnionRepresentation_Kinded__Itr struct {
	n UnionRepresentation_Kinded
	idx  int
}

func (itr *UnionRepresentation_Kinded__Itr) Next() (k RepresentationKind, v TypeName) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *UnionRepresentation_Kinded__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _UnionRepresentation_Kinded__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_Kinded
}
type MaybeUnionRepresentation_Kinded = *_UnionRepresentation_Kinded__Maybe

func (m MaybeUnionRepresentation_Kinded) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_Kinded) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_Kinded) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_Kinded) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_Kinded) Must() UnionRepresentation_Kinded {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (UnionRepresentation_Kinded)(&_UnionRepresentation_Kinded{})
var _ schema.TypedNode = (UnionRepresentation_Kinded)(&_UnionRepresentation_Kinded{})
func (UnionRepresentation_Kinded) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_Kinded) LookupByString(k string) (ipld.Node, error) {
	var k2 _RepresentationKind
	if err := (_RepresentationKind__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	return v, nil
}
func (n UnionRepresentation_Kinded) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(RepresentationKind)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_Kinded", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	return v, nil
}
func (UnionRepresentation_Kinded) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.LookupByIndex(0)
}
func (n UnionRepresentation_Kinded) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_Kinded) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Kinded__MapItr{n, 0}
}

type _UnionRepresentation_Kinded__MapItr struct {
	n UnionRepresentation_Kinded
	idx  int
}

func (itr *_UnionRepresentation_Kinded__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *_UnionRepresentation_Kinded__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (UnionRepresentation_Kinded) ListIterator() ipld.ListIterator {
	return nil
}
func (n UnionRepresentation_Kinded) Length() int {
	return len(n.t)
}
func (UnionRepresentation_Kinded) IsAbsent() bool {
	return false
}
func (UnionRepresentation_Kinded) IsNull() bool {
	return false
}
func (UnionRepresentation_Kinded) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsBool()
}
func (UnionRepresentation_Kinded) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsInt()
}
func (UnionRepresentation_Kinded) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsFloat()
}
func (UnionRepresentation_Kinded) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsString()
}
func (UnionRepresentation_Kinded) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsBytes()
}
func (UnionRepresentation_Kinded) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded"}.AsLink()
}
func (UnionRepresentation_Kinded) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Kinded__Prototype{}
}
type _UnionRepresentation_Kinded__Prototype struct{}

func (_UnionRepresentation_Kinded__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Kinded__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Kinded__Builder struct {
	_UnionRepresentation_Kinded__Assembler
}
func (nb *_UnionRepresentation_Kinded__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Kinded__Builder) Reset() {
	var w _UnionRepresentation_Kinded
	var m schema.Maybe
	*nb = _UnionRepresentation_Kinded__Builder{_UnionRepresentation_Kinded__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_Kinded__Assembler struct {
	w *_UnionRepresentation_Kinded
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _RepresentationKind__Assembler
	va _TypeName__Assembler
}

func (na *_UnionRepresentation_Kinded__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_UnionRepresentation_Kinded__Assembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_UnionRepresentation_Kinded{}
	}
	na.w.m = make(map[_RepresentationKind]*_TypeName, sizeHint)
	na.w.t = make([]_UnionRepresentation_Kinded__entry, 0, sizeHint)
	return na, nil
}
func (_UnionRepresentation_Kinded__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.BeginList(0)
}
func (na *_UnionRepresentation_Kinded__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Kinded__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignBool(false)
}
func (_UnionRepresentation_Kinded__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignInt(0)
}
func (_UnionRepresentation_Kinded__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignFloat(0)
}
func (_UnionRepresentation_Kinded__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignString("")
}
func (_UnionRepresentation_Kinded__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignBytes(nil)
}
func (_UnionRepresentation_Kinded__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Kinded__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Kinded); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Kinded", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Kinded__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Kinded__Prototype{}
}
func (ma *_UnionRepresentation_Kinded__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Kinded__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Kinded__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _RepresentationKind
	if err := (_RepresentationKind__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Kinded__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_UnionRepresentation_Kinded__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Kinded__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_UnionRepresentation_Kinded__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_UnionRepresentation_Kinded__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Kinded__Assembler) KeyPrototype() ipld.NodePrototype {
	return _RepresentationKind__Prototype{}
}
func (ma *_UnionRepresentation_Kinded__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__Prototype{}
}
func (UnionRepresentation_Kinded) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_Kinded) Representation() ipld.Node {
	return (*_UnionRepresentation_Kinded__Repr)(n)
}
type _UnionRepresentation_Kinded__Repr _UnionRepresentation_Kinded
var _ ipld.Node = &_UnionRepresentation_Kinded__Repr{}
func (_UnionRepresentation_Kinded__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (nr *_UnionRepresentation_Kinded__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (UnionRepresentation_Kinded)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (nr *_UnionRepresentation_Kinded__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (UnionRepresentation_Kinded)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(TypeName).Representation(), nil
}
func (_UnionRepresentation_Kinded__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_Kinded__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_UnionRepresentation_Kinded__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_Kinded__ReprMapItr{(UnionRepresentation_Kinded)(nr), 0}
}

type _UnionRepresentation_Kinded__ReprMapItr _UnionRepresentation_Kinded__MapItr

func (itr *_UnionRepresentation_Kinded__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_UnionRepresentation_Kinded__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(TypeName).Representation(), nil
}
func (itr *_UnionRepresentation_Kinded__ReprMapItr) Done() bool {
	return (*_UnionRepresentation_Kinded__MapItr)(itr).Done()
}

func (_UnionRepresentation_Kinded__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_Kinded__Repr) Length() int {
	return len(rn.t)
}
func (_UnionRepresentation_Kinded__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_Kinded__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_Kinded__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsBool()
}
func (_UnionRepresentation_Kinded__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsInt()
}
func (_UnionRepresentation_Kinded__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsFloat()
}
func (_UnionRepresentation_Kinded__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsString()
}
func (_UnionRepresentation_Kinded__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsBytes()
}
func (_UnionRepresentation_Kinded__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_Kinded.Repr"}.AsLink()
}
func (_UnionRepresentation_Kinded__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Kinded__ReprPrototype{}
}
type _UnionRepresentation_Kinded__ReprPrototype struct{}

func (_UnionRepresentation_Kinded__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_Kinded__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_Kinded__ReprBuilder struct {
	_UnionRepresentation_Kinded__ReprAssembler
}
func (nb *_UnionRepresentation_Kinded__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_Kinded__ReprBuilder) Reset() {
	var w _UnionRepresentation_Kinded
	var m schema.Maybe
	*nb = _UnionRepresentation_Kinded__ReprBuilder{_UnionRepresentation_Kinded__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_Kinded__ReprAssembler struct {
	w *_UnionRepresentation_Kinded
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _RepresentationKind__ReprAssembler
	va _TypeName__ReprAssembler
}

func (na *_UnionRepresentation_Kinded__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_UnionRepresentation_Kinded__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_UnionRepresentation_Kinded{}
	}
	na.w.m = make(map[_RepresentationKind]*_TypeName, sizeHint)
	na.w.t = make([]_UnionRepresentation_Kinded__entry, 0, sizeHint)
	return na, nil
}
func (_UnionRepresentation_Kinded__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_Kinded__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignString("")
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_Kinded__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_Kinded.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_Kinded__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_Kinded); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_Kinded.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_Kinded__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_Kinded__ReprPrototype{}
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.w = &tz.v
		ma.va.m = &ma.cm
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.va.w = nil
		ma.cm = schema.Maybe_Absent
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _RepresentationKind
	if err := (_RepresentationKind__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Kinded__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.w = &tz.v
	ma.va.m = &ma.cm
	return &ma.va, nil
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _UnionRepresentation_Kinded__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _RepresentationKind__ReprPrototype{}
}
func (ma *_UnionRepresentation_Kinded__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _TypeName__ReprPrototype{}
}


func (n _UnionRepresentation_StringPrefix) FieldDiscriminantTable() Map__String__TypeName {
	return &n.discriminantTable
}
type _UnionRepresentation_StringPrefix__Maybe struct {
	m schema.Maybe
	v UnionRepresentation_StringPrefix
}
type MaybeUnionRepresentation_StringPrefix = *_UnionRepresentation_StringPrefix__Maybe

func (m MaybeUnionRepresentation_StringPrefix) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnionRepresentation_StringPrefix) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnionRepresentation_StringPrefix) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnionRepresentation_StringPrefix) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnionRepresentation_StringPrefix) Must() UnionRepresentation_StringPrefix {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__UnionRepresentation_StringPrefix_DiscriminantTable = _String{"discriminantTable"}
)
var _ ipld.Node = (UnionRepresentation_StringPrefix)(&_UnionRepresentation_StringPrefix{})
var _ schema.TypedNode = (UnionRepresentation_StringPrefix)(&_UnionRepresentation_StringPrefix{})
func (UnionRepresentation_StringPrefix) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n UnionRepresentation_StringPrefix) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantTable":
		return &n.discriminantTable, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UnionRepresentation_StringPrefix) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UnionRepresentation_StringPrefix) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.LookupByIndex(0)
}
func (n UnionRepresentation_StringPrefix) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UnionRepresentation_StringPrefix) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_StringPrefix__MapItr{n, 0}
}

type _UnionRepresentation_StringPrefix__MapItr struct {
	n UnionRepresentation_StringPrefix
	idx  int
}

func (itr *_UnionRepresentation_StringPrefix__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_StringPrefix_DiscriminantTable
		v = &itr.n.discriminantTable
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_StringPrefix__MapItr) Done() bool {
	return itr.idx >= 1
}

func (UnionRepresentation_StringPrefix) ListIterator() ipld.ListIterator {
	return nil
}
func (UnionRepresentation_StringPrefix) Length() int {
	return 1
}
func (UnionRepresentation_StringPrefix) IsAbsent() bool {
	return false
}
func (UnionRepresentation_StringPrefix) IsNull() bool {
	return false
}
func (UnionRepresentation_StringPrefix) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsBool()
}
func (UnionRepresentation_StringPrefix) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsInt()
}
func (UnionRepresentation_StringPrefix) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsFloat()
}
func (UnionRepresentation_StringPrefix) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsString()
}
func (UnionRepresentation_StringPrefix) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsBytes()
}
func (UnionRepresentation_StringPrefix) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix"}.AsLink()
}
func (UnionRepresentation_StringPrefix) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_StringPrefix__Prototype{}
}
type _UnionRepresentation_StringPrefix__Prototype struct{}

func (_UnionRepresentation_StringPrefix__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_StringPrefix__Builder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_StringPrefix__Builder struct {
	_UnionRepresentation_StringPrefix__Assembler
}
func (nb *_UnionRepresentation_StringPrefix__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_StringPrefix__Builder) Reset() {
	var w _UnionRepresentation_StringPrefix
	var m schema.Maybe
	*nb = _UnionRepresentation_StringPrefix__Builder{_UnionRepresentation_StringPrefix__Assembler{w: &w, m: &m}}
}
type _UnionRepresentation_StringPrefix__Assembler struct {
	w *_UnionRepresentation_StringPrefix
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantTable _Map__String__TypeName__Assembler
	}

func (na *_UnionRepresentation_StringPrefix__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantTable.reset()
}

var (
	fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable = 1 << 0
	fieldBits__UnionRepresentation_StringPrefix_sufficient = 0 + 1 << 0
)
func (na *_UnionRepresentation_StringPrefix__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_StringPrefix{}
	}
	return na, nil
}
func (_UnionRepresentation_StringPrefix__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.BeginList(0)
}
func (na *_UnionRepresentation_StringPrefix__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignBool(false)
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignInt(0)
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignFloat(0)
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignString("")
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignBytes(nil)
}
func (_UnionRepresentation_StringPrefix__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix"}.AssignLink(nil)
}
func (na *_UnionRepresentation_StringPrefix__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_StringPrefix); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_StringPrefix", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_StringPrefix__Assembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_StringPrefix__Prototype{}
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_discriminantTable.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_StringPrefix_DiscriminantTable}
		}
		ma.s += fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_StringPrefix", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_StringPrefix__KeyAssembler)(ma)
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_StringPrefix__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _UnionRepresentation_StringPrefix__KeyAssembler _UnionRepresentation_StringPrefix__Assembler
func (_UnionRepresentation_StringPrefix__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_StringPrefix__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_StringPrefix__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_StringPrefix_DiscriminantTable}
		}
		ka.s += fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_StringPrefix", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_StringPrefix__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_StringPrefix__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UnionRepresentation_StringPrefix) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UnionRepresentation_StringPrefix) Representation() ipld.Node {
	return (*_UnionRepresentation_StringPrefix__Repr)(n)
}
type _UnionRepresentation_StringPrefix__Repr _UnionRepresentation_StringPrefix
var (
	fieldName__UnionRepresentation_StringPrefix_DiscriminantTable_serial = _String{"discriminantTable"}
)
var _ ipld.Node = &_UnionRepresentation_StringPrefix__Repr{}
func (_UnionRepresentation_StringPrefix__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_UnionRepresentation_StringPrefix__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "discriminantTable":
		return n.discriminantTable.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UnionRepresentation_StringPrefix__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UnionRepresentation_StringPrefix__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.LookupByIndex(0)
}
func (n _UnionRepresentation_StringPrefix__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UnionRepresentation_StringPrefix__Repr) MapIterator() ipld.MapIterator {
	return &_UnionRepresentation_StringPrefix__ReprMapItr{n, 0}
}

type _UnionRepresentation_StringPrefix__ReprMapItr struct {
	n   *_UnionRepresentation_StringPrefix__Repr
	idx int
	
}

func (itr *_UnionRepresentation_StringPrefix__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UnionRepresentation_StringPrefix_DiscriminantTable_serial
		v = itr.n.discriminantTable.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UnionRepresentation_StringPrefix__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_UnionRepresentation_StringPrefix__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UnionRepresentation_StringPrefix__Repr) Length() int {
	l := 1
	return l
}
func (_UnionRepresentation_StringPrefix__Repr) IsAbsent() bool {
	return false
}
func (_UnionRepresentation_StringPrefix__Repr) IsNull() bool {
	return false
}
func (_UnionRepresentation_StringPrefix__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsBool()
}
func (_UnionRepresentation_StringPrefix__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsInt()
}
func (_UnionRepresentation_StringPrefix__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsFloat()
}
func (_UnionRepresentation_StringPrefix__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsString()
}
func (_UnionRepresentation_StringPrefix__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsBytes()
}
func (_UnionRepresentation_StringPrefix__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AsLink()
}
func (_UnionRepresentation_StringPrefix__Repr) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_StringPrefix__ReprPrototype{}
}
type _UnionRepresentation_StringPrefix__ReprPrototype struct{}

func (_UnionRepresentation_StringPrefix__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UnionRepresentation_StringPrefix__ReprBuilder
	nb.Reset()
	return &nb
}
type _UnionRepresentation_StringPrefix__ReprBuilder struct {
	_UnionRepresentation_StringPrefix__ReprAssembler
}
func (nb *_UnionRepresentation_StringPrefix__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UnionRepresentation_StringPrefix__ReprBuilder) Reset() {
	var w _UnionRepresentation_StringPrefix
	var m schema.Maybe
	*nb = _UnionRepresentation_StringPrefix__ReprBuilder{_UnionRepresentation_StringPrefix__ReprAssembler{w: &w, m: &m}}
}
type _UnionRepresentation_StringPrefix__ReprAssembler struct {
	w *_UnionRepresentation_StringPrefix
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_discriminantTable _Map__String__TypeName__ReprAssembler
	}

func (na *_UnionRepresentation_StringPrefix__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_discriminantTable.reset()
}
func (na *_UnionRepresentation_StringPrefix__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UnionRepresentation_StringPrefix{}
	}
	return na, nil
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.BeginList(0)
}
func (na *_UnionRepresentation_StringPrefix__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignBool(false)
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignInt(0)
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignFloat(0)
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignString("")
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignBytes(nil)
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr"}.AssignLink(nil)
}
func (na *_UnionRepresentation_StringPrefix__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UnionRepresentation_StringPrefix); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.UnionRepresentation_StringPrefix.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UnionRepresentation_StringPrefix__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UnionRepresentation_StringPrefix__ReprPrototype{}
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "discriminantTable":
		if ma.s & fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_StringPrefix_DiscriminantTable_serial}
		}
		ma.s += fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_StringPrefix.Repr", Key:&_String{k}}
	}
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UnionRepresentation_StringPrefix__ReprKeyAssembler)(ma)
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_discriminantTable.w = &ma.w.discriminantTable
		ma.ca_discriminantTable.m = &ma.cm
		return &ma.ca_discriminantTable
	default:
		panic("unreachable")
	}
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UnionRepresentation_StringPrefix__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _UnionRepresentation_StringPrefix__ReprKeyAssembler _UnionRepresentation_StringPrefix__ReprAssembler
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignNull()
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "discriminantTable":
		if ka.s & fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UnionRepresentation_StringPrefix_DiscriminantTable_serial}
		}
		ka.s += fieldBit__UnionRepresentation_StringPrefix_DiscriminantTable
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.UnionRepresentation_StringPrefix.Repr", Key:&_String{k}}
	}
	return nil
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.UnionRepresentation_StringPrefix.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UnionRepresentation_StringPrefix__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UnionRepresentation_StringPrefix__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


type _Unit__Maybe struct {
	m schema.Maybe
	v Unit
}
type MaybeUnit = *_Unit__Maybe

func (m MaybeUnit) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUnit) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUnit) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUnit) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUnit) Must() Unit {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
)
var _ ipld.Node = (Unit)(&_Unit{})
var _ schema.TypedNode = (Unit)(&_Unit{})
func (Unit) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n Unit) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Unit) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Unit) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Unit"}.LookupByIndex(0)
}
func (n Unit) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Unit) MapIterator() ipld.MapIterator {
	return &_Unit__MapItr{n, 0}
}

type _Unit__MapItr struct {
	n Unit
	idx  int
}

func (itr *_Unit__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Unit__MapItr) Done() bool {
	return itr.idx >= 0
}

func (Unit) ListIterator() ipld.ListIterator {
	return nil
}
func (Unit) Length() int {
	return 0
}
func (Unit) IsAbsent() bool {
	return false
}
func (Unit) IsNull() bool {
	return false
}
func (Unit) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Unit"}.AsBool()
}
func (Unit) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Unit"}.AsInt()
}
func (Unit) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Unit"}.AsFloat()
}
func (Unit) AsString() (string, error) {
	return mixins.Map{"schemadmt.Unit"}.AsString()
}
func (Unit) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Unit"}.AsBytes()
}
func (Unit) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Unit"}.AsLink()
}
func (Unit) Prototype() ipld.NodePrototype {
	return _Unit__Prototype{}
}
type _Unit__Prototype struct{}

func (_Unit__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Unit__Builder
	nb.Reset()
	return &nb
}
type _Unit__Builder struct {
	_Unit__Assembler
}
func (nb *_Unit__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Unit__Builder) Reset() {
	var w _Unit
	var m schema.Maybe
	*nb = _Unit__Builder{_Unit__Assembler{w: &w, m: &m}}
}
type _Unit__Assembler struct {
	w *_Unit
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_Unit__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
}

var (
	fieldBits__Unit_sufficient = 0
)
func (na *_Unit__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Unit{}
	}
	return na, nil
}
func (_Unit__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Unit"}.BeginList(0)
}
func (na *_Unit__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Unit"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Unit__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignBool(false)
}
func (_Unit__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignInt(0)
}
func (_Unit__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignFloat(0)
}
func (_Unit__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignString("")
}
func (_Unit__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignBytes(nil)
}
func (_Unit__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Unit"}.AssignLink(nil)
}
func (na *_Unit__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Unit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Unit", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Unit__Assembler) Prototype() ipld.NodePrototype {
	return _Unit__Prototype{}
}
func (ma *_Unit__Assembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_Unit__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.Unit", Key:&_String{k}}
	}
}
func (ma *_Unit__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Unit__KeyAssembler)(ma)
}
func (ma *_Unit__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_Unit__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Unit__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Unit__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _Unit__KeyAssembler _Unit__Assembler
func (_Unit__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.BeginMap(0)
}
func (_Unit__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.BeginList(0)
}
func (na *_Unit__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignNull()
}
func (_Unit__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignBool(false)
}
func (_Unit__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignInt(0)
}
func (_Unit__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Unit__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.Unit", Key:&_String{k}}
	}
	return nil
}
func (_Unit__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignBytes(nil)
}
func (_Unit__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.Unit.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Unit__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Unit__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Unit) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Unit) Representation() ipld.Node {
	return (*_Unit__Repr)(n)
}
type _Unit__Repr _Unit
var (
)
var _ ipld.Node = &_Unit__Repr{}
func (_Unit__Repr) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n *_Unit__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Unit__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Unit__Repr) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.LookupByIndex(0)
}
func (n _Unit__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Unit__Repr) MapIterator() ipld.MapIterator {
	return &_Unit__ReprMapItr{n, 0}
}

type _Unit__ReprMapItr struct {
	n   *_Unit__Repr
	idx int
	
}

func (itr *_Unit__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 0 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Unit__ReprMapItr) Done() bool {
	return itr.idx >= 0
}
func (_Unit__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Unit__Repr) Length() int {
	l := 0
	return l
}
func (_Unit__Repr) IsAbsent() bool {
	return false
}
func (_Unit__Repr) IsNull() bool {
	return false
}
func (_Unit__Repr) AsBool() (bool, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsBool()
}
func (_Unit__Repr) AsInt() (int, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsInt()
}
func (_Unit__Repr) AsFloat() (float64, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsFloat()
}
func (_Unit__Repr) AsString() (string, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsString()
}
func (_Unit__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsBytes()
}
func (_Unit__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"schemadmt.Unit.Repr"}.AsLink()
}
func (_Unit__Repr) Prototype() ipld.NodePrototype {
	return _Unit__ReprPrototype{}
}
type _Unit__ReprPrototype struct{}

func (_Unit__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Unit__ReprBuilder
	nb.Reset()
	return &nb
}
type _Unit__ReprBuilder struct {
	_Unit__ReprAssembler
}
func (nb *_Unit__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Unit__ReprBuilder) Reset() {
	var w _Unit
	var m schema.Maybe
	*nb = _Unit__ReprBuilder{_Unit__ReprAssembler{w: &w, m: &m}}
}
type _Unit__ReprAssembler struct {
	w *_Unit
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	}

func (na *_Unit__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
}
func (na *_Unit__ReprAssembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Unit{}
	}
	return na, nil
}
func (_Unit__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.BeginList(0)
}
func (na *_Unit__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"schemadmt.Unit.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Unit__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignBool(false)
}
func (_Unit__ReprAssembler) AssignInt(int) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignInt(0)
}
func (_Unit__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignFloat(0)
}
func (_Unit__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignString("")
}
func (_Unit__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignBytes(nil)
}
func (_Unit__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"schemadmt.Unit.Repr"}.AssignLink(nil)
}
func (na *_Unit__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Unit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "schemadmt.Unit.Repr", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Unit__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Unit__ReprPrototype{}
}
func (ma *_Unit__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_Unit__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"schemadmt.Unit.Repr", Key:&_String{k}}
	}
}
func (ma *_Unit__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Unit__ReprKeyAssembler)(ma)
}
func (ma *_Unit__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	default:
		panic("unreachable")
	}
}
func (ma *_Unit__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	//FIXME check if all required fields are set
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Unit__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Unit__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _Unit__ReprKeyAssembler _Unit__ReprAssembler
func (_Unit__ReprKeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Unit__ReprKeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Unit__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignNull()
}
func (_Unit__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Unit__ReprKeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Unit__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Unit__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	default:
		return ipld.ErrInvalidKey{TypeName:"schemadmt.Unit.Repr", Key:&_String{k}}
	}
	return nil
}
func (_Unit__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Unit__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"schemadmt.Unit.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Unit__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Unit__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

